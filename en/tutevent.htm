<html>
<head>
   <title>Event Driven Programs</title>
<LINK REL="stylesheet" type="text/css" href="tutor.css">
<LINK REL="stylesheet" type="text/css" href="colors.css">
</head>
<body bgcolor="#CCBBCC">

<CENTER>
<h2>Event Driven Programming</h2>

<P>
<TABLE>
<TR><TH>What will we cover?</TH></TR>
<TR><TD>
<UL>
<LI>How does an event driven program differ from a batch program?
<LI>How to write an event loop
<LI>How to use an event framework such as Tkinter
</UL>
</TD></TR></TABLE>
</CENTER>

<P>So far we have been looking at batch oriented programs. Recall that programs
can be <i><a href="tutwhat.htm#batch">batch oriented</a></i>, whereby they 
start, do something then stop, or <i>event driven</i> where they start, 
wait for <i>events</i> and only stop when told to do so - by an event. 
How do we create an event driven program? We'll look at this in two 
ways - first we will simulate an event environment then we'll create 
a very simple GUI program that uses the operating system and 
environment to generate events.

<h3>Simulating an Event Loop</h3>

<P>Every event driven program has a loop somewhere that catches received 
events and processes them. The events may be generated by the operating 
environment, as happens with virtually all GUI programs or the program itself 
may go looking for events as is often the case in embedded control systems 
such as used in cameras etc.

<p>We will create a program that looks for precisely one type of event
- keyboard input - and processes the results until some quit event is received.
In our case the quit event will be the space key. We will process the incoming
events in a very simple manner - we will simply print the ASCII code
for that key. We'll use Python for this because it has a nice, easy to
use function for reading keys one at a time - <TT>getch()</TT>. This 
function comes in two varieties depending on the operating system you 
use. If you are using Linux it's found in the <TT>curses</TT> module, 
if you use Windows it's in the <TT>msvcrt</TT> module. I'll use the 
Windows version but if you are on Linux just substitute 
<TT>curses.stdscr</TT> for <TT>msvcrt</TT> and it should work 
just fine.

<P>First we implement the event handler function that will be 
called when a keypress is detected then the main program body 
which simply starts up the event gathering loop and calls the 
event handling function when a valid event is detected.

<PRE>
import msvcrt

def doKeyEvent(key):
    if key == '\x00' or key == '\xe0': <SPAN CLASS="comment"># non ASCII</SPAN>
       key = msvcrt.getch() <SPAN CLASS="comment"># fetch second character</SPAN>
    print ord(key)

def doQuitEvent(key):
    raise SystemExit

<SPAN CLASS="comment">
# First, clear the screen of clutter then warn the user 
# of what to do to quit</SPAN>
lines = 25 <SPAN CLASS="comment"># set to number of lines in console</SPAN>
for line in range(lines): print

print "Hit space to end..."
print

<SPAN CLASS="comment"># Now mainloop runs "forever"</SPAN>
while True:
   ky = msvcrt.getch()
   length = len(ky)
   if length != 0:
      <SPAN CLASS="comment"># send events to event handling functions</SPAN>
      if ky == " ": <SPAN CLASS="comment"># check for quit event</SPAN>
         doQuitEvent(ky)
      else: 
         doKeyEvent(ky)
</PRE>

<P>Notice that what we do with the events is of no interest to
the main body, it simply collects the events and passes them to
the event handlers. This Independence of event capture and
processing is a key feature of event driven programming. 

<P><B>Note:</B> Where the key was non ASCII - a Function key 
for example - we needed to fetch a second character from the 
keyboard, this is because these special keys actually generate 
pairs of bytes and <TT>getch</TT> only retrieves one at a 
time. The actual value of interest is the second byte.

<P>If we were creating this as a framework for use in lots of
projects we would probably include a call to an <I>initialization</I>
function at the start and a <I>cleanup</I> function at the end. The
programmer could then use the loop part and provide his own
initialization, processing and cleanup functions.

<P>That's exactly what most GUI type environments do, in that the
loop part is embedded in the operating environment or framework
and applications are <I>contractually required</I> to provide the
event handling functions and <I>hook</I> these into the event
loop in some way. 

<P>Let's see that in action as we explore Python's Tkinter GUI
library.

<H3>A GUI program</H3>

<P>For this exercise we'll use the Python Tkinter toolkit. This
is a Python wrapper around the Tk toolkit originally written as
an extension to Tcl and also available for Perl. The Python
version is an object oriented framework which is, in my opinion,
considerably easier to work with than the original procedural
Tk version. We will look much more closely at the principles 
of GUI programming in the <A href="tutgui.htm">GUI</A> topic.

<P>I am not going to dwell much on the GUI aspects in this topic, 
rather I want to focus on the <I>style</I> of programming 
- using Tkinter to handle the event loop and leaving the 
programmer to create the initial GUI and then process the 
events as they arrive.

<P>In the example we create an application class <TT>KeysApp
</TT> which creates the GUI in the <TT>__init__</TT> method and
<I>binds</I> the space key to the <TT>doQuitEvent</TT> method.
The class also defines the required <TT>doQuitEvent </TT> method. 

<P>The GUI itself simply consists of a text entry <I>widget</I>
whose default behavior is to echo characters typed onto the
display. 

<P>Creating an application class is quite common in OO event
driven environments because there is a lot of synergy between the
concepts of events being sent to a program and messages being
sent to an object. The two concepts map on to each other very
easily. An event handling function thus becomes a method of the
application class. 

<P>Having defined the class we simply create an instance of it
and then send it the <TT>mainloop</TT> message.

<P>The code looks like this:
<PRE>
<SPAN CLASS="comment">
# Use from X import * to save having to preface everything 
# as tkinter.xxx</SPAN>
from Tkinter import *
<SPAN CLASS="comment">
# Create the application class which defines the GUI 
# and the event handling methods</SPAN>
class KeysApp(Frame):
    def __init__(self): <SPAN CLASS="comment"># use constructor to build GUI</SPAN>
        Frame.__init__(self)
        self.txtBox = Text(self)
        self.txtBox.bind("&lt;space&gt;", self.doQuitEvent)
        self.txtBox.pack()
        self.pack()

    def doQuitEvent(self,event):
        import sys
        sys.exit()
        
<SPAN CLASS="comment">
# Now create an instance and start the event loop running</SPAN>
myApp = KeysApp()
myApp.mainloop()
</PRE>

<P>Notice that we don't even implement a key event handler! 
That's because the default behavior of the Text widget is 
to print out the keys pressed. However that does mean our 
programs are not really functionally equivalent. In the 
console version we printed the ASCII codes of all keys 
rather than only printing the alphanumeric versions of
printable keys as we do here. There's nothing to prevent us
capturing all of the keypresses and doing the same thing. To do
so we would add the following line to the <TT>__init__</TT>
method:

<PRE>
self.txtBox.bind("&lt;Key&gt;", self.doKeyEvent)
</PRE>

<P>And the following method to process the event:
<PRE>
def doKeyEvent(self,event):
    str = "%d\n" % event.keycode
    self.txtBox.insert(END, str)
    return "break"
</PRE>

<P><B>Note 1: </B>the key value is stored in the
<TT>keycode</TT> field of the event. I had to look at the
source code of Tkinter.py to find that out... Recall that
curiosity is a key attribute of a programmer?!

<P><B>Note 2: </B><TT>return "break"</TT> is a magic signal to
tell Tkinter not to invoke the default event processing for that
widget. Without that line, the text box displays the ASCII code
followed by the actual character typed, which is not what we
want here. 

<P>That's enough on Tkinter for now. This isn't meant to be a 
Tkinter tutorial, that's the subject of the next topic. There are also 
several books on using Tk and Tkinter.</P> 

<H3>Event Driven Programming in VBScript and JavaScript</H3>

<P>Both VBScript and JavaScript can be used in an event driven 
manner when programming a web browser. Normally when a web page 
containing script code is loaded the script is executed in 
a batch fashion as the page loads. However if the script contains 
nothing but function definitions the execution will do nothing 
but define the functions ready for use, but the functions will 
not be called initially. Instead, in the HTML part of the page 
the functions will be bound to HTML elements - usually within 
a Form element - such that when events occur the functions 
are called. We have already seen this in the JavaScript example 
of getting user input, when we read the input from an HTML 
form. Let's look at that example again more closely and see 
how it really is an example of event driven programming within 
a web page:
<PRE>
&lt;script language="JavaScript">
function myProgram(){
   alert("We got a value of " + document.entry.data.value);
}
&lt;/script>

&lt;form name='entry'>
&lt;P>Type value then click outside the field with your mouse&lt;/P>
&lt;Input Type='text' Name='data' onChange='myProgram()'>
&lt;/form>
</PRE>

<P>The script part simply defines a JavaScript function, 
and the definition is executed when the page loads. The 
HTML code then creates a <TT>Form</TT> with an <TT>Input</TT> 
element. As part of the <TT>Input</TT> definition we bind 
the <TT>onChange</TT> event to a short block of JavaScript 
which simply executes our <TT>myProgram()</TT> event handler.
Now when the user changes the content of the <TT>Input</TT> 
box the browser executes our event handler. The event loop 
is embedded inside the browser.

<P>VBScript can be used in exactly the same way except that 
the function definitions are all in VBScript instead of 
JavaScript, like this:

<PRE>
&lt;script language="VBScript">
Sub myProgram()
   MsgBox "We got a value of " & Document.entry2.data.value
End Sub
&lt;/script>

&lt;form name='entry2'>
&lt;P>Type value then click outside the field with your mouse&lt;/P>
&lt;Input Type='text' Name='data' onChange='myProgram()'>
&lt;/form>
</PRE>

<P>Thus we can see that web browser code can be written in 
batch form or event driven form or a combination of styles 
to suit our needs.

<center>
<P><TABLE>
<TR><TH>Things to remember</TH></TR>
<TR><TD><UL>
<LI>Event loops do not care about the events they detect
<LI>Event handlers handle one single event at a time
<LI>Frameworks such as Tkinter provide an event loop and often 
some default event handlers too. 
<LI>Web browsers provide for both batch and event driven coding 
styles, or even a mixture of both.
</UL></TD></TR></TABLE>

<p>
<hr WIDTH="60%">
<a href="tutname.htm" target="text">Previous</a>&nbsp;
<a href="tutgui.htm" target="text">Next</a>&nbsp;
<a href="tutcont.htm" target="contents">Contents</a>
<br>&nbsp;
<p>If you have any questions or feedback on this page send me mail at:
<a href="mailto:alan.gauld@btinternet.com">alan.gauld@btinternet.com</a></center>

</body>
</html>

Decisions, Decisions	Větvení, aneb nechť padne rozhodnutí	tutbranch-cztutbranch
What will we cover?	O čem si budeme povídat?	tutbranch-cztutbranch
The 3rd programming construct - Branching	Třetí programová konstrukce — větvení.	tutbranch-cztutbranch
Single branches and multiple branches	Jednoduché a násobné větvení.	tutbranch-cztutbranch
Using Boolean expressions	Použití boolovských výrazů.	tutbranch-cztutbranch
The 3rd of our fundamental building blocks is branching or conditional statements.	Třetím z našich základních stavebních kamenů je větvení nebo také podmíněný příkaz.	tutbranch-cztutbranch
These are simply terms to describe the ability within our programs to execute one of several possible sequences of code(branches) depending on some condition.	Jde jednoduše o pojmy, které popisují schopnost provést jednu z několika možných posloupností příkazů (jednu z větví) a to v závislosti na nějaké podmínce.	tutbranch-cztutbranch
Back in the early days of Assembler programming the simplest branch was a JUMP instruction where the program literally jumped to a specified memory address, usually if the result of the previous instruction was zero.	Dříve, v době programování v assembleru, bylo větvení realizováno nejjednodušším možným způsobem — použitím instrukce JUMP. Program v tomto místě doslova skočil na určenou adresu v paměti. Obvykle to bylo podmíněno tím, že výsledkem předchozí instrukce byla nula.	tutbranch-cztutbranch
Amazingly complex programs were written with virtually no other form of condition possible - vindicating Dijkstra's statement about the minimum requirements for programming.	I když nebylo možné použít jiný způsob realizace podmíněného příkazu, byly takto napsány úžasně složité programy. To potvrzovalo správnost Dijkstrových tvrzení o minimálních požadavcích potřebných pro programování.	tutbranch-cztutbranch
When high level languages came along a new version of the JUMP instruction appeared called GOTO.	Když se objevily vyšší programovací jazyky, objevila se i nová podoba instrukce JUMP pod názvem GOTO.	tutbranch-cztutbranch
In fact QBASIC, which is still supplied on the CD ROM with older versions of Windows(pre XP), still provides GOTO and, if you have QBASIC installed, you can try it out by typing the following bit of code:	V jazyce QBASIC, který byl dodáván na instalačních CD ROM starších verzí Windows (před XP), lze GOTO stále používat. Pokud máte QBASIC nainstalován, můžete si vyzkoušet následující úsek kódu:	tutbranch-cztutbranch
10 PRINT "Starting at line 10" 20 J = 5 30 IF J	10 PRINT "Začínáme na řádku 10" 20 J = 5 30 IF J	tutbranch-cztutbranch
Notice how even in such a short program it takes a few seconds to figure out what's going to happen.	Povšimněte si, že dokonce i u tak krátkého programu trvá několik sekund, než přijdete na to co se stane.	tutbranch-cztutbranch
There is no structure to the code, you have to literally figure it out as you read it. In large programs it becomes impossible.	Kód nemá žádnou strukturu. Musíte si ji během čtení doslova vytvořit. U velkých programů to začne být prakticky nemožné.	tutbranch-cztutbranch
For that reason most modern programming languages, including Python, VBScript and JavaScript, either don't have a direct JUMP or GOTO statement or discourage you from using it.	Z tohoto důvodu většina moderních programovacích jazyků — včetně jazyků Python, VBScript a JavaScript — buď příkazy skoku JUMP nebo GOTO nemají, nebo vás od jejich používání odrazují.	tutbranch-cztutbranch
So what do we use instead?	Takže co bychom vlastně místo nich měli použít?	tutbranch-cztutbranch
The if statement	Příkaz if	tutbranch-cztutbranch
The most intuitively obvious conditional statement is the if, then, else construct.	Intuitivně nejzřejmější podobou podmíněného příkazu je konstrukce if, then, else.	tutbranch-cztutbranch
It follows the logic of English in that if some boolean condition (see below for more about this aspect of things) is true then a block of statements is executed, otherwise (or else ) a different block is executed.	Sleduje logiku anglické věty v tom smyslu, že if (jestliže) je nějaká boolovská podmínka splněna (o boolovských podmínkách se zmíníme dále v textu), then (pak) se provede blok příkazů, v opačném případě (nebo else (jinak)) se provede jiný blok.	tutbranch-cztutbranch
Python	Python	tutbranch-cztutbranch
It looks like this in Python:	V jazyce Python vypadá zápis takto:	tutbranch-cztutbranch
import sys # only to let us exit print "Starting here" j = 5 if j > 10: print "This is never printed" else: sys.exit()	import sys # jen proto, abychom mohli program ukončit print "Začínáme zde" j = 5 if j > 10: print "Toto se nikdy nevytiskne" else: sys.exit()	tutbranch-cztutbranch
Hopefully that is easier to read and understand than the previous GOTO example.	Takový zápis se ve srovnání s předchozím příkazem s GOTO lépe čte a je srozumitelnější.	tutbranch-cztutbranch
Of course we can put any test condition we like after the if, so long as it evaluates to True or False, i.e. a boolean value.	Za slovo if můžeme samozřejmě dosadit libovolnou podmínku testu za předpokladu, že ji lze vyhodnotit jako True nebo False — to znamená jako boolovskou hodnotu.	tutbranch-cztutbranch
Try changing the > to a < and see what happens.	Zkuste změnit operátor > na < a pozorujte, co se stane.	tutbranch-cztutbranch
VBScript	VBScript	tutbranch-cztutbranch
VBScript looks quite similar:	Zápis v jazyce VBScript vypadá podobně:	tutbranch-cztutbranch
<script language="VBScript"> MsgBox "Starting Here" DIM J J = 5 If J > 10 Then MsgBox "This is never printed" Else MsgBox "End of Program" End If </script>	<script type="text/vbscript"> MsgBox "Začínáme zde" Dim J J = 5 If J > 10 Then MsgBox "Toto se nikdy nevytiskne." Else MsgBox "Konec programu." End If </script>	tutbranch-cztutbranch
It's very nearly identical, isn't it?	Vždyť je to téměř shodné, že ano?	tutbranch-cztutbranch
The main difference is the use of End If to indicate the end of the construct.	Hlavní rozdíl spočívá v použití End If pro označení konce konstrukce.	tutbranch-cztutbranch
And JavaScript too	A ještě v JavaScript	tutbranch-cztutbranch
And of course JavaScript has an if statement too:	V jazyce JavaScript nalezneme samozřejmě příkaz if také:	tutbranch-cztutbranch
<script language="JavaScript"> var j; j = 5; if (j > 10){ document.write("This is never printed"); } else { document.write("End of program"); } </script>	<script type="text/javascript"> var j; j = 5; if (j > 10){ document.write("Toto se nikdy nevytiskne."); } else { document.write("Konec programu."); } </script>	tutbranch-cztutbranch
Notice that JavaScript uses curly braces to define the blocks of code inside the if part and the else part.	Povimněte si, že JavaScript používá uvnitř částí if a else pro vymezení bloku kódu složené závorky.	tutbranch-cztutbranch
Also the boolean test is contained in parentheses and there is no explicit keyword then used.	Boolovský test je rovněž uzavřen v závorkách. Klíčové slovo then se zde nepoužívá.	tutbranch-cztutbranch
On a point of style, the curly braces can be located anywhere, I have chosen to line them up as shown purely to emphasize the block structure.	Co se týká stylu, složené závorky můžeme umístit na libovolnou pozici. Rozhodl jsem se, že je zarovnám pod sebe prostě proto, abych zdůraznil strukturu bloku.	tutbranch-cztutbranch
Also if there is only a single line within the block (as we have here) the braces can be omitted entirely, they are only needed to group lines together into a single block.	Pokud se v bloku nachází jen jediný řádek (jako v našem případě), můžeme závorky úplně vynechat. Potřebujeme je jen v případech, kdy mají ohraničit skupinu řádků, které patří do jednoho bloku.	tutbranch-cztutbranch
Boolean Expressions You might remember that in the Raw Materials section we mentioned a Boolean type of data.	Boolovské výrazy Možná si ještě vzpomínáte, že jsme se v kapitole o datech zmínili o datovém typu boolean.	tutbranch-cztutbranch
We said it had only two values: True or False.	Řekli jsme si, že má pouze dvě hodnoty: True a False.	tutbranch-cztutbranch
We very rarely create a Boolean variable but we often create temporary Boolean values using expressions.	Boolovské proměnné vytváříme velmi zřídka, ale dočasné boolovské hodnoty často vznikají jako výsledek vyhodnocení výrazů.	tutbranch-cztutbranch
An expression is a combination of variables and values combined by operators to produce a resultant value.	Výrazem rozumíme kombinaci proměnných a hodnot, spojených operátory s cílem vyprodukovat výslednou hodnotu.	tutbranch-cztutbranch
In the following example: if x x is the expression and the result will be True if x is less than 5 and False if x is greater than or equal to 5.	V následujícím příkladu if x < 5: print x je zápis x < 5 výrazem. Pokud je x menší než 5, bude jeho výsledkem hodnota True. Pokud je x větší nebo rovno 5, bude výsledkem výrazu hodnota False.	tutbranch-cztutbranch
Expressions can be arbitrarily complex provided they evaluate to a single final value.	Výrazy mohou být libovolně složité s tím, že výsledkem jejich vyhodnocení musí být nakonec vždy jediná hodnota.	tutbranch-cztutbranch
In the case of a branch that value must be either True or False.	V případě větvení musí být výsledkem pravdivostní hodnota True nebo False.	tutbranch-cztutbranch
However, the definition of these 2 values varies from language to language.	Nicméně, definice těchto dvou pravdivostních hodnot se jazyk od jazyka liší.	tutbranch-cztutbranch
In many languages False is the same as 0 or a non-existent value (often called NULL, Nil or None).	V mnoha jazycích je hodnota false ztotožněna s hodnotou 0 nebo s hodnotou vyjadřující neexistenci (té se často říká NULL, Nil nebo None).	tutbranch-cztutbranch
Thus an empty list or string evaluates to false in a Boolean context.	Takže v boolovském kontextu bude například prázdný seznam nebo prázdný řetězec vyhodnocen jako False.	tutbranch-cztutbranch
Python works this way and this means we can use a while loop to process a list until the list is empty, using something like:	Takovým způsobem se chová i Python. To znamená, že například můžeme využít cyklu while pro zpracování seznamu, které má skončit v okamžiku, kdy je seznam prázdný:	tutbranch-cztutbranch
while aList: # do something here	while seznam: # Proveď nějakou operaci, která vede ke zkrácení seznamu.	tutbranch-cztutbranch
Or we can use an if statement to test whether a list is empty without resorting to the len() function like this: if aList: # do something here	V příkazu if můžeme tento obrat použít k testování prázdnosti seznamu, aniž bychom použili funkci len() : if seznam: # něco zde udělej (seznam je prázdný)	tutbranch-cztutbranch
Finally we can combine Boolean expressions using Boolean operators which can often cut down the number of if statements we need to write.	Boolovské výrazy můžeme kombinovat pomocí boolovských operátorů. Často tím můžeme zmenšit počet příkazů if.	tutbranch-cztutbranch
Consider this example:	Uvažujme následující příklad:	tutbranch-cztutbranch
if value > maximum: print "Value is out of range!" else if value < minimum: print "Value is out of range!"	if hodnota > maximum: print "Hodnota je mimo rozsah!" else: if hodnota < minimum: print "Hodnota je mimo rozsah!"	tutbranch-cztutbranch
Notice that the block of code executed is identical.	Povšimněte si, že blok prováděného kódu je v obou případech shodný.	tutbranch-cztutbranch
We can save some work, both for us and for the computer, by combining both of the tests into a single test like this:	Zkombinováním obou testů do jednoho dosáhneme úspory práce jak pro počítač, tak pro nás:	tutbranch-cztutbranch
if (value < minimum) or (value > maximum): print "Value is out of range!"	if (hodnota > maximum) or (hodnota < minimum): print "Hodnota je mimo rozsah!"	tutbranch-cztutbranch
Notice we combined both tests using a boolean or operator.	Oba testy jsme spojili operátorem or (nebo, čili logickým součtem).	tutbranch-cztutbranch
This is still a single expression because Python evaluates the first set of parentheses, then the second set of parentheses and finally combines the two calculated values to form the final single value, either True or False.	Dostáváme jediný výraz. Python nejdříve vyhodnotí výraz uzavřený v první dvojici závorek, potom výraz v druhých závorkách a nakonec vypočtené hodnoty zpracuje do podoby jediné hodnoty — True nebo False.	tutbranch-cztutbranch
	Poznámka překladatele: Výše uvedený odstavec chápejte spíše z obecného pohledu. Python ve skutečnosti zpracovává boolovský výraz zleva doprava a skončí v okamžiku, kdy už následující části výrazu nemohou ovlivnit výsledek. Říká se tomu zkrácené vyhodnocování výrazu. Pokud v uvedeném příkladu získáváme vyhodnocením první závorky hodnotu True , pak při použití operátoru or nemá výsledek vyhodnocování druhé závorky na celkový výsledek vliv. Proto se vůbec neprovádí.	tutbranch-cztutbranch
	Zkráceného vyhodnocování boolovských výrazů se většinou spíš výhodně využívá.	tutbranch-cztutbranch
	Mohou však nastat případy, kdy díky tomuto jevu vzniká obtížněji odhalitelná chyba.	tutbranch-cztutbranch
	Pokud bychom v místě druhé části výrazu volali funkci, která vrací boolovský výsledek, ale kromě toho má nějaký vedlejší efekt (například něco vypisuje), pak musíme myslet na to, že se také nemusí vůbec zavolat.	tutbranch-cztutbranch
	Na dosažení zmíněného vedlejšího efektu proto nemůžeme při vyhodnocování výrazu spoléhat.	tutbranch-cztutbranch
Very often if we think carefully about the tests we need to carry out in natural language we will find ourselves using conjunctions like and, or and not.	Pokud o prováděných testech uvažujeme v pojmech přirozeného jazyka, velmi často používáme spojky jako a (anglicky and), nebo (or), negace (ne, není, anglicky not).	tutbranch-cztutbranch
If so there's a very good chance we can write a single combined test rather than many separate ones.	V takovém případě je velmi pravděpodobné, že se nám místo více jednoduchých testů podaří zapsat jeden složený.	tutbranch-cztutbranch
	Poznámka překladatele: Pokud uvažujeme v českém jazyce, pak vám doporučuji, abyste si operátor and překládali jako a zároveň.	tutbranch-cztutbranch
	Pouhé a může vést k chybám, kdy tuto spojku můžeme chápat ve významu nebo.	tutbranch-cztutbranch
	Překlad a zároveň zdůrazní význam operátoru and a pomůže nám snadněji vytvořit mentální obraz situace.	tutbranch-cztutbranch
Chaining if statements	Zřetězení příkazů if	tutbranch-cztutbranch
You can go on to chain these if/then/else statements together by nesting them one inside the other.	Příkazy if/then/else můžeme do sebe vnořovat.	tutbranch-cztutbranch
Here is an example in Python:	V jazyce Python to můžeme vyjádřit následovně:	tutbranch-cztutbranch
# Assume price created previously... price = int(raw_input("What price? ")) if price == 100: print "I'll take it!" else: if price > 500: print "No way Jose!" else: if price > 200: print "How about throwing in a free mouse mat?" else: print "price is an unexpected value!"	# Předpokládáme, že cena byla předem stanovena... cena = int(raw_input(u"Kolik to stojí? ")) if cena == 100: print u"Vezmu si to." else: if cena > 500: print u"Tak to nechci ani náhodou!" else: if cena > 200: print u"Co kdybyste přihodil zdarma podložku pod myš?" else: print u"Neočekávaná cena."	tutbranch-cztutbranch
Note 1: we used == (that's a double = sign) to test for equality in the first if statement, whereas we use = to assign values to variables.	Poznámka 1: V prvním příkazu if jsme pro test na rovnost použili operátor == (tj. zdvojený znak =). Jednoduchý znak = se používá pro přiřazování hodnot proměnným.	tutbranch-cztutbranch
Using = when you mean to use == is one of the more common mistakes in programming Python, fortunately Python warns you that it's a syntax error, but you might need to look closely to spot the problem.	Při programování v Pythonu (a také v C a v C++) patří použití jednoduchého = v místě, kde bychom chtěli použít == k nejčastějším chybám. Python vás v takovém případě naštěstí varuje, že jste se dopustili syntaktické chyby. Někdy se ale musíte pořádně podívat, než si všimnete, o co vlastně jde.	tutbranch-cztutbranch
Note 2: A subtle point to notice is that we perform the greater-than tests from the highest value down to the lowest.	Poznámka 2: Za povšimnutí stojí ještě jeden detail. Testy větší než provádíme od největší hodnoty k nejmenší.	
If we did it the other way round the first test, which would be price > 200 would always be true and we would never progress to the > 500 test.	Kdybychom postupovali obráceně a začali bychom testem cena > 200, pak bychom se nikdy nedostali k testu cena > 500.	tutbranch-cztutbranch
Similarly if using a sequence of less-than tests you must start at the lowest value and work up.	Při používání po sobě jdoucích testů menší než musíme naopak začít testovat na nejmenší hodnotu a postupovat směrem k hodnotám vyšším.	tutbranch-cztutbranch
This is another very easy trap to fall into.	Jde o další past, do které se můžeme při troše nepozornosti snadno chytit.	tutbranch-cztutbranch
VBScript & JavaScript	VBScript & JavaScript	tutbranch-cztutbranch
You can chain if statements in VBScript and JavaScript too but as it's pretty self evident I'll only show a VBScript example here:	Příkazy if můžeme řetězit i v jazycích VBScript a JavaScript. Postup je zcela zřejmý. Proto si to ukážeme jen na příkladu v jazyce VBScript:	tutbranch-cztutbranch
<script language="VBScript"> DIM Price price = InputBox("What's the price?") price = CInt(price) If price = 100 Then MsgBox "I'll take it!" Else: if price > 500 Then MsgBox "No way Jose!" else: if price > 200 Then MsgBox "How about throwing in a free mouse mat too?" else: MsgBox "price is an unexpected value!" End If End If End If </script>	<script type="text/vbscript"> DIM Cena cena = InputBox("Kolik to stojí?") cena = CInt(cena) If cena = 100 Then MsgBox "Vezmu si to." Else: if cena > 500 Then MsgBox "Tak to nechci ani náhodou!" else: if cena > 200 Then MsgBox "Co kdybyste přihodil zdarma podložku pod myš?" else: MsgBox "Neočekávaná cena." End If End If End If </script>	tutbranch-cztutbranch
The only things to note here are that there is an End If statement to match every If statement and that we used the VBScript conversion function CInt to convert from the input string value to an integer.	Za zmínku zde stojí jedině to, že ke každému příkazu if musíme uvést odpovídající příklaz End If. Poznamenejme ještě, že pro převod řetězcové hodnoty na celočíselnou jsme použili funkci CInt().	tutbranch-cztutbranch
Case statements	Příkazy typu Case	tutbranch-cztutbranch
One snag with chaining, or nesting if/else statements is that the indentation causes the code to spread across the page very quickly.	S používáním zanořených příkazů if/else souvisí jedna potíž. Postupné odsazování způsobí, že se zdrojový text rychle roztáhne přes celou šířku stránky.	tutbranch-cztutbranch
A sequence of nested if/else/if/else... is such a common construction that many languages provide a special type of branch for it.	Posloupnost zanořených if/else/if/else… však patří k tak běžným konstrukcím, že některé jazyky poskytují speciální způsob větvení.	tutbranch-cztutbranch
This is often referred to as a Case or Switch statement and the JavaScript version looks like:	Zmíněné speciální konstrukce se často označují jako příkazy case nebo switch. V jazyce JavaScript vypadá příkaz switch následovně:	tutbranch-cztutbranch
<script language="JavaScript"> function doArea(){ var shape, breadth, length, area; shape = document.area.shape.value; breadth = parseInt(document.area.breadth.value); len = parseInt(document.area.len.value); switch (shape){ case 'Square': area = len * len; alert("Area of " + shape + " = " + area); break; case 'Rectangle': area = len * breadth; alert("Area of " + shape + " = " + area); break; case 'Triangle': area = len * breadth / 2; alert("Area of " + shape + " = " + area); break; default: alert("No shape matching: " + shape) }; } </script>	<script type="text/javascript"> function vypoctiPlochu() { var tvar, sirka, delka, plocha; tvar = document.plocha.tvar.value; sirka = parseInt(document.plocha.sirka.value); delka = parseInt(document.plocha.delka.value); switch (tvar) { case 'ctverec': plocha = delka * delka; alert("Plocha tvaru " + tvar + " = " + plocha); break; case 'obdelnik': plocha = delka * sirka; alert("Plocha tvaru " + tvar + " = " + plocha); break; case 'trojuhelnik': plocha = delka * sirka / 2; alert("Plocha tvaru " + tvar + " = " + plocha); break; default: alert("Neznámý tvar: " + tvar) }; } </script>	tutbranch-cztutbranch
<form name="area"> Length: <input type="text" name="len"> Breadth: <input type="text" name="breadth"> Shape: <select name="shape" size=1 onChange="doArea()"> <option value="Square">Square <option value="Rectangle">Rectangle <option value="Triangle">Triangle </select> </form>	<form name="plocha"> Délka: <input type="text" name="delka"> Šířka: <input type="text" name="sirka"> Tvar: <select name="tvar" size="1" onChange="vypoctiPlochu()"> <option value="ctverec">čtverec <option value="obdelnik">obdélník <option value="trojuhelnik">trojúhelník </select> </form>	tutbranch-cztutbranch
The HTML form code just allows us to capture the details and then when the user selects a shape it calls our JavaScript function.	Detaily jsou zachyceny v rámci HTML kódu formuláře. Jakmile si uživatel vybere tvar, zavolá se naše funkce.	tutbranch-cztutbranch
The first few lines simply create some local variables and convert the strings to integers where needed.	Na prvních řádcích se vytvářejí lokální proměnné a podle potřeby se řetězce převádějí na čísla.	tutbranch-cztutbranch
The bold section is the bit we are really interested in.	Zajímá nás úsek, který je vyznačen tučně.	tutbranch-cztutbranch
It selects the appropriate action based on the shape value, notice, by the way, that the parentheses around shape are required.	Podle vybraného tvaru se v něm vybírá příslušná akce. Povšimněte si kulatých závorek kolem identifikátoru tvar za klíčovým slovem switch. Jsou povinné — musí být uvedeny.	tutbranch-cztutbranch
Each block of code within the case structure is not marked using curly braces, as you might expect, but is instead terminated by a break statement.	Mohli byste předpokládat, že bloky kódu uvnitř case by měly být uzavřeny do složených závorek, ale není tomu tak. Místo toho jsou ukončovány příkazem break.	tutbranch-cztutbranch
The entire set of case statements for the switch is, however, bound together as a block by a single set of curly braces.	Nicméně celá sada příkazů case, která odpovídá části switch, již je svázána do podoby bloku jedním párem složených závorek.	tutbranch-cztutbranch
Finally note the final condition is default which is simply a catch-all for anything not caught in the preceding Case statements.	Povšimněte si, že poslední podmínka v příkladu má podobu default . V této části se zachytí všechny případy, které se nezachytily v předchozích částech case.	tutbranch-cztutbranch
Why not see if you can extend the example to cover circles as well?	Vyzkoušejte si, zda byste uměli výše uvedený příklad rozšířit tak, aby pracoval i s kruhem.	tutbranch-cztutbranch
Remember to add a new option to the HTML form as well as a new case to the switch.	Do HTML formuláře nezapomeňte přidat novou volbu a do příkazu switch přidejte další variantu case.	tutbranch-cztutbranch
VBScript Select Case	Příkaz Select Case v jazyce VBScript	tutbranch-cztutbranch
VBScript has a version too:	Verzi příkazu pro výběr jedné z několika variant nalezneme i v jazyce VBScript:	tutbranch-cztutbranch
<script language="VBScript"> Dim shape, length, breadth, SQUARE, RECTANGLE, TRIANGLE SQUARE = 0 RECTANGLE = 1 TRIANGLE = 2 shape = CInt(InputBox("Square(0),Rectangle(1) or Triangle(2)?")) length = CDbl(InputBox("Length?")) breadth = CDbl(InputBox("Breadth?")) Select Case shape Case SQUARE area = length * length MsgBox "Area = " & area Case RECTANGLE area = length * breadth MsgBox "Area = " & area Case TRIANGLE area = length * breadth / 2 MsgBox "Area = " & area Case Else MsgBox "Shape not recognized" End Select </script>	<script type="text/vbscript"> Dim tvar, delka, sirka, CTVEREC, OBDELNIK, TROJUHELNIK CTVEREC = 0 OBDELNIK = 1 TROJUHELNIK = 2 tvar = CInt(InputBox("Čtverec(0), obdélník(1) nebo trojúhelník(2)?")) delka = CDbl(InputBox("Délka?")) sirka = CDbl(InputBox("Šířka?")) Select Case tvar Case CTVEREC plocha = delka * delka MsgBox "Plocha = " & plocha Case OBDELNIK plocha = delka * sirka MsgBox "Plocha = " & plocha Case TROJUHELNIK plocha = delka * sirka / 2 MsgBox "Plocha = " & plocha Case Else MsgBox "Neznámý tvar" End Select </script>	tutbranch-cztutbranch
As with the JavaScript example the first few lines simply collect the data from the user and convert it into the right type.	Na několika prvních řádcích se od uživatele získávají data a převádějí se na správný typ — stejně, jako tomu bylo u příkladu v jazyce JavaScript.	tutbranch-cztutbranch
The bold Select section shows the VBScript case construct with each successive Case statement active as a block terminator for the previous one.	Tučně vyznačená část Select znázorňuje konstrukci typu case, jak se používá v jazyce VBScript. Zasebou uvedené příkazy Case vždy ukončují blok předchozího.	tutbranch-cztutbranch
The whole Select construct is closed with the End Select statement.	Celou konstrukci Select uzavírá příkaz End Select.	tutbranch-cztutbranch
Finally there is a Case Else clause which, like the default in JavaScript catches anything not caught in the Case s above.	Nalezneme zde také část Case Else, ve které se (jako v části default jazyka JavaScript) zachytí vše, co nebylo zpracováno dříve uvedenými částmi Case.	tutbranch-cztutbranch
One other feature worth pointing out is the use of Symbolic Constants instead of numbers.	Za zmínku stojí ještě použití symbolických konstant místo čísel.	tutbranch-cztutbranch
That is the uppercase variables SQUARE, RECTANGLE and TRIANGLE are there simply to make the code easier to read.	Proměnné zapsané velkými písmeny CTVEREC , OBDELNIK a TROJUHELNIK jsou zde jen kvůli tomu, aby se zdrojový text snadněji četl.	tutbranch-cztutbranch
The uppercase names are simply a convention to indicate that they are constant values rather than conventional variables, but VBScript allows any variable name you like.	Použití proměnných zapsaných velkými písmeny je předepsáno pouze konvencí. Dáváme tím najevo, že bychom je neměli chápat jako běžné proměnné, ale jako proměnné udržující konstantní hodnoty. Jazyk VBScript vám ale dovolí pojmenovat si proměnné podle své libosti.	tutbranch-cztutbranch
Python multi-selection	case v jazyce Python	tutbranch-cztutbranch
Python does not provide an explicit case construct but rather compromises by providing an easier if/elseif/else format:	Python explicitní konstrukci typu case nepodporuje. Místo toho nabízí kompromis v podobě if/elif/else:	tutbranch-cztutbranch
menu = """ Pick a shape(1-3): 1) Square 2) Rectangle 3) Triangle """ shape = int(raw_input(menu)) if shape == 1: length = float(raw_input("Length: ")) print "Area of square = ", length ** 2 elif shape == 2: length = float(raw_input("Length: ")) width = float(raw_input("Width: )) print "Area of rectangle = ", length * width elif shape == 3: length = float(raw_input("Length: ")) width = float(raw_input("Width: )) print "Area of triangle = ", length * width else: print "Not a valid shape, try again"	menu = """ Vyberte si tvar (1-3): 1) Ctverec 2) Obdelnik 3) Trojuhelnik """ tvar = int(raw_input(menu)) if tvar == 1: strana = float(raw_input("Strana: ")) print "Plocha ctverce = ", strana ** 2 elif tvar == 2: delka = float(raw_input("Delka: ")) sirka = float(raw_input("Sirka: ")) print "Plocha obdelniku = ", delka * sirka elif tvar == 3: zakladna = float(raw_input("Zakladna: ")) vyska = float(raw_input(" Vyska: ")) print "Plocha trojuhelniku = ", zakladna * vyska / 2 else: print "Neplatny tvar. Zkute to znovu"	tutbranch-cztutbranch
	Poznámka překladatele: Abychom se zatím vyhnuli problémům s českými znaky, použili jsme texty bez diakritických znamének. Způsob řešení, kdy používáme i české znaky s diakritikou, můžete nalézt v dalších kapitolách.	tutbranch-cztutbranch
Note the use of elif and the fact that the indentation (all important in Python) does not change (unlike the nested if statement example). It's also worth pointing out that both this technique and the earlier nested if/else example are equally valid, the elif technique is just a little easier to read if there are many tests.	Povšimněte si použití elif a skutečnosti, že se (v porovnání s příkladem se zanořenými if) nemění odsazení, které je v Pythonu tak důležité. Za zmínku stojí i to, že oba zápisy — jak poslední zápis, tak dříve uvedený zápis využívající vnořených konstrukcí if/else — jsou funkčně shodné. Zápis využívající elif zvyšuje čitelnost v případech, kdy použijeme větší množství testů.	tutbranch-cztutbranch
The final condition is an else which catches anything not caught by the previous tests, just like the default in JavaScript and Case Else in VBScript.	V koncové větvi else se zachytí všechny případy, které nebyly zachyceny v předchozích testech. Odpovídá to použití default v JavaScript nebo Case Else v jazyce VBScript.	tutbranch-cztutbranch
VBScript also provides a slightly more cumbersome version of this technique with ElseIf...Then which is used in exactly the same way as the Python elif but is rarely seen since Select Case is easier to use.	O něco těžkopádnější podobu stejné konstrukce naleznete i v jazyce VBScript. Konstrukce ElseIf...Then se používá naprosto stejným způsobem, jako elif v jazyce Python. Ale setkáte se s ní zřídka, protože použití alternativního příkazu Select Case je jednodušší.	tutbranch-cztutbranch
Putting it all together	Teď to dáme všechno dohromady	tutbranch-cztutbranch
So far many of our examples have been pretty abstract.	Až dosud byly mnohé z našich příkladů velmi abstraktní.	tutbranch-cztutbranch
To conclude let's take a look at an example that uses nearly everything we've learned about so far to introduce a common programming technique, namely displaying menus for controlling user input.	Na závěr se podívejme na příklad, který používá téměř vše, co jsme se zatím naučili. Uvedeme si běžnou programovací techniku, konkrétně zobrazení menu pro řízení uživatelského vstupu.	tutbranch-cztutbranch
Here is the code, followed by a brief discussion: menu = """ Pick a shape(1-3): 1) Square 2) Rectangle 3) Triangle 4) Quit """ shape = int(raw_input(menu)) while shape != 4: if shape == 1: length = float(raw_input("Length: ")) print "Area of square = ", length ** 2 elif shape == 2: length = float(raw_input("Length: ")) width = float(raw_input("Width: )) print "Area of rectangle = ", length * width elif shape == 3: length = float(raw_input("Length: ")) width = float(raw_input("Width: )) print "Area of triangle = ", length * width else: print "Not a valid shape, try again" shape = int(raw_input(menu))	Zde máme kód, za kterým následuje krátká diskuse. menu = """ Vyberte si tvar (1-3): 1) Ctverec 2) Obdelnik 3) Trojuhelnik 4) Konec """ tvar = int(raw_input(menu)) while tvar != 4: if tvar == 1: strana = float(raw_input("Strana: ")) print "Plocha ctverce = ", strana ** 2 elif tvar == 2: delka = float(raw_input("Delka: ")) sirka = float(raw_input("Sirka: ")) print "Plocha obdelniku = ", delka * sirka elif tvar == 3: zakladna = float(raw_input("Zakladna: ")) vyska = float(raw_input(" Vyska: ")) print "Plocha trojuhelniku = ", zakladna * vyska / 2 else: print "Neplatny tvar. Zkute to znovu" tvar = int(raw_input(menu))	tutbranch-cztutbranch
We've added just three lines (in bold) to the previous Python example but in so doing have significantly enhanced the usability of our program.	K předchozímu příkladu jsme přidali pouhé tři řádky (označeny tučně), ale tato jednoduchá úprava výrazně zvýšila použitelnost našeho programu.	tutbranch-cztutbranch
By adding a Quit option to the menu, plus a while loop we have provided the capability for the user to keep on calculating sizes of different shapes until she has all the information she needs.	Doplněním volby Konec a přidáním cyklu jsme uživateli umožnili pokračovat ve výpočtech ploch různých tvarů až do doby, kdy získá všechny potřebné informace.	tutbranch-cztutbranch
There is no need to rerun the program manually each time.	Program již nemusí pokaždé ručně znovu a znovu spouštět.	tutbranch-cztutbranch
The only other line we added was to repeat the raw_input(menu) shape selection so that the user gets the chance to change the shape and, ultimately, to quit.	Kromě již zmíněných řádků jsme přidali pouze jeden řádek s raw_input(menu), který uživateli umožní volit různé tvary a na závěr také činnost programu ukončit.	tutbranch-cztutbranch
What the program does is create the illusion to the user that the program knows what they want to do and does it correctly, acting differently depending what they input.	Program tedy uživateli vytváří iluzi, že ví, co uživatel potřebuje. Na základě jeho volby se chová různým způsobem a správně provede odpovídající činnost.	tutbranch-cztutbranch
In essence the user appears to be in control, whereas in fact, the programmer is in control since the he has anticipated all the valid inputs and how the program will react.	Uživateli se v podstatě zdá, že postup řídí, zatímco ve skutečnosti má řízení v rukou programátor, který předvídal, jak mají vypadat všechny platné vstupy a jak má na ně program reagovat.	tutbranch-cztutbranch
The intelligence on display is that of the programmer, not the machine - computers after all are stupid!	Projevovaná inteligence tedy patří programátorovi, nikoliv stroji. Počítače jsou ve své podstatě hloupé!	tutbranch-cztutbranch
You see how easily we can extend our program just by adding a few lines and combining sequences (the blocks that calculate the area), loops (the while loop) and conditionals (the if/elif structure).	Povšimněte si jak snadno můžeme svůj program zdokonalit přidání pouhých pár řádků a zkombinováním posloupností (bloků pro výpočet plochy), cyklů (zde cyklus while) a podmíněných příkazů (konstrukce if/elif/else).	tutbranch-cztutbranch
Dijkstra's three building blocks of programming.	Jde o tři z Dijkstrových základních programátorských stavebních kamenů.	tutbranch-cztutbranch
Having covered all three you can, in theory, now go out and program anything, but there are a few more techniques we can learn to make things a bit easier, so don't rush off just yet.	Pokud zvládnete všechny tři, můžete teoreticky naprogramovat cokoliv. Ale můžeme se naučit ještě několik technik, které nám programování dále usnadní. Takže zatím mějte ještě trochu strpení.	tutbranch-cztutbranch
Modifying collections from inside loops	Změny v kolekci během provádění cyklu	tutbranch-cztutbranch
We mentioned in the looping topic that modifying a collection from inside a loop was a difficult thing to do, but never got round to explaining how to do it!	Když jsme se bavili o cyklech, zmínili jsme se o tom, že úprava kolekce během průchodu cyklem, konkrétné rušení prvků v procházené kolekci, nemusí být zcela jednoduché. Ale nevysvětlili jsme proč!	tutbranch-cztutbranch
The reason is, we had to wait for branching to be explained first.	Důvodem pro tento odklad byla skutečnost, že jsme museli nejdříve vysvětlit pojem větvení.	tutbranch-cztutbranch
So here is the solution:	Vraťme se tedy k řešení problému.	tutbranch-cztutbranch
If we need to modify the elements of a collection in place we can use a while loop to make the changes as we iterate over it.	Pokud potřebujeme měnit obsah kolekce během jejího zpracování (bez kopírování do jiné kolekce), můžeme k tomu využít vlastností cyklu while.	tutbranch-cztutbranch
We can do this because in a while construct we have explicit control over the index, unlike the situation in a for loop where the index is automatically updated.	Při použití konstrukce while totiž přímo pracujeme s obsahem indexové proměnné. Srovnejte to se situací, kdy se použije cyklus for, který indexovou proměnnou upravuje automaticky.	tutbranch-cztutbranch
Let's see how to delete all zeros from a list:	Podívejme se, jak můžeme ze seznamu vypustit všechny prvky s nulovou hodnotou:	tutbranch-cztutbranch
myList = [1,2,3,0,4,5,0] index = 0 while index < len(myList): if myList[index] == 0: myList.remove(myList[index]) else: index += 1 print myList	seznam = [1, 2, 3, 0, 4, 5, 0] index = 0 while index < len(seznam): if seznam[index] == 0: del seznam[index] else: index += 1 print seznam	tutbranch-cztutbranch
The thing to note here is that we do not increment the index if we remove an item, we rely on the deletion moving everything up so that the old index value now points at the next item in the collection.	Povšimněte si, že v případě odstraňování prvku neprovádíme zvyšování indexu. Spoléháme na to, že se při smazání položky vše posune, takže původní hodnota indexu bude poté ukazovat na další prvek kolekce.	tutbranch-cztutbranch
We use an if/else branch to control when we increment the index.	Zvyšování indexu se tedy provádí jen v jedné větvi konstrukce if/else.	tutbranch-cztutbranch
It's very easy to make a mistake doing this kind of thing so test your code carefully.	Při podobných obratech se můžeme velice snadno dopustit chyby, proto vždy funkčnost pečlivě otestujte.	tutbranch-cztutbranch
There is another set of Python functions which are specifically designed for manipulating list contents and we look at them in the Functional Programming topic in the advanced section of the tutorial.	V Pythonu můžeme používat jistou sadu funkcí, které byly přímo navrženy pro manipulaci s obsahy senamů. Seznámíme se s nimi v rámci tématu Funkcionální programování, tedy v části pro pokročilé.	tutbranch-cztutbranch
Things to Remember	Zapamatujte si	tutbranch-cztutbranch
Use if/else to branch	Pro větvení používáme if/else.	tutbranch-cztutbranch
The else is optional	Část else je nepovinná.	tutbranch-cztutbranch
Multiple decisions can be represented using a Case or if/elif construct	K rozhodnutí podle více z možných hodnot lze využít konstrukci typu Case nebo konstrukci if/elif.	tutbranch-cztutbranch
Boolean expressions return True or False	Boolovské výrazy vracejí hodnoty True nebo False.	tutbranch-cztutbranch
Combining menus with Case constructs allows us to build a wide range of user controlled applications.	Kombinování menu s konstrukcemi Case nám umožňuje vytvářet širokou škálu aplikací řízených uživatelem.	tutbranch-cztutbranch
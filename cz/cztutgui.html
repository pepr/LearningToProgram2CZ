<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se nauèit programovat: Programování grafického uivatelského rozhraní</title>
</head>
<body>

<p class="ir">Níe uvedenı text pochází z prvního vydání. Nad tímto textem 
se nachází aktuální stav po revizi smìøující k druhému vydání.</p>

<h2>Programování grafického uivatelského rozhraní s Tkinter</h2>

<div class="whatcovered">

<p>Následující téma se vìnuje nejdøíve zpùsobu vıstavby programu s grafickım
uivatelskım rozhraním (GUI) v obecném smyslu. Poté se zamìøíme na to, jak
se pro tento úèel pouívá <em>rodná</em> nástrojová sada systému Python pro
tvorbu grafického uivatelského rozhraní &mdash; Tkinter. Neèekejte, e
pùjde o dokonalou referenèní pøíruèku pro Tkinter. Nejedná se dokonce ani o
ucelenou uèebnici. Velmi dobrá a detailní uèebnice, která se tomuto
tématu vìnuje, ji existuje. Odkaz na ni naleznete na webovskıch stránkách
systému Python. Tato kapitola se vás spíše bude snait provést základy
programování grafického uivatelského rozhraní (GUI), seznámí vás s jeho
základními prvky a zpùsobem jejich pouití. Podíváme se také na to, jak nám
mùe pøi vıstavbì aplikace s grafickım uivatelskım rozhraním pomoci
objektovì orientované programování.</p>

</div>

<h3>Principy grafického uivatelského rozhraní</h3>

<p>Ze všeho nejdøíve bych rád øekl, e se zde nenauèíte nic nového, co se
tıká programování. Programování grafického uivatelského rozhraní je stejné
jako jakıkoliv jinı druh programování. Mùete pouívat posloupnosti <span
class="trnote" title="Poznámka pøekladatele">pøíkazù</span>, cykly, vìtvení
a moduly stejnì, jak jsme si ukázali døíve. Èím se programování grafického
uivatelského rozhraní obvykle liší je to, e obvykle pouíváme nìjakou
<em>sadu nástrojù</em> (toolkit) a to nás nutí postupovat v souladu se
vzory, které do návrhu sady nástrojù vnesl její tvùrce. Kadá nová sada
nástrojù definuje své aplikaèní programátorské rozhraní (API) a mnoinu
návrhovıch pravidel, které se vy, jako programátor, musíte nauèit. A právì
to je ten dùvod, proè se vìtšina programátorù snaí tvoøit standardy na
základì pouze nìkolika nástrojovıch sad, které jsou dostupné pro více
programovacích jazykù. Zvládnutí nové nástrojové sady (toolkit <span
class="trnote" title="Poznámka pøekladatele">[túlkit]</span>) bıvá mnohem
obtínìjší, ne zvládnutí nového programovacího jazyka.</p>

<p>Vìtšina programovacích jazykù, které se pouívají pro vytváøení aplikací
s okny, bıvá dodávána spolu s toolkitem. (Jde obvykle o tenkou vrstvu nad
nejjednoduššími nástroji, které jsou zabudovány pøímo do systému, kterı okna
podporuje.) Pøíkladem mohou bıt Visual Basic, Delphi (Kylix) a Visual
C++/.NET.</p>

<p>Java se od nich odlišuje tím, e se jazyk dodává s jeho vlastním
grafickım toolkitem (nazıvá se Swing). Ten je podporován na kadé platformì,
kde mùe bìet Java &mdash; co jsou témìø všechny platformy.</p>

<p class="ir"><b>Poznámka pøekladatele:</b> VB, Delphi jsou jazyky s
podporou Rapid prototyping, resource, nástroje, podpora pro okna uvnitø
jazyka. Visual C++ v podstatì standardní pøekladaè jazyka C++ s nìkterımi
nestandardními rozšíøeními. .NET je jazykovì nezávislá, objektovì
orientovaná platforma, kde èást pro okna je jen èástí. Longhorn (2005/2006)
bude pøekrıvat celou mnoinu funkcí jádra systému (kompatibilita). .Net
jazykovì neutrální, jazyky CLI, CLR se podobá Java runtime, WindowForms lze
pøirovnat k Swingu, ale je jazykovì nezávislı, C# lze pøirovnat k Javì.
Celkovì má .Net blíe k jádru systému. Struèné vysvìtlení ponechat zde,
detaily do cztuttrn.</p>

<p>Existují ale i další toolkity, které mùete pro konkrétní operaèní systém
(Unix, Mac, Windows, atd.) získat samostatnì. Jejich souèástí jsou obvykle
adaptéry, které umoòují jejich pouití z rùznıch jazykù. Nìkteré z nich
jsou komerèní, ale øada z nich je volnì dostupná (freeware). Jako pøíklad
uveïme GT/K, Qt, Tk. Všechny mají své webové stránky. Vyzkoušejte
napøíklad:</p>

<ul>

<li><a href="http://www.wxPython.org/" target="_blank">wxPython</a> &mdash; 
  pythonovská verze toolkitu wxWindows, kterı je ve skuteènosti napsán v C++.</li>

<li><a href="http://www.trolltech.com/" target="_blank">PyQt</a> &mdash; 
  pythonovskı obal toolkitu Qt, kterı lze pouívat s vìtšinou jazykù.</li>

<li><a href="http://www.daa.com.au/~james/software/pygtk/" target="_blank"
  >pyGTK</a> &mdash; pythonovskı obal The Gimp Toolkit neboli GTK+. Jde o
  volnì pouitelnı projekt (freeware), kterı je intenzivnì vyuíván v rámci
  komunity uivatelù systému Linux.</li>
  
</ul>

<p>V toolkitech Qt a GT/k je napsána vìtšina linuxovıch aplikací. Oba jsou
pro nekomerèní pouití dostupné zdarma. (To znamená, e je mùete volnì
pouívat, pokud nechcete své programy prodávat za úèelem vıdìlku.) Pokud
chcete, mùete pro Qt získat i komerèní licenci.</p>

<p>U jazyka Python se za standardní prostøedí pro tvorbu grafického
uivatelského rozhraní povauje Tkinter (je souèástí instalace). Prostøedí
Tkinter je zaloeno na Tk, co je velmi starı toolkit, dostupnı pro více
operaèních systémù. A právì na tuto nástrojovou sadu se podíváme blíe. Její
verze jsou k dispozici i pro jazyky Tcl a Perl.</p>

<p>Principy, na kterıch je toolkit Tk zaloen, se od ostatních nástrojovıch
sad mírnì liší. Proto si na závìr uvedeme struènı pøehled jiného populárního
nástroje pro tvorbu grafického uivatelského rozhraní v systému Python (a
také v jazycích C/C++), kterı je zaloen na obvyklejších pøístupech.
Nejdøíve si ale uveïme obecné principy.</p>

<p>Jak u jsme se døíve nìkolikrát zmínili, pøirozenou vlastností aplikací s
grafickım uivatelskım rozhraním je to, e jsou témìø vdy øízeny událostmi.
Pokud si nevzpomínáte, co se tím myslí, zopakujte si téma <a
href="cztutevent.html">událostmi øízeného programování.</a></p>

<p>Pøedpokládám, e <em>z uivatelského hlediska</em> ji grafické
uivatelské rozhraní znáte. Zamìøíme se na to, jak takové programy fungují
<em>z hlediska programátora</em>. Nebudeme zabíhat do takovıch detailù, jak
se napøíklad tvoøí rozsáhlá a sloitá grafická uivatelská rozhraní s mnoha
okny, rozhraní pro práci s více dokumenty (MDI) a podobnì. Pøidríme se
takovıch základù, jako je vytváøení jednoduchého okna aplikace s nìjakımi
popisnımi texty, s tlaèítky, prvky pro vstup textu a s okny pro zobrazování
zpráv (message box).</p>

<p>Nejdøíve si zkontrolujme naši slovní zásobu. Programování grafického
uivatelského rozhraní pouívá svou vlastní sadu programátorskıch pojmù.
Nejbìnìjší s nich jsou uvedeny v následující tabulce:</p>

<table summary="Pojmy GUI">
<tr><th>Pojem</th><th>Vysvìtlení</th></tr>
<tr><td>Okno (Window)</td>
    <td>Plocha na obrazovce, která je ovládána aplikací. Okna mají obvykle
    obdélníkovı tvar, ale nìkterá prostøedí pro tvorbu grafického
    uivatelského rozhraní dovolují pouití i jinıch tvarù. Okna mohou
    obsahovat další okna. Èasto je kadı ovládací prvek grafického
    uivatelského rozhraní tvoøen svım vlastním oknem.</td></tr>
<tr><td>Ovládací prvek (Control)</td>
    <td>Ovládací prvek je objekt grafického uivatelského rozhraní, kterı se
    pouívá pro ovládání aplikace. Ovládací prvky mají urèité vlastnosti a
    obvykle generují nìjaké události. Ovládací prvky obvykle souvisejí s
    odpovídajícími objekty na aplikaèní úrovni a jejich události jsou
    svázány s metodami aplikaèních objektù. Pøi vıskytu události se tedy
    provede jedna z odpovídajících metod. Prostøedí pro tvorbu grafického
    uivatelského rozhraní obvykle poskytuje mechanismus, kterım se vazba
    mezi událostí a metodou ustanoví.</td></tr>    
<tr><td>Widget</td>
    <td><p>Ovládací prvky mají nìkdy viditelnou podobu. Nìkteré ovládací 
    prvky (jako tøeba èasovaèe) sice mohou bıt spojeny s nìjakım oknem, ale 
    samy o sobì nejsou viditelné. Prvky typu widget tvoøí tu podmnoinu 
    ovládacích prvkù, které jsou viditelné a se kterımi mùe uivatel nebo
    programátor manipulovat. Ukáeme si pouití následujících prvkù typu 
    widget:</p>
    
    <ul>
    <li>Rámec (frame),</li>
    <li>popisnı text (label),</li>
    <li>tlaèítko (button),</li>
    <li>pole pro vstup textu (text entry),</li>
    <li>okno se zprávou (message box).</li>
    </ul>

    <p>Jinde v této uèebnici jsou pouity další prvky, kterımi se ale v této
    kapitole nebudeme zabıvat:</p>
    
    <ul>
    <li>Okno pro psaní textu (text box),</li>
    <li>pøepínací tlaèítko (radio button).</li>
    </ul>
    
    <p>A nakonec si uveïme prvky, kterımi se nebudeme zabıvat vùbec:</p>

    <ul>
    <li>Kreslicí plocha (canvas),</li>
    <li>prvek pro vıbìr (check button) &mdash; lze vybírat více nabídnutıch 
      moností najednou,</li>
    <li>obrázek (image) &mdash; pro zobrazování obrázkù ve formátu BMP,
      GIF, JPEG a PNG,</li>
    <li>okno se seznamem (list box),</li>
    <li>Menu/MenuButton &mdash; pro tvorbu menu,</li>
    <li>Scale/Scrollbar &mdash; pro znázornìní a úpravu pozice pohledu.</li>
    </ul>
    
    <p class="trnote"><b>Poznámka pøekladatele:</b> Protoe pro pojem
    <em>widget</em> nemáme dostateènì struènı èeskı ekvivalent, pøekládám
    jej v zájmu dobré èitelnosti textu jako <em>ovládací prvek</em>, i kdy
    jsem si vìdom, e tento pojem je obecnìjší, ne v pøípadì anglického
    originálu. Pokud by mohly vzniknout nejasnosti kolem charakteru prvku
    nebo pokud chci naznaèit, co obsahoval originální text, uvádím slovo
    widget jako souèást opisu, kterım obcházím nutnost jeho skloòování. 
    V nìkterıch pøípadech slovo widget uvádím v závorkách.</p>
    </td></tr>
<tr><td>Rámec (Frame)</td>
    <td>Jde o prvek typu widget, kterı se pouívá k seskupení dalších prvkù
    typu widget dohromady. Rámec se èasto pouívá jako reprezentant celého
    okna. Uvnitø rámce se mohou nacházet další rámce.</td></tr>
<tr><td>Pøedpis pro rozloení prvkù (Layout)</td>
    <td>Ovládací prvky jsou uvnitø rámce umístìny podle urèitého pøedpisu.
    Ten mùe bıt definován rùznım zpùsobem. Buï se pouívají souøadnice
    odpovídající pixelùm na obrazovce, nebo se poloha urèuje relativnì vùèi
    jinım prvkùm (zarovnání vlevo, nahoru, atd.), nebo se vyuívá uspoøádání
    do møíky nebo do tabulky. Pouití souøadnicového systému je sice snadno
    srozumitelné, ale obtínì se pouívá napøíklad v situaci, kdy dochází
    ke zmìnám rozmìrù okna. Pokud se umístìní prvkù pøedepisuje souøadnicemi, 
    pak by zaèáteèníci mìli pouívat radìji okna, u kterıch nelze mìnit
    rozmìry.</td></tr>    
<tr><td>Potomek (Child)</td>
    <td>Pøi tvorbì aplikací s grafickım uivatelskım rozhraním èasto vzniká
    hierarchické uspoøádání ovládacích prvkù. Rámec na nejvyšší úrovni,
    kterı pøedstavuje okno aplikace, se skládá z podrámcù, které obsahují
    další rámce nebo ovládací prvky. Vazby mezi ovládacími prvky si mùeme
    zobrazit jako stromovou strukturu, ve které má kadı ovládací prvek
    nadøazen jeden rodièovskı prvek a nìkolik potomkù (podøízenıch prvkù).
    Ve skuteènosti je tato struktura závislostí pøímo uloena v jednotlivıch
    prvcích <span class="trnote" title="Poznámka pøekladatele">(prvek si 
    udruje odkazy na své podøízené prvky &mdash; potomky)</span>, take
    programátor &mdash; nebo èastìji samo prostøedí grafického uivatelského
    rozhraní &mdash; mùe provádìt nìkteré akce nad ovládacím prvkem a všemi
    jeho potomky najednou.</td></tr>
</table>

<h3>Exkurze mezi nìkteré bìné ovládací prvky</h3>

<p>V této sekci vytvoøíme pøes pøíkazovı øádek systému Python jednoduchá
okna a ovládací prvky (widget). Poznamenejme, e aplikaci, která vyuívá
Tkinter, nemùeme spolehlivì spouštìt z prostøedí IDLE, protoe IDLE samotné
je aplikací, která Tkinter vyuívá. Z IDLE samozøejmì mùeme pouít jeho
editor a vytvoøit v nìm zdrojové texty, ale vısledek musíme spustit z
pøíkazového øádku operaèního systému. Uivatelé prostøedku Pythonwin naopak
takovou aplikaci spouštìt mohou, protoe Pythonwin pouívá jinou nástrojovou
sadu pro tvorbu grafického uivatelského rozhraní &mdash; MFC <span
class="trnote" title="Poznámka pøekladatele">(Microsoft Foundation
Classes)</span>. Nicménì i v prostøedí Pythonwin mùeme u tkinterovskıch
aplikací pozorovat jisté neoèekávané projevy chování. Proto zde radìji
pouijeme pøíkazovı øádek systému Python<span class="trnote" title="Poznámka
pøekladatele">, kterı máme k dispozici po spuštìní interpretu jazyka Python
prostøedky operaèního systému (v DOSovém oknì)</span>.</p>

<h4>>>> from Tkinter import * </h4> 

<p>Mezi první poadavky kadého tkinterovského programu patøí importování
jmen ovládacích prvkù. Mohli byste samozøejmì importovat jen modul, ale
velice rychle byste se unavili tím, e byste pøed kadé jméno museli
pøipisovat <code>Tkinter</code>.</p>

<h4>>>> top = Tk()</h4>

<p>Tento pøíkaz vytvoøí ovládací prvek na nejvyšší úrovni hierarchie našich
ovládacích prvkù. Všechny ostatní ovladací prvky budou vytvoøeny jako jeho
potomci. Povšimnìte si, e se zobrazilo nové prázdné okno s textem
<code>tk</code> v titulku okna, s ikonou Tk a s obvyklou sadou ovládacích
tlaèítek (zmenšení do ikony, zvìtšení pøes celou obrazovku, atd.). Tak, jak
budeme aplikaci postupnì vytváøet, budeme do tohoto okna pøidávat další
prvky.</p>

<h4>>>> dir(top)</h4>

<pre>['_tclCommands', 'children', 'master', 'tk']</pre>

<p>Funkce <code>dir</code> nám ukáe všechna jména, která jsou zadanému
argumentu známa. Mùeme ji pouít i pro moduly, ale v tomto pøípadì se
chceme podívat na vnitøek objektu <code>top</code>, co je instance tøídy
<code>Tk</code>. Jde o jeho atributy. Povšimnìte si zejména atributù
<code>children</code> a <code>master</code>, která zachycují vazby v
hierarchii ovládacích prvkù. Povšimnìte si také atributu
<code>_tclCommands</code>, kterı má svùj pùvod ve skuteènosti &mdash; jak si
mùete vzpomenout &mdash;, e Tkinter je vytvoøen nad nástrojovou sadou
systému Tcl, která se jmenuje Tk.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> Vypsanı seznam jmen je ve
skuteènosti mnohem delší a popíše vám celou obrazovku &mdash; pøinejmenším u
verze Python 2.2.</p>

<h4>>>> F = Frame(top)</h4>

<p>Vytvoøí se ovládací prvek (widget) <code>Frame</code>, ve kterém budou
umístìny ovládací prvky, které budeme pouívat. <span class="trnote"
title="Poznámka pøekladatele">Pøi vytváøení instance</span>
<code>Frame</code> je jako první argument (a v tomto pøípadì jedinı) pouit
<code>top</code>. Tím øíkáme, e <code>F</code> bude ovládací prvek,
vytvoøenı jako potomek ovládacího prvku <code>top</code>.</p>

<h4>>>> F.pack()</h4>

<p>Povšimnìte si, e po provedení tohoto pøíkazu se okno Tk scvrkne na
velikost pøidaného ovládacího prvku tøídy <code>Frame</code>. Ten je v
souèasnosti prázdnı, take okno je teï velmi malé. Metoda
<code>pack()</code> aktivuje <em>správce rozloení</em> (Layout Manager),
kterı je znám jako <em>packer</em> (pakovaè, stlaèovaè). Ten se pøi
jednoduchıch rozloeních prvkù pouívá velmi snadno, ale s tím, jak se
rozloení prvkù stává sloitìjším, zaèíná bıt ponìkud neohrabanı. Pro tyto
chvíle se jej budeme dret &mdash; snadno se pouívá. Povšimnìte si,
e ovládací prvky (widget) nebudou v naší aplikaci vidìt a do té doby, ne
provedeme jejich "spakování" (nebo pouijeme jinou metodu správce rozloení
prvkù).</p>

<h4>>>> lHello = Label(F, text="Ahoj, vy tam!")</h4>

<p>Tímto pøíkazem vytvoøíme novı objekt <code>lHello</code> jako instanci
tøídy <code>Label</code>. Rodièovskım (nadøízenım) ovládacím prvkem je
<code>F</code> a atributu <code>text</code> pøiøazujeme hodnotu <code>"Ahoj,
vy tam!"</code>. Konstruktory objektù modulu Tkinter mívají obvykle mnoho
parametrù (kadı z nich má pøednastavenou hodnotu). Všimnìte si, e se jim
èasto pøedávají argumenty zpùsobem, kdy vyuíváme monosti urèení
pøíslušného parametru jménem. <span class="trnote" title="Poznámka pøekladatele"
>(Srovnejte to s èastìjším, pozièním zpùsobem pøedávání argumentù, kdy
udáváme pouze hodnotu parametru, ale nikoliv jméno. V takovém pøípadì musíme
hodnotu uvést na správné pozici.)</span> Povšimnìte si rovnì, e objekt
není dosud viditelnı, protoe jsme dosud neprovedli "spakování".</p>

<p>Nakonec si uveïme poznámku ke konvenci pro volbu jména: Pøed jméno
<code>Hello</code> jsem pøidal malé <code>l</code> jako <code>Label</code>,
které má pøipomínat vıznam objektu. Stejnì jako u ostatních konvencí pro
volbu jména je dodrování této konvence vìcí vašeho názoru. Podle mì je její
dodrování uiteèné.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> V souvislosti s tvorbou
programù pro první verze operaèního systému Microsoft Windows byl vypracován
celı systém pøedpon pøidávanıch ke jménùm promìnnıch, funkcí a dalších
prvkù. Je znám jako <em>maïarská notace</em>. Podrobnosti mùete najít v <a
href="http://msdn.microsoft.com/library/en-us/dnvsgen/html/hunganotat.asp"
target="_blank">Charles Simonyi: "Hungarian notation"</a>. V poslední dobì
ovšem pøevládá názor, e pouívání podobné notace mùe zpùsobovat více
problémù, ne uitku. Tıká se to pøedevším vìtších projektù a jazykù s velmi
silnou typovou kontrolou, jako je napøíklad jazyk C++. Pouívejte proto
podobnıch konvencí s mírou. Vhodná volba identifikátoru (tj. jména) mùe
potøebu pouívání podobnıch pøedpon zmírnit.</p>

<h4>>>> lHello.pack()</h4>

<p>Teï u vısledek pøedchozích pøíkazù vidíme. Mìl by vypadat nìjak
takto:</p>

<p class="center"><img src="cztk_hello.png" alt="Okno s popisnım textem."></p>

<p>Objektu tøídy <code>Label</code> mùeme parametry konstruktoru pøedepsat
i další vlastnosti, jako je napøíklad typ a barva písma. Tyto vlastnosti si
ale mùeme zpøístupnit voláním metody <code>configure</code>, kterou
ovládací prvky (widget) modulu Tkinter podporují:</p>

<h4>>>> lHello.configure(text="Nashledanou.")</h4>

<p>Zpráva se zmìnila. Bylo to docela snadné, e? Pouití metody
<code>configure</code> je vıhodné pøedevším v pøípadech, kdy chcete zmìnit
nìkolik vlastností najednou, protoe je mùeme najednou pøedepsat jako její
argumenty. Pokud ovšem chcete zmìnit jen jedinou vlastnost, jako jsme to
uèinili v naposledy uvedeném pøípadì, mùeme se k objektùm chovat, jako
kdyby se jednalo o slovníky (dictionary, vyhledávací tabulky). Take mùeme
psát:</p>

<h4>>>> lHello['text'] = "Ahoj, jsem tady zase!"</h4>

<p>... je to kratší a snad i srozumitelnìjší.</p>

<p>Objekty typu <code>Label</code> (popisné texty) patøí k docela nudnım
ovládacím prvkùm. Mohou pouze zobrazit text, kterı je urèen jen ke ètení
&mdash; i kdy v rùznıch barvách, rùznım písmem a v rùzné velikosti. (Ve
skuteènosti je lze pouít i pro zobrazení jednoduché grafiky, ale jak to
udìlat si ukáeme a pozdìji.)</p>

<p>Døíve ne se podíváme na další typ objektu, zbıvá nám pøedvést ještì
jednu vìc &mdash; zpùsob, jak mùeme nastavit titulek okna. Dosáhneme toho
pouitím metody ovládacího prvku na vrcholu hierarchie, objektu
<code>top</code>:</p>

<h4>>>> F.master.title("Ahoj")</h4>

<p>Stejného efektu jsme mohli dosáhnout pøímım pouitím objektu
<code>top</code>, ale technika, vyuívající pøístup prostøednictvím
vlastnosti <code>master</code> objektu tøídy <code>Frame</code>, bıvá
uiteèná &mdash; jak uvidíme pozdìji.</p>

<h4>>>> bQuit = Button(F, text="Konec", command=F.quit)</h4>

<p>Tímto pøíkazem vytvoøíme novı ovládací prvek, tlaèítko (button, èti
[batn]). Tlaèítko nese nápis "<code>Konec</code>" a je spojeno s pøíkazem
<code>F.quit</code>. Povšimnìte si, e pøedáváme jméno metody. Neprovádíme
volání této metody, protoe jsme za jméno nepøidali závorky. To znamená, e
se pøedává objekt s charakterem funkce ve smyslu chápaném v jazyce Python.
Mùe to bıt vestavìná metoda modulu Tkinter, jako v tomto pøípadì, nebo
jakákoliv jiná, námi definovaná funkce. Funkce nebo metoda nesmí mít ádné
argumenty. Metoda <code>quit</code>, podobnì jako metoda <code>pack</code>,
je definována v bázové tøídì, kterou dìdí všechny ovládací prvky modulu
Tkinter.</p>

<h4>>>> bQuit.pack()</h4>

<p>Metoda <code>pack</code> opìt zajistí zviditelnìní tlaèítka.</p>

<h4>>>> top.mainloop()</h4>

<p>Tímto odstartujeme provádìní tkinterovské smyèky zpráv. Povšimnìte si,
vyzıvací znaky '<code>>>>&nbsp;</code>' pøíkazového øádku systému Python nyní
zmizely. Podle toho poznáme, e øízení <span class="trnote" 
title="Poznámka pøekladatele">další èinnosti</span> pøešlo do reie Tkinter.
Pokud stisknete tlaèítko <code>Konec</code>, vyzıvací znaky pøíkazového
øádku se znovu objeví, co je dùkaz toho, e zafungoval náš parametr
<code>command</code>.</p>

<p>Poznamenejme, e pokud toté provádíme z prostøedí Pythonwin nebo IDLE,
mùe bıt chování odlišné. Pokud tomu tak skuteènì je, zkuste dosud uvedené
pøíkazy zapsat do pythonovského skriptu<span class="trnote" 
title="Poznámka pøekladatele">, tedy do textového souboru s pøíponou
<code>py</code>,</span> a spuste jej z pøíkazového øádku operaèního
systému.</p>

<p>On vlastnì nastal pøíhodnı okamik k tomu, abychom to stejnì vyzkoušeli.
Kdy se to tak vezme, tímto zpùsobem se v praxi provozuje vìtšina
tkinterovskıch programù. Pouijme klíèové pøíkazy z tìch, o kterıch jsme se
zatím bavili:</p>

<pre>
from Tkinter import *

<span class="comment"># Vytvoøíme samotné okno.</span>
top = Tk()
F = Frame(top)
F.pack()

<span class="comment"># Pøidáme ovládací prvky.</span>
lHello = Label(F, text="Ahoj")
lHello.pack()
bQuit = Button(F, text="Konec", command=F.quit)
bQuit.pack()

<span class="comment"># Spustíme smyèku událostí.</span>
top.mainloop()
</pre>

<p>Volání metody <code>top.mainloop</code> zahájí provádìní tkinterovské
smyèky událostí. V tomto pøípadì bude jedinou zachycenou událostí ta, která
odpovídá stisku tlaèítka a která je spojena s provedením metody
<code>F.quit</code>. Její provedení zpùsobí ukonèení aplikace. Vyzkoušejte
si to. Vısledek by mìl vypadat takto:</p>

<p class="center"><img src="cztk_hellbut.png" 
alt="Popisnı text a tlaèítko."></p>


<h3>Bliší prùzkum umísování prvkù (layout)</h3>

<p><b>Poznámka:</b> V následujícím textu budou pøíklady uvádìny v podobì, 
jakou mají v pythonovskıch zdrojovıch souborech. Nebudou tedy uvozeny
øetìzcem '<code>>>>&nbsp;</code>', kterı se vypisuje na zaèátku vstupního
øádku interpretu jazyka Python.</p>

<p>V této èásti bych se rád zamìøil na to, jak Tkinter umísuje prvky
(widget) uvnitø okna. V pøedchozím textu jsme si ji ukázali prvky typu
<code>Frame</code>, <code>Label</code> a <code>Button</code>. Ty nám pro
potøeby této èásti textu postaèí. V pøedchozím pøíkladu jsme pouívali
metodu prvku (widget) zvanou <code>pack</code> k umístìní prvku uvnitø jeho
rodièovského okna. Technicky vzato jsme tím aktivovali <em>správce rozloení
prvkù</em> systému Tk, kterému se øíká <em>packer</em>. Úkolem správce
rozloení prvkù (Layout Manager) je urèení nejlepšího rozloení prvkù, které
je zaloeno na nápovìdì pøedepsané programátorem a na omezeních, jako je
napøíklad velikost okna, kterou ovlivòuje uivatel. Nìkteré typy správcù
rozloení prvkù pouívají pøesné umístìní uvnitø okna, které je pøedepsáno v
pixelech<sup class="trnote"><a href="cztuttrn.html#Pgui_pixel"
id="BPgui_pixel" title="Vysvìtlení pojmu pixel.">[1]</a></sup>. S tímto
pøístupem se bìnì setkáte v systému Microsoft Windows, napøíklad pøi
pouívání programátorského prostøedí Visual Basic. V modulu Tkinter
dosáhneme tého pøi pouití správce rozloení prvkù, kterému se øíká
<em>placer</em> (doslova "umísovaè") &mdash; èiníme tak voláním jeho metody
<code>place</code>. V této uèebnici se uvedenım správcem rozloení zabıvat
nebudeme, protoe obvykle bıvá lepší, kdy si vybereme jeden ze zbıvajících,
inteligentnìjších správcù rozloení prvkù. Jejich pouití zbavuje
programátory starosti o to, co se stane, kdy okno zmìní své rozmìry.</p>

<p>V Tkinter je nejjednodušším správcem rozloení prvkù takzvanı
<em>packer</em>, kterı jsme ji pouívali v pøedchozím textu.
<em>Packer</em>, pokud mu neøekneme jinak, jednoduše skládá ovládací prvky
(widget) jeden na druhı. Z hlediska bìnıch ovládacích prvkù tuto vlastnost
vyuijeme velmi zøídka, ale pokud sestavujeme rozhraní naší aplikace z
rámeèkù (<code>Frame</code>), pak mùeme povaovat skládání rámeèkù na sebe
za docela rozumnı pøístup. Ostatní ovládací prvky mùeme do rámeèkù
umísovat buï s vyuitím správce rozloení typu <em>packer</em> nebo uvnitø
rámeèku podle potøeby vyuijeme vlastností jiného správce rozloení. Pøíklad
pouití takového pøístupu mùete najít v <a href="cztutcase.html">pøípadové
studii</a>.</p>

<p>Ale dokonce i tak jednoduchı správce rozloení prvkù, jako je
<em>packer</em>, poskytuje celou øadu voleb. Napøíklad uvedením argumentu
<code>side</code> (strana, do strany, stranovì) mùeme pøedepsat uspoøádání
našich prvkù ve vodorovném, místo ve svislém smìru:</p>

<pre>
lHello.pack(side="left")
bQuit.pack(side="left")
</pre>

<p>Tyto pøíkazy pøinutí prvky, aby se skládaly zleva <span class="trnote"
title="Poznámka pøekladatele">(left [left], znamená levı nebo vlevo)</span>.
Take první prvek (typu <code>Label</code>) se objeví úplnì vlevo. Za ním
následuje další prvek (typu <code>Button</code>). Pokud uvedené øádky
pøíkladu upravíme uvedenım zpùsobem, bude vısledek vypadat takto:</p>

<p class="center"><img src="cztk_leftpack.png" 
alt="Prvky poskládané zleva." title="Prvky poskládané zleva."></p>

<p>A pokud zmìníme hodnotu <code>"left"</code> na <code>"right"</code> <span
class="trnote" title="Poznámka pøekladatele">([rajt] znamená pravı,
vpravo)</span>, pak se prvek typu <code>Label</code> objeví úplnì vpravo a
prvek typu <code>Button</code> vlevo od nìj<span class="trnote"
title="Poznámka pøekladatele">, jinımi slovy, co nejvíc vpravo, jak je to za
aktuálního stavu moné</span>. Vısledek bude vypadat takto:</p>

<p class="center"><img src="cztk_rightpack.png" 
alt="Prvky poskládané zprava." title="Prvky poskládané zprava."></p>

<p>Jedna z vìcí, které si mùete všimnout je, e to nevypadá moc hezky,
protoe pvky jsou pøíliš nalepeny na sebe. Správce <em>packer</em> nám ale
nabízí další parametry, které nám umoní vypoøádat se i s touto situací.
Snadno pouitelné jsou takzvané <em>vycpávky</em> (také vıplnì; v originále
padding, èti pading). Mùeme pøedepsat vodorovné vycpávky
(<code>padx</code>) a svislé vycpávky (<code>pady</code>). Jejich hodnoty se
udávají v pixelech. Doplòme tedy do našeho pøíkladu vodorovné vycpávky:</p>

<pre>
lHello.pack(side="left", padx=10)
bQuit.pack(side='left', padx=10)
</pre>

<p>Vısledek by mìl vypadat nìjak takto:</p>

<p class="center"><img src="cztk_padx.png" alt="Vodorovné vycpávky." 
title="Vodorovné vycpávky."></p>

<p>Pokud zkusíte mìnit velikost okna, mùete pozorovat, e oba prvky
zachovávají svou vzájemnou pozici, ale zùstávají uprostøed okna. Proè tomu
tak je? Vdy jsme je pøeci nechali poskládat zleva? Odpovìï zní: prvky jsme
poskládali dovnitø obalujícího rámeèku (<code>Frame</code>), ale samotnı
rámeèek jsme do okna vloili (metodou <code>pack</code>) bez uvedení
parametru <code>side</code>. Take rámeèek je jako celek v oknì umístìn
nahoøe uprostøed, co odpovídá základnímu chování správce rozloení typu
<em>packer</em>. Pokud bychom chtìli, aby byly prvky umístìny na poadované
stranì okna, musíme i pøi volání metody <code>pack</code> pro objekt typu
<code>Frame</code> uvést vhodnou hodnotu parametru <code>side</code>:</p>

<pre>
F.pack(side='left')
</pre>

<p>Nyní si mùete všimnout, e pøi zmìnì svislého rozmìru okna zùstávají
prvky uprostøed vıšky okna &mdash; jde opìt o základní chování správce
rozloení typu <em>packer</em>.</p>

<p>Nechám u na vás, abyste si sami pohráli s hodnotami parametrù
<code>padx</code> a <code>pady</code>. Pozorujte vliv jejich rùznıch hodnot
a kombinací. Zejména parametry <code>side</code> a
<code>padx</code>/<code>pady</code> umoòují pøi pouití správce rozloení
typu <em>packer</em> pomìrnì pruné monosti umísování prvkù typu widget.
Existují ještì další parametry. Kadı z nich pøidává další, jemnìjší podobu
øízení umístìní. Detaily hledejte na referenèních stránkách modulu
Tkinter.</p>

<p>Modul Tkinter poskytuje ještì další správce rozloení, které jsou známy
jako <em>grid</em> (míka) a <em>placer</em> (umísovaè). Pouití správce
typu grid aktivujeme voláním metody <code>grid()</code> místo
<code>pack()</code>. V pøípadì pouití správce typu <em>placer</em> voláme
místo metody <code>pack()</code> metodu <code>place()</code>. Kadá z
uvedenıch metod má svou sadu parametrù, ale protoe se zde zabıváme pouze
správcem typu <em>packer</em>, budete muset detaily hledat v uèebnici a v
referenèní pøíruèce Tkinter. Zmíním se jen o tom, e správce typu
<em>grid</em> zaøídí uspoøádání prvkù do møíky (jaké pøekvapení!) uvnitø
okna. Jeho pouití je uiteèné napøíklad v pøípadì dialogovıch oken se
zarovnanımi poli pro vkládání textu. U správce typu <em>placer</em> mùeme
pouít buï pevné souøadnice v pixelech nebo relativní souøadnice uvnitø
okna. Poslednì zmiòovaná monost umoòuje, aby vloenı prvek mìnil své
rozmìry souèanì s pvkem napøíklad tak, aby vdy zabíral napøíklad
75&nbsp;procent svislého prostoru. Tento správce umoòuje øešit zvláštní
návrhové poadavky, ale vyaduje to od nás, abychom si pøedem vše
naplánovali. Vøele vám doporuèuji, abyste si pro tyto úèely obstarali
ètvereèkovanı papír, tuku a gumu.</p>

<h3>Øízení vzhledu za pouití rámeèkù a správce typu <em>packer</em></h3>

<p>U prvku (widget) typu <code>Frame</code> mùeme ve skuteènosti ovlivnit
nìkolik uiteènıch vlastností. Kdy se to tak vezme, není špatné, kdy
mùeme prvky uivatelského rozhraní z logického hlediska obalit rámeèkem,
ale nìkdy navíc chceme také nìco vidìt. Hodí se nám to zejména v pøípadech
seskupení ovládacích prvkù jako jsou pøepínací tlaèítka (radio buttons) nebo
zaškrtávací pole voleb (check boxes). Tøída <code>Frame</code> tento problém
øeší tím, e poskytuje vlastnost <em>relief</em> &mdash; tak jako mnoho
dalších prvkù Tk typu widget. Relief mùe nabıvat libovolné z následujících
hodnot: <code>sunken</code> ([sankn]; ponoøenı, vmáèknutı),
<code>raised</code> ([reizd]; vystouplı, vyzvednutı), <code>groove</code>
([grúv]; dráka, vyrytı) <code>ridge</code> ([rid]; høbet, geometrickı opak
dráky) nebo <code>flat</code> ([flat]; plochı). Vyzkoušejme u našeho
dialogového okna hodnotu <code>sunken</code>. Jednoduše zmìníme øádek, na
kterém se vytváøí prvek tøídy <code>Frame</code>:</p>

<pre>F = Frame(top, relief="sunken", border=1)</pre>

<p><b>Poznámka 1:</b> Musíme uvést i <span class="trnote" 
title="Poznámka pøekladatele" >nenulovou</span> hodnotu parametru
<code>border</code> ([bódr]; hranice). Pokud tak neuèiníme, bude sice plocha
prvku typu <code>Frame</code> ponoøená, ale hranice <span class="trnote"
title="Poznámka pøekladatele">mezi ponoøenou a okolní plochou</span> bude
neviditelná, take nezpozorujeme ádnı rozdíl.</p>

<p><b>Poznámka 2:</b> &hellip; o tom, proè tloušku hranice (border)
neuvádíme v uvozovkách. Znalost toho, zda máme pouít uvozovky kolem hodnoty
parametru a kdy je vynechávat, patøí k jedné z matoucích vlastností Tk.
Obecnì se dá øíci, e u èíselnıch nebo jednoznakovıch hodnot mùeme uvozovky
vynechávat. Pokud jde o smìs èíslic a písmen nebo o øetìzec, musíme pouít
uvozovky. Podobnı problém spoèívá v tom, kdy pouít malá nebo velká písmena.
Naneštìstí zde neexistuje jednoduchı návod. Musíte se prostì uèit ze
zkušeností. V pøípadì chyby Python èasto v chybovıch hlášeních vypisuje
seznam pøípustnıch hodnot parametrù.</p>

<div class="trnote">
<p><b>Poznámka pøekladatele k poznámce 2:</b> Aby se zvıšila èitelnost
zdrojovıch textù, jsou pro vyhrazené øetìzcové argumenty definovány
øetìzcové promìnné, které se pouívají v roli pøeddefinovanıch konstant.
Jejich jména jsou psána velkımi písmeny. Naleznete je v souboru
<code>Tkconstants.py</code>. Zde definovaná jména jsou zviditelnìna v rámci
importu Tkinter. Ve zdrojovıch textech proto místo</p>

<pre>F = Frame(top, relief="sunken", border=1)</pre>

<p>mùeme psát:</p>

<pre>F = Frame(top, relief=SUNKEN, border=1)</pre>

<p>Podobnì mùeme místo <code>side="left"</code> psát <code>side=LEFT</code>
a podobnì. Uvedené obraty mùete pozorovat dále v textu.</p>

</div>

<p>Další vìc, které si mùete všimnout, je ta, e <code>Frame</code>
nevyplòuje okno. Mùeme to napravit pouitím dalšího parametru správce typu
<em>packer</em>, parameru <code>fill</code> ([fil]; vyplnit). Pøi volání
metody <code>pack()</code> tedy zapíšeme:</p>

<pre>F.pack(fill=X)</pre>

<p>Uvedenı parametr zpùsobí vyplnìní prostoru ve vodorovném smìru. Vyplnìní
prostoru ve svislém smìru zajistíme pouitím <code>fill=Y</code>. Mezi bìné
poadavky patøí vyplnìní prostoru v obou smìrech. Pro tyto pøípady máme k
dispozici hodnotu parametru <code>BOTH</code>. <span class="trnote"
title="Poznámka pøekladatele">(Nechtìjte po mì, abych zde normálními
písmenky zapisoval vıslovnost. Kadopádnì slovo <em>both</em> znamená
<em>oba</em> &mdash; tedy vyplòování v obou smìrech.)</span></p>

<pre>F.pack(fill=BOTH)</pre>

<p>Vısledek by mìl vypadat takto:</p>

<p class="center"><img src="cztk_sunken.png" alt="Ponoøující rámeèek."></p>

<h3>Pøidejme další prvky</h3>

<p>Podívejme se nyní na prvek (widget) pro tøídy <code>Entry</code>
([entry]; vstup). Jde o známı prvek pro zadávání jednoøádkového textu. Øada
jeho metod se shoduje s metodami propracovanìjšího prvku (widget) tøídy
<code>Text</code>, ale tím se zde zabıvat nebudeme. Pøesto doufám, e
pouíváním metod prvku tøídy <code>Entry</code> získáte dobré základy pro
pozdìjší experimenty s prvkem tøídy <code>Text</code>.</p>

<p>Vrátíme se opìt k našemu programu, kterı zobrazuje <code>Ahoj, vy
tam!</code>, pøidáme do nìj prvek pro vkládání textu do samostatného prvku
typu <code>Frame</code> a také tlaèítko, které umí vymazat text, kterı do
pole vepisujeme. Tím si ukáeme nejen to, jak se dá vytvoøit a pouívat
prvek typu <code>Entry</code>, ale také jak mùeme definovat své vlastní
funkce pro ošetøení (zpracování) událostí a jak je naváeme na ovládací
prvky.</p>

<pre>
from Tkinter import *

<span class="comment"># Nejdøíve vytvoøíme funkci pro ošetøení události.</span>
def evVymazat():
  eTxt.delete(0, END)

<span class="comment"># Vytvoøíme hierarchicky nejvyšší okno a rámeèek.</span>
top = Tk()
F = Frame(top)
F.pack(expand=True)

<span class="comment"># Nyní vytvoøíme rámeèek s polem pro vstup textu.</span>
fVstup = Frame(F, border=1)
eTxt = Entry(fVstup)
fVstup.pack(side=TOP, expand=True)
eTxt.pack(side=LEFT, expand=True)

<span class="comment"># Nakonec vytvoøíme rámeèek s tlaèítky. 
# Pro zvıraznìní jej vytvoøíme jako ponoøenı (vmáèknutı).</span>
fTlacitka = Frame(F, relief=SUNKEN, border=1)
bVymazat = Button(fTlacitka, text="Vymazat text", command=evVymazat)
bVymazat.pack(side=LEFT, padx=5, pady=2)
bKonec = Button(fTlacitka, text="Konec", command=F.quit)
bKonec.pack(side=LEFT, padx=5, pady=2)
fTlacitka.pack(side=TOP, expand=True)

<span class="comment"># Nyní spustíme smyèku zpráv.</span>
F.mainloop()
</pre>

<p>Povšimnìte si, e jméno funkce pro ošetøení události
(<code>evVymazat</code>) opìt pøedáváme jako hodnotu argumentu
<code>command</code> pøi vytváøení tlaèítka <code>bVymazat</code>.
Povšimnìte si také konvence pro vytváøení jména <code>evXXX</code> funkce
pro ošetøení události &mdash; dáváme jí najevo vazbu s odpovídajícím prvkem
typu widget.</p>

<p>Po spuštìní programu obdríme následující vısledek:</p>

<p class="center"><img src="cztk_entry.png" alt="Prvky typu Entry a Button."
title="Prvky typu Entry a Button."></p>

<p>Pokud nìco napíšeme do vstupního pole a poté stiskneme tlaèítko
"<code>Vymazat&nbsp;text</code>", bude napsanı text opìt odstranìn.</p>

<h3>Navázání událostí &mdash; od ovládacích prvkù ke kódu</h3>

<p>Doposud jsme pro propojení pythonovskıch funkcí s událostmi tlaèítek
&mdash; jako prvkù grafického uivatelského rozhraní &mdash; pouívali
vlastnost tlaèítek zvanou <code>command</code>. Nìkdy ovšem potøebujeme
zajistit pøesnìji a pøímo vyjádøenı zpùsob ovládání. Chceme napøíklad
zachytit událost stisku zvláštní kombinace kláves. Mùeme toho dosáhnout
pouitím funkce <code>bind</code> ([bajnd]; svázat, spojit), kterou lze
pøímo vyjádøit vazbu mezi nìjakou událostí pythonovskou funkcí.</p>

<p>Do pøedchozího pøíkladu dodefinujeme "horkou klávesu" (hot key) &mdash;
dejme tomu <code>Ctrl-c</code> &mdash;, která rovnì zpùsobí vymazání textu.
Potøebujeme tedy navázat kombinaci kláves <code>Ctrl-c</code> na stejnou
funkci pro obsluhu událostí, na kterou se váe událost tlaèítka
<code>Vymazat</code>. Máme tu ale jednu neoèekávanou nepøíjemnost. Parametru
<code>command</code> jsme museli pøedávat jméno funkce, která nesmìla mít
ádné parametry. Pokud chceme pouít k provedení stejné èinnosti funkci
<code>bind</code>, musí navazovaná funkce definovat jeden parametr. Proto
musíme vytvoøit novou funkci, která pøebírá jeden argument a volá
<code>evVymazat</code>. Za definici funkce <code>evVymazat</code> proto
pøidejme následující definici:</p>

<pre>
def evHorkaKlavesa(udalost):
    evVymazat()
</pre>

<p>A za definici prvku typu <code>Entry</code> pøidejme následující
øádek:</p> 

<pre>
<span class="comment"># Definice klávesy je citlivá na velikost písmen.</span>
eTxt.bind("&lt;Control-c&gt;", evHorkaKlavesa) 
</pre>

<p>Spuste znovu upravenı program. Nyní mùete text vymazat buï stiskem
pøíslušného tlaèítka nebo stiskem kombinace kláves <code>Ctrl-c</code>.
Funkci <code>bind</code> mùeme pouít i pro zachycení takovıch událostí,
jako jsou kliknutí myši, událost získání nebo ztráty aktivity okna (fokus)
nebo dokonce událost, která doprovází situaci, kdy se okno stane viditelnım.
Více informací na toto téma naleznete v dokumentaci k Tkinter. Nejsloitìjší
obvykle bıvá zjistit podobu zápisu poadované události.</p>

<h3>Krátká zpráva</h3>

<p>Chceme-li uivatelùm našeho programu zobrazit krátkou zprávu, mùeme k
tomu vyuít prvek zvanı <em>Message Box</em> ([mesid box]; doslova okno se
zprávou). Pøi vyuití Tk je to velmi snadné. Za tímto úèelem mùeme pouít 
funkce modulu <code>tkMessageBox</code> napøíklad takto:</p>

<pre>
import tkMessageBox
tkMessageBox.showinfo("Titulek okna", "Krátká zpráva") 
</pre>

<p>Pro zobrazování oken chybovıch hlášení, varování, dotazù typu Ano/Ne nebo
OK/Storno existují také další funkce nazvané <code>showXXX</code> ([šou];
uka). Pøíslušná okna se odlišují rùznımi ikonami a tlaèítky. Dvì poslední
zmínìné varianty pouívají místo názvu tvaru <code>showXXX</code> názvy
<code>askXXX</code> ([ásk]; zeptej se) a vracejí hodnotu, která øíká, jaké
tlaèítko uivatel stiskl:</p>

<pre>
vysledek = tkMessageBox.askokcancel("Co zvolíte?", "Chcete zastavit èinnost?")
print vysledek
</pre>

<div class="trnote">

<p id="Bcz_tkinter"><b>Poznámka pøekladatele k èeskım textùm s
diakritikou:</b> Více podrobností o problémech hledejte <a
href="cztuttrn.html#Pinput_noascii">v poznámce, ke vstupu èeskıch znakù</a>,
která se vztahuje k èásti uèebnice, <a href="cztutinput.html#Binput_noascii"
>kde jsme se zabıvali vstupem z klávesnice</a>. Naleznete v ní ovšem i údaje
k <a href="cztuttrn.html#Pcz_tkinter">pouívání èeskıch textù pro prvky
grafického uivatelského rozhraní</a>. Struènì: pro zobrazení èeského textu
v oknech Tk mùeme vyuít pøevodu do kódování Unicode. Vyuijeme k tomu
funkci <code>unicode()</code>:</p>

<pre>
# -*- coding: cp1250 -*-
import tkMessageBox
vysledek = tkMessageBox.askokcancel(
               unicode("Co zvolíte?", "cp1250"), 
               unicode("Chcete zastavit èinnost?", "cp1250"))
print vysledek
</pre>

<p>První komentáøovı øádek øíká, e zdrojovı text byl programu byl zapsán v
kódování <code>cp1250</code> &mdash; je známé také jako
<code>windows-1250</code>. Øádek se uvádí hned na zaèátku skriptu, obvykle
jako první nebo druhı. (V unixovém svìtì se na prvním øádku uvádí jinı typ
komentáøe, kterı pro skripty s pøíznakem spustitelnosti urèuje jméno
programu, kterı má skript interpretovat.) Zvláštní tvar øádku s
posloupnostmi <code>-*-</code> souvisí s konvencemi, které byly v minulosti
zavedeny u nìkterıch známıch textovıch editorù. Pokud tento øádek neuvedeme,
pak se pøi spuštìní skriptu (pøinejmenším od verze Pythonu 2.3) setkáme s
varovnım hlášením, e byl v øetìzci pouit znak s kódem vìtším, ne 127 a
pøitom nebylo upøesnìno pouité kódování.</p>

<p>Abych v dalších pøíkladech nemusel vymıšlet texty, které vypadají èesky a
pøitom neobsahují znaky s diakritikou, budu tento obrat pouívat. V praxi je
ale vıhodnìjší nadefinovat si obalující funkce nebo metody tøíd (pøípadnì
odvozené tøídy), které pøevody kódování ukrıvají a pøi psaní zdrojového
textu se nám to pak jeví, jako kdyby Python umìl odjakiva èesky.</p>

</div>

<p>A takto vypadají nìkterá okna se zprávami:</p>

<p class="center">
<img src="cztk_info.png" alt="Okno s informací." title="Okno s informací.">&nbsp;
<img src="cztk_error.png" alt="Okno s chybou." title="Okno s chybou.">&nbsp;
<img src="cztk_yesno.png" alt="Okno s dotazem Ano/Ne." 
title="Okno s dotazem Ano/Ne."></p>

<h3>Z pohledu jazyka Tcl</h3>

<p>V úvodních èástech této uèebnice jsme srovnávali Python s Tcl. Proto
povauji za rozumné, abychom si ukázali, jak by úvodní pøíklad s prvky typu
<code>Label</code> a <code>Button</code> vypadal v originální podobì zapsané
v Tcl/Tk:</p>

<pre>
Label .lHello -text "Ahoj, vy tam!"
Button .bHello -text Konec -command "exit"
wm title . Ahoj
pack .lHello .bHello
</pre>

<p>Jak sami vidíte, zápis je velmi struènı. Hierarchie prvkù typu widget je
vyjadøována s vyuitím konvence jejich pojmenování, kde prvek se jménem
'<code>.</code>' stojí na nejvyšší úrovni. Jak u je v Tcl zvykem, prvky
typu widget jsou vyjadøovány pøíkazy, kterım jsou poadované vlastnosti
pøedány formou argumentù. Doufám, e je vám pøevod parametrù prvkù do podoby
pojmenovanıch argumentù v jazyce Python docela jasnı. Pokud tedy pøi
programování s Tkinter potøebujete vyøešit nìjaké problémy, mùete pouít
dokumentaci systému Tcl/Tk (které je velmi mnoho). Pøepis do Tkinter je
vìtšinou zøejmı.</p>

<p>Dál u se v tomto místì do Tcl/Tk pouštìt nebudeme. V následujícím textu
si ukáeme bìnì pouívanou techniku pro zabalení aplikací s grafickım
uivatelskım rozhraním vyuívajících Tkinter do podoby objektù.</p>

<h3>Zabalení aplikací do podoby objektù</h3>

<p>Pøi programování aplikací s grafickım uivatelskım rozhraním se bìnì
celá aplikace obaluje do podoby tøídy. To vyvolává otázku, jak do této
struktury tøíd napasujeme prvky typu widget modulu Tkinter? Na vıbìr máme
dvì monosti. Buï se rozhodneme pro odvození tøídy aplikace od tkinterovské
tøídy <code>Frame</code>, nebo uloíme referenci na hierarchicky nejvyšší
okno do èlenské promìnné. Poslednì zmínìnı pøístup se bìnì pouívá i u
jinıch prostøedkù (toolkit), take jej pouijeme i my. Pokud byste chtìli
vidìt pouití prvního ze zmiòovanıch pøístupù, vrate se k pøíkladu v
kapitole <a href="cztutevent.html#Tkinter_example">Událostmi øízené
programování</a>. (Zmínìnı pøíklad mimo jiné ukazuje základy pouití
neuvìøitelnì univerzálního tkinterovského prvku (widget) tøídy
<code>Text</code>.)</p>

<div class="trnote">

<p><b>Poznámka pøekladatele:</b> Pøístup, kdy ukládáme referenci na
hierarchicky nejvyšší okno odpovídá obecnému doporuèení pøi objektovì
orientovaném návrhu aplikací. To øíká, e bychom mìli <em>dávat pøednost
kompozici pøed dìdièností</em>. Jinımi slovy to znamená, e pokud si mùeme
vybrat, zda spojit funkènost dvou tøíd dohromady, bıvá lepší, kdy nìjak
spojíme <em>objekty</em> dvou jednodušších tøíd, ne kdybychom vytváøeli
jednu novou, sloitìjší tøídu. Ve svém dùsledku to vede k vyšší prunosti
pøi budoucích úpravách návrhu aplikace. Návrh bıvá také pøehlednìjší.
Dìdiènost (tj. odvozování jedné tøídy objektù z jiné) bychom mìli pouívat
pøedevším tehdy, kdy pouze <em>upravujeme</em> funkènost bázové tøídy pro
speciální úèel. Nemìli bychom ji pouívat, kdy chceme propojit funkènosti
dvou tøíd s odlišnım úèelem.</p>

</div>

<p>Vıše uvedenı pøíklad, vyuívající vstupní pole typu <code>Entry</code>,
tlaèítko Vymazat a tlaèítko Konec, pøevedeme do objektovì orientované
podoby. Nejdøíve si vytvoøíme tøídu aplikace a v rámci jejího konstruktoru
poskládáme viditelné èásti grafického uivatelského rozhraní.</p>

<p>Referenci na vıslednı prvek typu <code>Frame</code> pøiøadíme do
<code>self.hlavniOkno</code>. Tím lze zajistit pøístup k hierarchicky
nejvyššímu prvku typu <code>Frame</code> ostatním metodám tøídy. Ostatní
prvky (widget), ke kterım bychom mohli chtít pøistupovat (jako je napøíklad
pole typu <code>Entry</code>) jsou podobnım zpùsobem pøiøazeny do èlenskıch
promìnnıch instance tøídy <code>Frame</code>. Pøi vyuití popsané techniky
se funkce pro zpracování událostí stanou metodami aplikaèní tøídy a kadá z
tìchto metod mùe pøistupovat k libovolnım datovım èlenùm aplikace (aèkoliv
v tomto pøípadì ádné datové èleny nevytváøíme) prostøednictvím reference
<code>self</code>. Tím zajistíme pøirozené propojení prvkù grafického
uivatelského rozhraní s ostatními aplikaèními objekty:</p>

<pre>
from Tkinter import *
     
class AplikaceVymazat:
    def __init__(self, rodic=0):
        self.hlavniOkno = Frame(rodic)
        <span class="comment"># Vytvoøíme widget tøídy Entry</span>
        self.vstup = Entry(self.hlavniOkno)
        self.vstup.insert(0, "Ahoj, vy tam!")
        self.vstup.pack(fill=X)
      
        <span class="comment"># Nyní pøidáme dvì tlaèítka a pouijeme efekt dráky.</span>
        fTlacitka = Frame(self.hlavniOkno, border=2, relief=GROOVE)
        bVymazat = Button(fTlacitka, text="Vymazat", 
                          width=8, height=1, command=self.vymazatText)
        bKonec = Button(fTlacitka, text="Konec", 
                        width=8, height=1, command=self.hlavniOkno.quit)
        bVymazat.pack(side=LEFT, padx=15, pady=1)
        bKonec.pack(side=RIGHT, padx=15, pady=1)
        fTlacitka.pack(fill=X)
        self.hlavniOkno.pack()

        <span class="comment"># Nastavíme nadpis okna.</span>
        self.hlavniOkno.master.title("Vymazat")
      
    def vymazatText(self):
        self.vstup.delete(0, END)
      
aplikace = AplikaceVymazat()
aplikace.hlavniOkno.mainloop()
</pre>

<p>Vısledek vypadá takto:</p>

<p class="center"><img src="cztk_oopentry.png" 
alt="Objektovì orientovaná verze pøíkladu."
title="Objektovì orientovaná verze pøíkladu."></p>

<p>Stojí za povšimnutí, e vısledek vıraznì pøipomíná pøedchozí verzi
pøíkladu. Trochu jsme upravili spodní rámeèek, aby získal pìknìjší podobu s
drákou okolo. Nastavili jsme také šíøky tlaèítek, abychom se pøiblíili
vzhledu, kterı bude mít další pøíklad, vyuívající nadstavbu wxPython.</p>

<p>Do podoby objektu samozøejmì mùeme zabalit nejen hlavní aplikaci. Mohli
bychom vytvoøit tøídu s prvkem typu <code>Frame</code>, kterı obaluje
standardní sadu tlaèítek. Tu pak mùeme vyuívat napøíklad pøi vytváøení
dialogovıch oken. Mohli bychom dokonce vytvoøit <span class="trnote"
title="Poznámka pøekladatele">tøídy pro</span> celé dialogy a ty pak
pouívat v nìkolika projektech. Nebo bychom mohli rozšíøit schopnosti
standardních prvkù typu widget definicí odvozenıch tøíd. Napøíklad bychom
mohli vytvoøit tlaèítko, které mìní barvu v závislosti na svém stavu. Nìco
takového provádí modul <em>Python Mega Widgets</em> (PMW), co je rozšíøení
Tkinter &mdash; PMW si mùete stáhnout (download).</p>

<h3>Alternativa jménem wxPython</h3>

<p>Pro práci s grafickım uivatelskım rozhraním je k dispozici mnoho dalších
nástrojù (toolkit), ale jedním z nejpopulárnìjších je wxPython. Ten je pro
zmìnu pythonovskou obálkou kolem nástroje wxWindows pro jazyk C++. Z
obecného hlediska je wxPython mnohem typiètìjším nástrojem pro práci s
grafickım uivatelskım rozhraním, ne je Tkinter. V základní podobì také
poskytuje více standardní funkènosti, ne Tk. Poskytuje prvky jako tooltip
<span class="trnote" title="Poznámka pøekladatele">([túltip];
<em>bublina</em> s textem pro prvek leící pod kurzorem myši)</span>,
stavová lišta (status bar) a další, které si v Tkinter musíte vytvoøit sami.
Pomocí wxPython si znovu pøepíšeme døíve uvedenı pøíklad "<code>Ahoj, vy
tam!</code>", kterı pouívá prvky typu <code>Label</code> a
<code>Button</code>.</p>

<p>Co se tıká wxPython, nepùjdeme pøíliš do detailù. Pokud se chcete
dozvìdìt více o tom, jak wxPython pracuje, budete si muset stáhnout <span
class="trnote" title="Poznámka pøekladatele">instalaèní</span> balík z <a
href="http://www.wxPython.org/" target="_blank">webovskıch stránek
wxPython</a>.</p>

<p>Obecnì se dá øíci, e tato nástrojová sada (toolkit) definuje pracovní
rámec (framework), kterı nám dovolí vytváøet okna, umísovat do nich
ovládací prvky a navazovat na nì metody<span class="trnote" 
title="Poznámka pøekladatele">, tj. definovat, které metody se mají volat
pro obsluhu událostí tìchto ovládacích prvkù</span>. wxPython je plnì
objektovì orientován, take byste <span class="trnote" 
title="Poznámka pøekladatele">pro obsluhu událostí</span> mìli pouívat
opravdu metody a ne funkce. Pøíklad pouití vypadá následovnì:</p>

<pre>
from wxPython.wx import *

<span class="comment"># --- Definujeme uivatelskı rámeèek (Frame), kterı se stane hlavním oknem. ---</span>
class RamecekAhoj(wxFrame):
    def __init__(self, rodic, ID, titulek, pozice, velikost):
        wxFrame.__init__(self, rodic, ID, titulek, pozice, velikost)
        <span class="comment"># Pouití panelu zajistí správné pozadí.</span>
        panel = wxPanel(self, -1)

        <span class="comment"># Nyní vytvoøíme text a tlaèítka.</span>
        self.tAhoj = wxTextCtrl(panel, -1, "Ahoj, vy tam!", (3,3), (185,22))
        tlacitko = wxButton(panel, 10, "Vymazat", (15, 32))
        tlacitko = wxButton(panel, 20, "Konec", (100, 32))

        <span class="comment"># Nyní sváeme tlaèítka s obslunımi metodami.</span>
        EVT_BUTTON(self, 10, self.OnVymazat)
        EVT_BUTTON(self, 20, self.OnKonec)
        
    <span class="comment"># Následují naše metody pro obsluhu událostí.</span>
    def OnVymazat(self, udalost):
        self.tAhoj.Clear()
       
    def OnKonec(self, udalost):
        self.Destroy()

<span class="comment"># --- Definujeme aplikaèní objekt. ---
# Poznamenejme, e všechny wxPythonovské programy MUSÍ definovat 
# tøídu aplikaèního objektu jako tøídu odvozenou od wxApp.</span>
class AplikaceAhoj(wxApp):
    def OnInit(self):
        frame = RamecekAhoj(NULL, -1, "Ahoj", (200,50), (200,90))
        frame.Show(True)
        # self.setTopWindow(frame)
        return True

<span class="comment"># Vytvoøíme instanci tøídy a spustíme smyèku zpráv.</span>
AplikaceAhoj().MainLoop()
</pre>

<p>Vısledek vypadá takto:</p>

<p class="center"><img src="czwx_hello.png" alt="Program Ahoj ve wxPython"
title="Program Ahoj ve wxPython"></p>

<p>Za povšimnutí stojí pouívání konvence pro pojmenování metod, které mají
bıt volány z rámce (framework) wxPython &mdash; <code>OnXxxx</code>. <span
class="trnote" title="Poznámka pøekladatele">(Pøedloku <em>On</em> bychom
pro tento pøípad mohli doslova pøekládat jako <em>Pøi</em>.)</span>
Povšimnìte si také funkcí <code>EVT_XXX</code>, kterımi se definuje vazba na
události prvkù. <span class="trnote" title="Poznámka pøekladatele">(Zkratka
<code>EVT</code> pochází z anglického <em>event</em> [ivent], tj.
událost.)</span> Podobnıch funkcí existuje celá rodina. Systém wxPython
vyuívá celou øadu ovládacích prvkù (widget) &mdash; mnohem více, ne je
tomu u Tkinter. Lze jimi realizovat pomìrnì nároèná grafická uivatelská
rozhraní. Naneštìstí se u nich pouívá pøevánì rozmisovací schéma zaloené
na souøadnicích, které budete ji po chvíli vnímat jako velmi únavné.
Existuje sice monost pouití schématu, které se velmi podobá tkinterovskému
správci rozloení zvanému <em>packer</em>, ale tento prostøedek není pøíliš
dobøe dokumentován. Pro tvorbu grafického uivatelského rozhraní existuje
komerènì dostupnı nástroj. Doufejme, e se brzy objeví i nìjaká zdarma
dostupná alternativa.</p>

<p>Za zmínku stojí to, e poslednì uvedenı pøíklad a velmi podobnı, døíve
uvedenı pøíklad psanı v Tkinter, mají pøiblinì stejnı poèet øádkù (<span
class="trnote" title="Poznámka pøekladatele">v anglickém originále jich
je</span> 19 pro Tkinter a 20 pro wxPython &mdash; <span class="trnote"
title="Poznámka pøekladatele"> pokud nepoèítáme komentáøové a prázdné øádky.
V èeském pøekladu jsem se o dosaení pøesnì stejného poètu øádkù
nesnail.)</span></p>

<p>Shrneme-li to, pak v pøípadì, kdy chcete k nìjakému textovì orientovanému
nástroji rychle vytvoøit jednoduché grafické uivatelské rozhraní, pak by
mìl Tkinter vyhovìt vašim poadavkùm pøi souèasné minimalizaci nutného
úsilí. Pokud chcete vytváøet aplikace s plnohodnotnım grafickım uivatelskım
rozhraním, které mají bıt pouitelné na více platformách, pak byste se mìli
blíe seznámit s wxPython.</p>

<p>Mezi další nástroje pro budování grafického uivatelského rozhraní patøí
MFC, .NET a jsou zde samozøejmì letité <em>curses</em>, co je vlastnì
grafické uivatelské rozhraní realizované v textovém prostøedí. <span
class="ir">Poznámka k .NET.</span></p>

<p class="trnote"><b>Poznámka pøekladatele:</b> Knihovna <em>curses</em>
Vyuívá moností textového reimu zobrazovacích adaptérù, kdy lze
pøedepisovat zobrazování znakù na danıch pozicích textové obrazovky, urèení
barev takto zobrazeného textu, a další. Pokud si pod tímto popisem
nedovedete nic pøedstavit, vzpomeòte si na klasickou verzi aplikace Norton
Commander, jeho kvalitního windowsovského soupeøe zvaného FAR, pøípadnì
linuxovskou variantu zvanou Midnight Commander (mc). Mùete si pøedstavit i
libovolnou <em>klasickou</em> dosovou aplikaci, která pouívala okénka
tvoøená z rámeèkovıch znakù. Aplikace s podobnım vzhledem vznikaly døíve,
ne se objevily první verze Windows. Knihovna <em>curses</em> ale má svùj
pùvod v unixovém svìtì, z jeho promyšlenıch abstrakcí tvùrci Windows velmi
èasto èerpají. Nìkdy to jde tak daleko, e nìkteøí napùl ertem øíkají, e
a budou jednou MS&nbsp;Windows dokonèené, bude to nejlépe dokumentovanı
Unix na svìtì.</p>

<p>Øadu vìcí, které jsme se nauèili v souvislosti s Tkinter, lze aplikovat
na všechny ze zmínìnıch prostøedkù pro tvorbu grafického uivatelského
rozhraní. Kadı z nich má ale své charakterické vlastnosti, zvláštnosti,
podivnosti a neduhy. Vyberte si nìkterı z nich, nauète se jej a uívejte si
bláznivého svìta návrhu grafického uivatelského rozhraní. Na závìr bych se
mìl zmínit, e pro øadu tìchto nástrojù existují grafické prostøedky pro
návrh a tvorbu uivatelského rozhraní. Jako pøíklad uveïme Blackadder pro Qt
a Glade pro GTK. Pro wxPython se o zjednodušení procesu vıstavby grafického
uivatelského rozhraní snaí prostøedek zvanı <a
href="http://pythoncard.sourceforge.net/" target="_blank">Python Card</a>.

<p>To nám prozatím staèí. Nechceme zde vytváøet novou referenèní pøíruèku
pro Tkinter. Cílem bylo pouze uvedení nezbytnıch vìcí k tomu, abyste mohli
uèinit první kroky. Odkazy na další zdroje informací o Tkinter naleznete
v&nbsp;<a href="http://www.python.org/topics/tkinter/" target="_blank">sekci
Tkinter</a> na webovskıch stránkách systému Python.</p>

<p>Problematikou pouívání Tcl/Tk se také zabıvá nìkolik knih. Pøinejmenším
jedna se vìnuje pøímo Tkinter. K Tkinter se nicménì vrátíme v&nbsp;<a
href="cztutcase.html">pøípadové studii</a>, kde si ukáeme jeden ze
zpùsobù, jak obalit program s dávkovım charakterem grafickım uivatelskım
rozhraním. Tím se docílí zlepšení pouitelnosti pùvodního programu.</p>

<hr>
<div class="foot">
<p class="navig">[ 
<a href="cztutevent.html" title="Událostmi øízené programování">pøedchozí</a> |
<a href="cztutcont.html">obsah</a> | 
<a href="cztutfctnl.html" title="Funkcionální programování">další</a> 
]</p>
<p class="note">Pokud vás napadne, co by se dalo na pøekladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztutgui.html,v 1.6 2004/08/31 11:55:13 prikryl Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka' 
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20') 
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script> 

Tím budou do dopisu automaticky vloeny informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztutgui.html,v 1.6 2004/08/31 11:55:13 prikryl Exp $</p>
</div>
</body>
</html>


<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se nauèit programovat: Data, datové typy a promìnné</title>
</head>
<body>


<h2>Data, datové typy a promìnné</h2>

<div class="whatcovered">
<p class="title">O èem si budeme povídat?</p>
<ul>
<li>Co jsou data.</li>
<li>Co jsou promìnné.</li>
<li>Datové typy a co se s nimi dá dìlat.</li>
<li>Definování našich vlastních datovıch typù.</li>
</ul>
</div>

<h3>Úvod</h3>

<p>Pøi jakékoliv kreativní tvorbì potøebujeme tøi základní poloky:
nástroje, suroviny a techniky (postupy). Kdy si napøíklad budeme chtít nìco
namalovat, našimi nástroji budou štìtce, tuky a paleta. Technikami budeme
rozumìt malování vlhkım do vlhkého, rozmıvání, sprejování a podobnì. A
koneènì surovinami budou barvy, papír a voda. Pøi programování je to
podobné. Našimi nástroji jsou programovací jazyky, operaèní systémy a
hardware. Za techniky budeme povaovat pouívání programovıch konstrukcí, o
kterıch jsme se zmínili v pøedchozí èásti <span class="trnote"
title="Poznámka pøekladatele">(Koncepty &mdash; <a href="cztutwhat.html">Co
je to <em>programování</em>?</a> &mdash; <a
href="cztutwhat.html#Dijkstra">Spoleèné vlastnosti programù</a>)</span>.
Surovinami budou data, se kterımi budeme manipulovat. V této kapitole se
zamìøíme právì na tyto suroviny.</p>

<p>Tato kapitola je docela dlouhá a ze své podstaty ponìkud nezáivná. Dobrá
zpráva je, e si ji nemusíte pøeèíst celou najednou. Kapitola zaèíná
pohledem na nezákladnìjší datové typy, které máme k dispozici. Dále si
øekneme nìco o tom, jak zacházet s kolekcemi poloek. A nakonec se podíváme
na nìkterá pokroèilejší témata. Ètení kapitoly mùete pøerušit po pøeètení
èásti o kolekcích. Poté si mùete pøeèíst nìkolik dalších kapitol a doèíst
ji mùete v okamiku, kdy zaèneme pouívat sloitìjší vìci.</p>


<h3>Data</h3>

<p>Pojem <em>data</em> je jedním z tìch, kterı lidé èasto pouívají, ale
málokdo rozumí jeho pøesnému vıznamu. V mém slovníku je pojem data definován
takto:</p>

 <blockquote>
 <em>"fakta nebo údaje, ze kterıch je moné odvodit závìry; informace"</em>
 </blockquote>

<a name="type"></a> <p>Pøíliš nám to sice nepomùe, ale tuto definici mùeme
pouít alespoò jako odrazovı mùstek. Uvidíme, zda se vìci neozøejmí, kdy se
podíváme na to, jak je pojem data pouíván v oblasti programování. Data jsou
oním <em>materiálem</em>, surovımi informacemi, se kterımi manipuluje váš
program. Bez dat nemùe program provádìt ádnou uiteènou èinnost. Programy
mohou s&nbsp;daty manipulovat rùznımi zpùsoby. Èasto to závisí na
<em>typu</em> dat. S kadım datovım typem je spojena skupina
<em>operací</em> &mdash; tj. èinností, které lze s daty <span class="trnote"
title="Poznámka pøekladatele">daného typu</span> provést. U èísel jsme si
napøíklad ukázali, e je mùeme sèítat. Sèítání je tedy operace, kterou
mùeme pouít pro data typu èíslo. Datovıch typù mùe bıt velké mnoství.
Postupnì se podíváme na nejbìnìjší z nich a na operace, které lze pro nì
pouít.</p>

<h3>Promìnné</h3>

<p>Data jsou uloena v pamìti vašeho poèítaèe. Mùeme ji pøirovnat k velké
stìnì plné skøínìk, která se na poštách pouívá k tøídìní poštovních
zásilek. Dopis mùete strèit do libovolné skøíòky, ale pokud by na tìchto
skøíòkách nebyly štítky s konkrétní cílovou adresou, nedávalo by jejich
pouití smysl. Promìnné pøestavují ty popisné štítky<sup
class="trnote"><a href="cztuttrn.html#Pdata_variable" id="Bdata_variable"
title="Poznámka k odlišnosti chápání pojmu promìnná v rùznıch jazycích."
>[1]</a></sup> na skøíòkách a ony skøíòky jsou vytvoøeny v pamìti vašeho
poèítaèe.</p>

<p>Zatím tedy víme, jak data vypadají. To je sice pìkné, ale k tomu, abychom
s nimi mohli manipulovat, musíme bıt schopni se k nim dostat. Právì k tomuto
úèelu se pouívají promìnné. V programátorské terminologii øíkáme, e
vytváøíme <em>instance</em> datovıch typù a pøiøazujeme je do promìnnıch<sup
class="trnote" id="Bdata_refinstance" title="Instance a její identifikace"
><a href="cztuttrn.html#Pdata_refinstance">[2]</a></sup>. Promìnná
pøedstavuje <em>odkaz</em> (nebo jinımi slovy <em>referenci</em>) na urèitou
oblast, která leí nìkde v pamìti poèítaèe. V tìchto pamìovıch oblastech
jsou data uloena. V nìkterıch poèítaèovıch jazycích musí promìnná odpovídat
typu dat, na která odkazuje. Jakıkoliv pokus o pøiøazení chybného typu dat
do takové promìnné zpùsobí ohlášení chyby. Nìkteøí programátoøi dávají
takovım jazykùm pøednost &mdash; øíká se jim jazyky se <em>statickou typovou
kontrolou</em><sup class="trnote" id="Bdata_stattype" 
title="Statická typová kontrola..."><a href="cztuttrn.html#Pdata_stattype"
>[3]</a></sup> &mdash;, protoe umoòují pøedcházet urèitım záludnım chybám,
které se obtínì hledají.</p>

<p>Pravidla pro tvorbu jmen promìnnıch jsou závislá na konkrétním
programovacím jazyce. Kadı jazyk pøedepisuje, které znaky mohou bıt souèástí
jména promìnné, a které ne. V nìkterıch jazycích &mdash; a patøí k nim i
Python a JavaScript &mdash; záleí na <em>velikosti</em> písmen a v angliètinì
jsou oznaèovány jako <em>case sensitive</em> [keis sensitiv], èili <em>citlivé
na velikost</em>. Jiné jazyky, jako napøíklad VBScript, velká a malá písmena
nerozlišují. Jazyky citlivé na velikost písmen po programátorovi vyadují
trošku peèlivìjší pøístup. Velmi nám pomùe, kdy budeme pøi volbì jmen
promìnnıch pouívat urèitı systém. Jeden z bìnıch stylù, kterı budeme èasto
pouívat, zahajuje jméno promìnné malımi písmeny a u kadého dalšího slova
uvádí první písmeno velké:</p>

<pre>
velmiDlouheJmenoPromenneSOddelovanimSlovVelkymiPismeny
</pre>

<p class="trnote"><b>Poznámka pøekladatele:</b> Pro jména promìnnıch musíme
v&nbsp;jazyce Python volit písmena bez diakritickıch znamének.</p>

<p>Nebudeme zde podrobnìji probírat pravidla popisující, které znaky mùeme v
našich jazycích pouívat. Pøi dodrování stylu pouívaného v
ukázkách byste se nemìli setkat s nìjakımi problémy.</p>

<p>V jazyce Python promìnná získává typ podle do ní pøiøazenıch dat. Datovı
typ si tato promìnná zapamatuje a pokud se pokusíte kombinovat data rùzného
typu nedovolenım zpùsobem &mdash; jako je napøíklad sèítání øetìzce a èísla
&mdash;, budete varováni. (Vzpomínáte si na døíve uvedenı pøíklad s chybovım
hlášením? Ten byl pøíkladem právì takového typu chyby.) Pokud pozdìji
promìnné pøiøadíte data jiného typu, pak se typ promìnné zmìní. <span
class="trnote" title="Poznámka&nbsp;pøekladatele">(To není napøíklad u vıše
zmínìnıch jazykù se statickou typovou kontrolou moné.)</span></p>

<pre>
>>> q = 7       <span class="comment"># v q je nyní èíslo</span>
>>> print q
7
>>> q = "Sedm"  <span class="comment"># do q jsme pøiøadili øetìzec</span>
>>> print q
Sedm
</pre>

<p>Povšimnìte si, e na zaèátku byl promìnné <code>q</code> pøiøazen odkaz
na <em>èíslo</em> <code>7</code>. V promìnné se hodnota odkazu udrovala a
do té doby, ne jsme ji pøinutili, aby ukazovala na øetìzec "Sedm". Take
ještì jednou: promìnné jazyka Python si uchovávají typ dat, na která
ukazují. Ale to, na co ukazují, mùeme zmìnit jednoduše dalším pøiøazením do
této promìnné. V tomto okamiku jsou pùvodní data prohlášena za 'ztracená' a
Python je odstraní z pamìti (pokud na nì souèasnì neodkazuje jiná promìnná).
Tento proces je znám jako <em>garbage collection</em>. <span
class="trnote">(Poznámka pøekladatele: Èti gábid kolekšn. Tento pojem je
natolik specifickı, e se obvykle nepøekládá; doslova by se dal pøeloit
jako <em>sbírání smetí</em>.)</span></p>

<p>Garbage collection mùeme pøirovnat k èinnosti poštovního úøedníka, kterı
jednou a èas odstraní všechny dopisy a balíèky ze skøínìk, které nemají
ádnı nápis. Pokud tyto dopisy na sobì nemají cílovou adresu nebo adresu 
odesílatele, hodí je do smetí.</p>


<h3>Promìnné v jazycích VBScript a JavaScript</h3>

<p>Pøi pouívání promìnnıch v jazycích VBScript a JavaScript se navíc 
setkáváme s drobnou odlišností. Oba uvedené jazyky vyadují, abychom
promìnnou pøed jejím pouitím <em>deklarovali</em>. Jde o obecnı rys, se
kterım se setkáme u kompilovanıch jazykù a u jazykù se <em>silnou typovou
kontrolou</em>. Jednou z velkıch vıhod tohoto pøístupu je to, e pøekladaè
mùe odhalit pokus o pouití neznámé promìnné. K této situaci mùe dojít
tím, e se pøi zápisu pouití promìnné dopustíme pøeklepu v jejím jménì.
Nevıhodou je samozøejmì to, e programátor toho musí napsat o nìco víc.</p>

<div class="trnote">

<p><b>Poznámka pøekladatele:</b> Uvedená nevıhoda je zanedbatelná tím více,
èím vìtší projekt se realizuje. V takovıch pøípadech programátor vìnuje
mnohem více úsilí ostatním vìcem, ne je jednoduché klapání do klávesnice.
Za skuteènou nevıhodu mùeme povaovat nutnost deklarace promìnnıch pouze u
jazykù, kde musíme deklaraci uvést na vıraznì jiném místì zdrojového textu,
ne se objevuje její první pouití. (Pøi pohledu do zdrojového textu &mdash;
typicky pøes okno editoru s omezenım poètem øádkù na obrazovce &mdash; mùe
programátor ztratit pøehled o deklaraci promìnné. Musí ji dohledávat a
ztrácí tím èást svého èasu a mentální kapacity.) Pøíkladem takového jazyka
je napøíklad jazyk <code>C</code>. Naproti tomu napøíklad modernìjší jazyk
<code>C++</code> dovoluje uvést deklaraci pøímo v místì prvního pouití
promìnné.</p>

<p>Zajímavìjší diskusi lze vést na téma <em>silná</em> versus <em>slabá
typová kontrola</em>. Donedávna se tradovalo, e silná typová kontrola je
vdy a jednoznaènì lepší, protoe umoòuje odhalit urèitou kategorii chyb
ji pøi pøekladu. V poslední dobì ji nejsou názory tak vyhranìné. Silná
typová mùe mít i nevıhody (komplikuje napøíklad <em>generické
programování</em>) a navíc nezaruèí odhalení jiné kategorie chyb &mdash;
špatnou interpretaci hodnoty formálnì správného typu. Odpovìdi na tyto
problémy se nyní nehledají pouze v technikách fungování pøekladaèù, ale i v
technologiích a technikách vıvoje aplikací, v postupech programátorù. Jedním
z pøístupù, kterı prokázal svou uiteènost, je psaní <em>testù
funkènosti</em> (<em>unit testing</em> &mdash; jednotkové testy a
<em>acceptance testing</em> &mdash; uivatelské testy). Pouèení i zajímavé
námìty k zamyšlení naleznete v èlánku <a
href="http://www.artima.com/intv/strongweak.html" target="_blank">Strong
versus Weak Typing</a>.</p>

</div>

<h4>VBScript</h4>

<p>Deklaraci promìnné zajistíme v jazyce VBScript pouitím pøíkazu
<code>Dim</code>, co je zkratka slova <em>Dimension</em> <span
class="trnote" title="Poznámka pøekladatele">([dajmenn] = rozmìr)</span>.
Jde o projev dávnıch koøenù jazyka VBScript v jazyce BASIC a pøes nìj ještì
dále v jazycích typu assembler. V tìchto jazycích jste museli uvést, jak
velkı pamìovı prostor bude promìnná vyadovat &mdash; tedy její rozmìr,
velikost. Zkratka <code>Dim</code> se dochovala z tìchto dob.</p>

<p>Deklarace promìnné v jazyce VBScript vypadá takto:</p>
<pre>
Dim promenna
</pre>

<p>Jakmile je promìnná jednou deklarována, mùeme ji pouívat stejnì, jako
jsme to ukázali u Pythonu. Jedním pøíkazem <code>Dim</code> mùeme
deklarovat více promìnnıch. Jejich seznam oddìlujeme èárkami:</p>

<pre>
Dim promenna, druha, treti
</pre>

<p>Pøiøazení provedeme takto:</p>

<pre>
promenna = 42
druha = "Toto je krátká vìtièka."
treti = 3.14159
</pre>

<p>Dalším klíèovım slovem, se kterım se mùete obèas setkat, je
<code>Let</code> <span class="trnote" title="Poznámka pøekladatele">([let] =
nech)</span>. Jde opìt o pozùstatek z jazyka BASIC a ve skuteènosti jej
nemusíte vùbec pouívat. Pokud pøesto nìkdy uvidíte jeho pouití, bude
vypadat nìjak takto:</p>

<pre>
Let promenna = 22
</pre>

<p>V této uèebnici nebudeme <code>Let</code> pouívat.</p>


<h4>JavaScript</h4>

<p>V jazyce JavaScript je deklarace promìnnıch uvedena klíèovım slovem
<code>var</code> a v jedné deklaraci mùeme uvést více promìnnıch, jako v
pøípadì VBScript:</p>

<pre>
var promenna, druha, treti;
</pre>

<p>Souèástí pøíkazu <code>var</code> mùe bıt v jazyce JavaScript i
inicializace (nebo <em>definice</em>, <span class="trnote"
title="Poznámka&nbsp;pøekladatele">tj. urèení poèáteèní hodnoty</span>)
promìnnıch:</p>

<pre>
var promenna = 42;
var druha = "Krátká vìta.", treti = 3.14159; 
</pre>

<p>Ušetøíme tím trochu psaní, ale jinak se tato forma <span class="trnote"
title="Poznámka&nbsp;pøekladatele">funkènì</span> od dvoukrokové definice
promìnnıch v jazyce VBScript nijak neliší.</p>

<p>Doufám, e tento struènı pohled promìnné v jazycích VBScript a JavaScript
objasnil rozdíl mezi jejich <em>deklarací</em> a <em>definicí</em>. V jazyce
Python dojde k <em>deklaraci</em> promìnné v okamiku, kdy je uvedena její
<span class="trnote" title="Poznámka&nbsp;pøekladatele">první</span>
definice.</p>

<p>Nyní se podívejme na pøíklady datovıch typù a uvidíme, jak to všechno
pasuje dohromady.</p>


<h3>Jednoduché datové typy</h3>

<p>Jednoduché datové typy se nazıvají jednoduchımi proto, e patøí k
nejzákladnìjším typùm dat, se kterımi se dá manipulovat. Sloitìjší datové
typy jsou ve skuteènosti jen kombinacemi jednoduchıch datovıch typù.
Jednoduché datové typy jsou stavebními kameny, ze kterıch se ostatní typy
budují. Jednoduché datové typy pøedstavují opravdovı základ veškerıch
vıpoètù. Patøí k nim písmena, èísla a nìco, èemu se øíká boolovskı typ
(boolean).</p>


<h3 id="string">Znakové øetìzce</h3>

<p>U jsme se s nimi setkali. Patøí k nim doslova libovolné øetìzce, neboli
posloupnosti znakù, které mohou bıt zobrazeny na vaší obrazovce. (Ve
skuteènosti mohou obsahovat i netisknutelné <em>øídicí znaky</em>.)</p>

<p>V jazyce Python mohou bıt øetìzce zapsány nìkolika zpùsoby:</p>

<dl>
<dt>S jednoduchımi apostrofy</dt>
<dd><pre>'Toto je retezec'</pre></dd>

<dt>S uvozovkami</dt>
<dd><pre>"Toto je velmi podobny retezec"</pre></dd>

<dt>S trojitımi uvozovkami</dt>
<dd><pre>"""Tady je velmi dlouhy retezec, ktery -- pokud
   si to budeme prat -- muze byt zapsan na vice 
   radcich. Python zachova viceradkovy retezec 
   ve tvaru, v jakem jej zapiseme..."""
</pre>
</dd>
</dl>

<p>Naposledy zmínìná forma má jedno speciální pouití. Pouívá se k
dokumentování funkcí, které jsme v jazyce Python sami napsali &mdash; k tomu
se ještì dostaneme.</p>

<p>K jednotlivım znakùm øetìzce mùeme pøistupovat jako ke slokám znakového
pole (viz <em>pole</em> dále v textu). Kadı programovací jazyk obvykle
poskytuje operace pro manipulaci s øetìzci &mdash; nalezni podøetìzec, spoj
dva øetìzce, okopíruj jeden øetìzec jinam a podobné.</p>

<p>Za zmínku stojí skuteènost, e nìkteré jazyky pouívají zvláštní typ pro
ukládání znakù &mdash; tedy typ pro jeden znak. V takovém pøípadì mùeme o
øetìzcích uvaovat jako o kolekcích hodnot typu znak. Ve srovnání s tímto
pøístupem Python pouívá pro uloení jednoho znaku jednoduše øetìzec o délce
jedna. To znamená, e nepotøebuje jinı syntaktickı pøedpis pro zápis øetìzce
a jinı pro zápis jednoho znaku.</p>

<h4>Øetìzcové operátory</h4>

<p>Nad øetìzci lze provádìt celou øadu operací. Nìkteré z nich jsou pøímo
zabudovány do jazyka Pyhon, ale øada dalších je poskytována moduly, které
musíme zapojit do èinnosti pøíkazem <code>import</code> (tak, jak jsme to
udìlali s modulem <code>sys</code> v kapitole <a
href="cztutseq1.html">Jednoduché posloupnosti</a>).</p>

<div class="center">
<table summary="Øetìzcové operátory">
<col span="2" style="padding: 0 1em">
<caption>Øetìzcové operátory</caption>
<tr><td>S1 + S2</td><td>Spojení øetìzce S1 a S2</td></tr>
<tr><td>S1 * N</td><td>N-násobné opakování øetìzce S1</td></tr>
</table>
</div>

<p>Následující pøíklady demonstrují jejich funkci:</p> 

<pre>
>>> print 'Znovu a ' + 'znovu'        <span class="comment"># spojení øetìzcù</span>
Znovu a znovu
>>> print 'Opakuj ' * 3               <span class="comment"># opakování øetìzce</span>
Opakuj Opakuj Opakuj
>>> print 'Znova ' + ('a znova ' * 3) <span class="comment"># kombinace '+' a '*'</span>
Znova a znova a znova a znova
</pre>

<p>Øetìzce znakù mùeme pøiøazovat do promìnnıch:</p> 

<pre>
>>> s1 = 'Znova '
>>> s2 = 'a znova '
>>> print s1 + (s2 * 3)
Znova a znova a znova a znova
</pre>

<p>Všimnìte si, e poslední dva pøíklady dávají stejnı vıstup.</p> 

<p>S øetìzci se dá dìlat spousta dalších vìcí, ale k tomu se podrobnìji
dostaneme a v dalších tématech. Nejdøíve si musíme osvojit základnìjší
znalosti.</p>


<h4>Øetìzcové promìnné v jazyce VBScript</h4>

<p>V jazyce VBScript jsou promìnné <span class="trnote" title="Poznámka
pøekladatele">(v angliètinì)</span> oznaèovány jako <em>variants</em>,
protoe mohou obsahovat libovolnı typ dat. <span class="trnote"
title="Poznámka pøekladatele">(Nepøekládal jsem jako <em>varianty</em>,
protoe by se to pletlo s <em>monostmi</em>.)</span> VBScript se je podle
potøeby pokouší pøevádìt na poadovanı typ. To znamená, e do promìnné
mùete pøiøadit èíslo, ale v okamiku, kdy promìnnou pouijete v místì, kde
se oèekává øetìzec, VBScript provede potøebnı pøevod. Dá se øíci, e se to
podobá chování pythonovského pøíkazu <code>print</code>, ale podobné chování
je rozšíøeno na všechny pøíkazy jazyka VBScript. Pokud chceme pøekladaèi
napovìdìt, e se na nìjakou èíselnou hodnotu má dívat jako na øetìzec,
uzavøeme ji do uvozovek:</p>

<pre>
&lt;script type="text/vbscript">
retezec = "42"
MsgBox retezec
&lt;/script>
</pre>

<p class="trnote"><b>Poznámka pøekladatele:</b> Zatímco <code>print</code>
se snaí pøevést vše na øetìzec, automatické konverze ve VBScript se
principiálnì snaí pøevádìt cokoliv na cokoliv. Mùeme se na to také podívat
také jinak. Snaha o pøevod do pouitelné podoby je v Pythonu vlastností
pøíkazu <code>print</code>, zatímco ve VBScript je vlastností promìnnıch
samotnıch. Tuto vlastnost jazyka VBScript ocení pøedevším zaèáteèníci a dá
se dobøe vyuít u jednoduchıch skriptù. U sloitìjších a rozsáhlejších
programù mùe bıt podobné chování zdrojem obtínì odhalitelnıch chyb.</p>

<p>Øetìzce mùeme spojovat dohromady. Této operaci se øíká
<em>zøetìzení</em> (konkatenace) a v jazyce VBScript k ní pouíváme operátor
<code>&amp;</code> takto:</p>

<pre>
&lt;script type="text/vbscript">
retezec = "Ahoj, " &amp; "vy tam!"
MsgBox retezec
&lt;/script>
</pre>

<h4>Øetìzce v JavaScript</h4>

<p>V jazyce JavaScript mohou bıt øetìzce uzavøeny buï v apostrofech nebo v
uvozovkách. Promìnné<span class="trnote"
title="Poznámka&nbsp;pøekladatele">, které pouijeme pro jejich
zpøístupnìní,</span> musíme pøed pouitím <em>deklarovat</em>. Pouíváme k
tomu klíèové slovo <code>var</code>. Take deklaraci a <em>definici</em>
dvou øetìzcovıch promìnnıch provedeme v jazyce JavaScript takto:</p>

<pre>
&lt;script type="text/javascript">
var retezec1, retezec2;
retezec1 = "Ahoj, ";
retezec2 = "vy tam!";
document.write(retezec1 + retezec2)
&lt;/script>
</pre>

<p>Jako poznámku na závìr uveïme, e v jazyce JavaScript mùeme vytváøet
øetìzce i jako <em>objekty</em> typu <code>String</code>. O objektech se
budeme bavit o nìco pozdìji. Prozatím mùeme o objektech typu
<code>String</code> uvaovat jako o obyèejnıch øetìzcích s urèitımi
vlastnostmi navíc. Hlavní rozdíl spoèívá v tom, e je vytváøíme trochu
jinak:</p>

<pre>
&lt;script type="text/javascript">
var retezec1, retezec2;
retezec1 = String("Ahoj, ");
retezec2 = String("vy tam!");
document.write(retezec1 + retezec2)
&lt;/script>
</pre>


<h3>Celá èísla</h3>

<p>Celá èísla &mdash; <span class="trnote" title="Poznámka pøekladatele">v
rùznıch programovacích jazycích známá jako <em>integer</em>, nemají
desetinnou èást &mdash; </span> jejich hodnoty se pohybují od velkıch
zápornıch hodnot a po velké kladné hodnoty. Tuto dùleitou skuteènost
bychom si mìli zapamatovat. Obvykle neuvaujeme o tom, e by èísla mìla bıt
co do velikosti nìjak omezena, ale u poèítaèù existují jejich horní a dolní
hranice. Hodnota horní hranice je známa jako MAXINT a závisí na poètu bitù,
které váš poèítaè pouívá pro reprezentaci èísla. Na vìtšinì souèasnıch
poèítaèù je to 32&nbsp;bitù, take konstanta MAXINT odpovídá hodnotì kolem 2
miliard. (V jazyce VBScript je to jen kolem 32 tisíc. <span class="trnote"
title="Poznámka pøekladatele">Pro reprezentaci èísla se pouívá jen 16 bitù,
èili dva bajty, take mùeme vyjádøit èísla v rozmezí pøiblinì +/-32
tisíc</span>.)</p>

<p>Èísla, která mohou nabıvat jak kladnıch, tak zápornıch hodnot jsou
oznaèována jako <em>celá èísla se znaménkem</em> (<em>signed integer</em>).
Nìkdy se vyuívají i èísla, která jsou omezena pouze na kladné hodnoty a
nulu. Oznaèujeme je jako <em>celá èísla bez znaménka</em> (<em>unsigned
integer</em>). <span class="trnote">(Poznámka pøekladatele: Pokud na chvíli
zapomeneme na omezení horní hranicí, pak v matematice takovım èíslùm øíkáme
<em>pøirozená èísla</em>.)</span> V takovém pøípadì se horní hranice zvìtší
na dvojnásobek hodnoty MAXINT &mdash; u 32bitovıch èísel na hodnotu kolem 4
miliard &mdash;, protoe prostor, kterı byl jinak vyhrazen pro reprezentaci
zápornıch èísel, mùe bıt vyuit pro reprezentaci dalších kladnıch
èísel.</p>

<p>Protoe jsou celá èísla <span class="trnote"
title="Poznámka&nbsp;pøekladatele" >(budeme øíkat také <em>èísla typu
integer</em>)</span> shora omezena konstantou MAXINT, mùe nastat situace, kdy
souèet dvou èísel pøesáhne konstantu MAXINT a vıslednı souèet bude chybnı<span
class="trnote" title="Poznámka&nbsp;pøekladatele">, protoe správnı vısledek
nelze do vyhrazeného prostoru 32 bitù uloit</span>. V nìkterıch
systémech/jazycích se vrací tato špatná hodnota pøímo tak jak vyšla (èasto je
souèasnì nastaven skrytı pøíznak chyby, kterı mùete testovat, pokud
pøedpokládáte, e k chybì mohlo dojít). Obvykle se však v této situaci vyvolá
chybovı stav, kterı mùete vaším programem zjistit a ošetøit. Pokud tak
neuèiníte, program se ukonèí. Jazyky VBScript a JavaScript se chovají poslednì
zmínìnım zpùsobem. Poslední verze jazyka Python se v chování mírnì liší. Od
verze 2.3 vıše Python automaticky pøevádí celé èíslo na nìco, èemu se øíká
<em>velké celé èíslo</em> (<em>long integer</em>; <span class="trnote"
title="Poznámka&nbsp;pøekladatele">nezamìòujte s typem <code>long</code> v
jazycích C a C++, kdy se èíslo ukládá na 32 bitech</span>). Jde o specifickou
vlastnost jazyka, která umoòuje pracovat s celımi èísly o prakticky neomezené
velikosti. Nic ovšem není zadarmo. Platíme za to cenou mnohem pomalejšího
zpracování. Pøinejmenším si však mùeme bıt jisti tím, e naše vıpoèty nakonec
skonèí korektnì. Navíc rychlost je v poèítaèovém svìtì velmi relativní. Pokud
takovıch velmi velkıch celıch èísel nezpracováváme mnoho, pravdìpodobnì si
rozdílu ani nevšimnete. To, e se skuteènì jedná o velké celé èíslo mùeme
poznat podle toho, e je Python zobrazuje s pøipojenım 'L' (jako long):</p>

<pre>
>>> 1234567 * 3456789
4267637625363L
>>> _
</pre>

<p>Povšimnìte si, e jsme zde nepouili pøíkaz <code>print</code>. Pokud
bychom tak uèinili, zmínìné 'L' by zùstalo skryto. Python umoòuje <span
class="trnote" title="Poznámka&nbsp;pøekladatele">v interaktivním
reimu</span> dva zpùsoby zobrazování hodnot. Vısledek pouití pøíkazu
<code>print</code> je obvykle hezèí (ve smyslu snadnìjší èitelnosti), ale
prosté pouití hodnoty, jako ve vıše uvedeném pøíkladu, nám obèas odhalí více
detailù. Zkuste si pøíklady z pøedchozích témat zapsat bez pouití pøíkazu
<code>print</code> a zamìøte se na pozorování drobnıch rozdílù v zobrazení.
Pøíkaz <code>print</code> budu pouívat také z toho dùvodu, e mnohé jazyky
jeho pouití vyadují. A také chci, aby vám do krve pøešly dobré obecné návyky
a ne pouze podlné postupy, které vám umoòuje Python.</p>


<h4>Aritmetické operátory</h4>

<p>S vìtšinou aritmetickıch operátorù, které budeme potøebovat, jsme se ji
setkali v kapitole <a href="cztutseq1.html">Jednoduché posloupnosti</a>.
Zopakujme si je:</p>

<table summary="Aritmetické operátory v jazyce Python">
<caption>Aritmetické operátory v jazyce Python</caption>
<col span="2" valign="top" style="padding: 0 1em">
<tr><th>Pøíklad</th><th>Popis vıznamu</th></tr>
<tr>
<td>M + N</td>
<td>Sèítání M a N</td>
</tr>

<tr>
<td>M - N</td>
<td>Odèítání N od M</td>
</tr>

<tr>
<td>M * N</td>
<td>Násobení M a N</td>
</tr>

<tr>
<td>M / N</td>
<td>Dìlení, jak èísel typu integer tak reálnıch èísel. Vısledek
záleí na typu èísel M a N. Kdy je alespoò jedno z èísel M a N reálné,
vısledek bude té reálnı.</td>
</tr>

<tr>
<td>M&nbsp;%&nbsp;N</td>
<td>Modulo: nalezne zbytek po celoèíselném dìlení M : N</td>
</tr>

<tr>
<td>M**N</td>
<td>Umocòování: M na N-tou</td>
</tr>
</table>

<p>O posledním z nich jsme se ještì nezmínili. Podívejme se na pøíklad v
nìm vytvoøíme nìkolik promìnnıch typu integer a poté pouijeme operátor pro
umocòování:</p>


<pre>
>>> i1 = 2    <span class="comment"># vytvoø promìnnou i1 a pøiøaï jí hodnotu celého èísla</span>
>>> i2 = 4
>>> i3 = 2**4 <span class="comment"># pøiøaï vısledek dvì na ètvrtou do i3</span>
>>> print i3
16
</pre>


<h4>Celá èísla v jazyce VBScript</h4>

<p>Jak ji bylo uvedeno vıše, hodnoty typu integer jsou v jazyce VBScript
omezeny menší hodnotou MAXINT, která odpovídá uloení na 16 bitech &mdash;
konkrétnì zhruba +/-32 tisíc. Pokud potøebujete pracovat s vìtší
celoèíselnou hodnotou, mùete pouít <code>long</code>. Ten <span
class="trnote" title="Poznámka&nbsp;pøekladatele" >co do rozsahu</span>
odpovídá typu integer, kterı je standardnì pouíván v jazyce Python. Ve
VBScript lze pouívat i typ <code>byte</code>, kterı definuje èísla uloená
na 8 bitech, s maximální hodnotou 255 <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(interval 0 a 255)</span>. V praktickıch
pøípadech vám vìtšinou bude vyhovovat pouití standardního typu integer.</p>

<p>Podporovány jsou všechny aritmetické operátory.</p>


<h4>Èísla v jazyce JavaScript</h4>

<p>Jistì není ádnım pøekvapením, e JavaScript také definuje numerickı typ.
Èísla mají opìt podobu objektu, viz dále, a nazıvají se <code>Number</code>
<span class="trnote" title="Poznámka&nbsp;pøekladatele" >(tj. èíslo)</span>.
Jak originální, e? :-)</p>

<p>V jazyce JavaScript lze pouít i takzvané <em>Not a Number</em> neboli
<em>NaN</em> <span class="trnote" title="Poznámka&nbsp;pøekladatele"
>(<em>ne-èíslo</em> nebo <em>toto-není-èíslo</em>)</span>. Jde o speciální
verzi objektu Number a reprezentuje neplatné èíslo. Vìtšinou se pouívá v
roli vısledku nìjaké operace, která je z matematického hlediska nepøípustná.
Hlavní myšlenka zavedení NaN spoèívá v monosti testovat nìkteré typy chyb
ani by došlo k pøerušení programu. JavaScript definuje i další speciální
verze typu Number, které reprezentují kladné a záporné nekoneèno. V
programovacích jazycích se tento rys objevuje zøídka. Èíselné objekty v
jazyce JavaScript reprezentují buï celá èísla nebo reálná èísla &mdash; viz
dále.</p>


<h3>Reálná èísla</h3>

<p>Jde o èísla s desetinnou èástí, o zlomky<sup class="trnote"
id="Bdata_real" title="Jsou to tedy reálná nebo racionální èísla?"><a
href="cztuttrn.html#Pdata_real">[4]</a></sup>. Mohou reprezentovat èísla
velmi velká, mnohem vìtší ne MAXINT, ale s menší pøesností. To znamená, e
dvì èísla, která by mìla bıt shodná, ve skuteènosti pro poèítaè stejná
nejsou. Je to dáno tím, e poèítaè ukládá jen pøiblinou hodnotu v
závislosti na tom, jakou úroveò detailù èísla je schopen zachytit. Napøíklad
èíslo 4.0 by mohlo bıt uloeno jako 3.9999999&hellip; nebo
4.000000&hellip;01. Ve vìtšinì pøípadù taková pøiblinost postaèuje, ale
obèas mùe mít dùleité dopady. Pokud pøi pouívání reálnıch èísel dostanete
nìjaké legraèní vısledky, mìjte tuto skuteènost na pamìti.</p>

<p>S reálnımi èísly, známımi také jako èísla <em>s plovoucí øádovou
èárkou</em> (<em>floating-point numbers)</em>, mùeme provádìt stejné
operace jako s èísly typu integer. Navíc máme k dispozici operace pro pøevod
na celá èísla odseknutím <span class="trnote"
title="Poznámka&nbsp;pøekladatele" >nebo zaokrouhlením</span> desetinné
èásti.</p>

<p>Python, VBScript i JavaScript práci s reálnımi èísly podporují. V jazyce
Python je vytvoøíme jednoduše tím, e uvedeme zápis èísla, ve kterém se
vyskytuje desetinná teèka &mdash; jak jsme si ukázali v èásti <a
href="cztutseq1.html">Jednoduché posloupnosti</a>. V jazycích VBScript a
JavaScript nejsou celá èísla a reálná èísla <span class="trnote"
title="Poznámka&nbsp;pøekladatele">pøi pouívání</span> jasnì rozlišována.
Jednoduše je pouíváme a pøekladaè jazyka si s tím vìtšinou dobøe
poradí.</p>


<h3>Komplexní nebo imaginární èísla</h3>

<p>Pokud máte základy matematického nebo jiného vìdeckého vzdìlání, pak vás
moná napadlo: A co komplexní èísla? Pokud tyto základy nemáte, moná jste o
komplexních èíslech vùbec neslyšeli. V takovém pøípadì mùete tuto èást
pøeskoèit, protoe vám zde uvedená fakta k nièemu nebudou. Nicménì, nìkteré
programovací jazyky, vèetnì jazyku Python, mají podporu pro typ komplexních
èísel zabudovánu pøímo do jazyka, zatímco k jinım jazykùm se dodávají
knihovny nebo funkce, které práci s komplexními èísly umoòují. A ještì ne
se zeptáte &mdash; toté platí pro matice.</p>

<p>V jazyce Python jsou komplexní èísla reprezentována jako:</p>

<pre>
(<span class="comment">real</span>+<span class="comment">imaginary</span>j)
</pre>

<p><span class="trnote" title="Poznámka&nbsp;pøekladatele">... kde
<code>real</code> pøedstavuje reálnou sloku a <code>imaginary</code> sloku
imaginární.</span></p>

<p>Take sèítání komplexních èísel zapisujeme následovnì:</p>

<pre>
>>> M = (2+4j) 
>>> N = (7+6j)
>>> print M + N 
(9+10j)
</pre>

<p>Všechny operace pouívané pro èísla typu integer je mono pouít i pro
komplexní èísla.</p>

<p>VBScript ani JavaScript práci s komplexními èísly nepodporují.</p>



<h3 id="Boolean">Hodnoty typu Boolean &mdash; True a False</h3>

<p>Tento podivnì vypadající název typu je pojmenován po matematikovi
19.&nbsp;století, George Boolovi, kterı se zabıval studiem logiky. Jak u
nadpis napovídá, tento typ má pouze dvì hodnoty &mdash; <em>true</em>
(pravda) a <em>false</em> (nepravda). Nìkteré jazyky podporují boolovské
hodnoty pøímo, jiné pouívají konvence, kdy vybraná èíselná hodnota (èasto
nula) reprezentuje false a jiná hodnota (èasto 1 nebo -1) reprezentuje true.
Bylo tomu tak i u jazyka Python, a to a do verze 2.2 vèetnì. Od verze 2.3
podporuje Python boolovské hodnoty pøímo &mdash; pouívá hodnoty
<code>True</code> a <code>False</code>.</p>

<p>Boolovské hodnoty jsou známy také jako <em>pravdivostní hodnoty</em>,
protoe vyjadøují skuteènost, zda je nìco pravdivé nebo nepravdivé. Dejme
tomu, e píšete program, kterı má zálohovat všechny soubory v adresáøi.
Mùeme <span class="trnote" title="Poznámka pøekladatele">v cyklu</span>
postupovat tak, e uloíme soubor jednoho jména a potom se operaèního
systému zeptáme, jak se jmenuje další soubor. Pokud u ádnı další soubor
neexistuje <span class="trnote" title="Poznámka pøekladatele">(tj. byly
zpracovány všechny soubory v adresáøi)</span>, vrátí se prázdnı øetìzec.
Vrácené jméno souboru tedy mùete porovnat s hodnotou prázdného øetìzce a
vısledek mùete uloit jako boolovskou hodnotu (pokud je vrácenı øetìzec
prázdnı, uloí se True, pokud ne, uloíme False). Pozdìji si ukáeme, jak
mùeme takto uloenı vısledek pouít.</p>

<table summary="Boolovské operátory">
<caption>Boolovské (nebo také logické) operátory</caption>
<col span="3" style="padding: 0 1em" valign="top">
<tr><th>Zápis</th><th>Jméno operace</th><th>Popis vıznamu</th></tr>
<tr>
<td>A&nbsp;and&nbsp;B</td>
<td>A&nbsp;<small class="trnote">souèasnì</small></td>
<td>True, kdy A i B jsou True. V jiném pøípadì je vısledkem False.</td>
</tr>

<tr>
<td>A&nbsp;or&nbsp;B</td>
<td>NEBO</td>
<td>True kdy oba nebo jeden z A, B jsou True. False, kdy oba A i B
jsou False.</td>
</tr>

<tr>
<td>A == B</td>
<td>ROVNOST</td>
<td>True kdy A je rovno B.</td>
</tr>

<tr>
<td>A&nbsp;!=&nbsp;B<br><small>nebo</small><br>A&nbsp;&lt;&gt;&nbsp;B</td>
<td>NEROVNOST</td>
<td>True kdy A není rovno B.</td>
</tr>

<tr>
<td>not B</td>
<td>NEGACE</td>
<td>True kdy B není True.</td>
</tr>
</table>

<p><b>Poznámka:</b> poslední operace se tıká jedné hodnoty, zatímco
ostatní porovnávají dvì hodnoty.</p> 

<p>Jazyk VBScript, stejnì jako Python, pouívá typ Boolean s hodnotami
<code>True</code> a <code>False</code>. Jazyk JavaScript rovnì pouívá typ
Boolean, ale jeho hodnoty jsou tentokrát pojmenovány <code>true</code> a
<code>false</code> (první písmeno se píše malé).</p>

<p>Rùzné jazyky pouívají pro pojmenování boolovského typu mírnì odlišná
jména. Python mu øíká <em>bool</em>, VBScript a JavaScript <em>Boolean</em>.
Vìtšinou se tím nemusíte vùbec zabıvat, protoe budete spíše pouívat
boolovské vısledky v testech, ne abyste je ukládali do boolovskıch
promìnnıch.</p>


<h3>Kolekce</h3>

<p>Pro studium <em>kolekcí</em> a jejich chování byla v poèítaèové vìdì
vybudována celá disciplína. Nìkdy bıvají kolekce oznaèovány pojmem
<em>kontejnery</em>. V této sekci se nejdøíve podíváme na kolekce, které
podporují jazyky Python, VBScript a JavaScript. Nakonec struènì shrneme, s
jakımi dalšími typy kolekcí se mùeme setkat v jinıch jazycích.</p>


<h4>Seznam</h4>

<p>Seznamy dobøe známe z kadodenního ivota. <p>Seznam <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(anglicky <em>list</em> [list])</span> je
jednoduše tvoøen posloupností poloek. Do seznamu mùeme poloky pøidávat
nebo je mùeme naopak odstraòovat. Pokud máme seznam napsanı na papíru, pak
mùeme stìí vkládat poloky doprostøed. Mùeme je pøidávat pouze na konec.
Ale pokud seznam udrujeme v elektronické podobì, dejme tomu v textovém
editoru, mùeme nové poloky vkládat do libovolného místa seznamu.</p>

<p>V seznamu mùeme také vyhledávat &mdash; pokud chceme zjistit, zda v nìm
nìco u je, nebo ne. V takovém prípadì ale musíme seznam procházet postupnì,
od zaèátku do konce, a kontrolovat, zda se jedná o poloku, kterou hledáme.
Seznamy patøí v mnoha moderních programovacích jazycích k základním typùm s
charakterem kolekce.</p>

<p>V jazyce Python jsou seznamy pøímo jeho souèástí (jsou zabudovány do
jazyka). Mùeme s nimi provádìt všechny základní operace, o kterıch jsme se
zmínili vıše. Navíc mùeme poloky seznamu
zpøístupòovat i prostøednicvím <em>indexu</em>. To znamená, e k prvku
seznamu mùem pøistupovat na základì znalosti jeho poøadového èísla.
(Prvnímu prvku je pøidìleno poøadové èíslo nula.)</p>

<p>V jazyce VBScript neexistují seznamy jako takové, ale jejich vlastnosti
mùeme simulovat jinımi typy kolekcí, o kterıch se zmíníme pozdìji.</p>

<p>V jazyce JavaScript rovnì nemáme pøímo typ seznam, ale témìø ke všemu,
co potøebujete dìlat se seznamem, mùete vyuít jeho typ <em>pole</em>
(array [erey]). Jde o jinı typ kolekce, o kterém se budeme bavit o nìco
pozdìji.</p>


<h4>Operace nad seznamem</h4>

<p>Python definuje nad kolekcemi øadu operací. Témìø všechny z nich lze
aplikovat na seznamy. Èást operací lze aplikovat na další typy kolekcí a
také na øetìzce, které jsou vlastnì jen speciálním pøípadem seznamu &mdash;
jde o&nbsp;<em>seznam znakù</em>. V jazyce Python seznam vytvoøíme a
zpøístupníme pouitím hranatıch závorek. <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(Tímto zápisem seznam
<em>konstruujeme</em>, proto se takto pouité dvojici hranatıch závorek øíká
také <em>konstruktor seznamu</em>.)</span> Pokud pouijeme pouze hranaté
závorky a nic do nich nevepíšeme, vytvoøíme prázdnı seznam. Seznam s
hodnotami vytvoøíme tak, e poadované hodnoty zapíšeme dovnitø závorek a
oddìlíme je èárkami:</p>

<pre>
>>> seznam = []
>>> jinySeznam = [1, 2, 3]
>>> print jinySeznam
[1, 2, 3]
</pre>

<p>K jednotlivım polokám mùeme pøistupovat pomocí indexu, kterı uvedeme v
hranatıch závorkách. První poloka seznamu má pøidìlen index 0 (nula). Pokud
napøíklad chceme zpøístupnit tøetí prvek, pouijeme index 2:</p>

<pre>
>>> print jinySeznam[2]
3
</pre>

<p>Hodnoty poloek seznamu mùeme podobnım zpùsobem i mìnit:</p>

<pre>
>>> jinySeznam[2] = 7
>>> print jinySeznam
[1, 2, 7]
</pre>

<p>Povšimnìte si, e tøetí prvek (index 2) zmìnil svou hodnotu z 3 na 7.</p>

<p>Záporné hodnoty indexového èísla pouíváme pro zpøístupnìní poloek
indexovanıch vùèi konci seznamu. Nejèastìji se pouívá index -1 (mínus
jedna), kterı zajistí zpøístupnìní poslední poloky seznamu:</p>

<pre>
>>> print jinySeznam[-1]
7
</pre>

<p>Operátorem <code>append()</code> mùeme pøidávat nové poloky na konec
seznamu:</p>

<pre>
>>> seznam.append(42)
>>> print seznam
[42]
</pre>

<p>Polokou seznamu mùe bıt dokonce i jinı seznam, take pokud pøipojíme na
konec prvního seznamu náš druhı seznam, dopadne to takto:</p>

<pre>
>>> seznam.append(jinySeznam)
>>> print seznam
[42, [1, 2, 7]]
</pre>

<p>Všimnìte si, e vısledkem je seznam sloenı ze dvou poloek, kde druhou
poloku tvoøí opìt seznam (jak je znázornìno párem okolních hranatıch
závorek). V posledním pøípadì mùeme prvek s hodnotou 7 zpøístupnit pomocí
dvojitého indexu:</p>

<pre>
>>> print seznam[1][2]
7
</pre>

<p>Hodnota prvního indexu (tj. 1) zpøístupní druhou poloku seznamu, která
je vlastnì seznamem. Hodnota druhého indexu (tj. 2) zpøístupní tøetí poloku
zmínìného podseznamu.</p>

<p>Monost vnoøování seznamù jednoho do druhého je velmi uiteèná. Tato
vlastnost nám umoòuje budovat datové tabulky, jako je napøíklad
následující:</p>

<pre>
>>> radek1 = [1, 2, 3]
>>> radek2 = ['a', 'b', 'c']
>>> tabulka = [radek1, radek2]
>>> print tabulka
[[1, 2, 3], ['a', 'b', 'c']]
>>> prvek2 = tabulka[0][1]
</pre>

<p>Tímto zpùsobem si mùeme vybudovat napøíklad adresáø <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(pro ukládání adres lidí)</span>, kde
kadá poloka pøedstavuje seznam se jménem a dalšími detaily adresy.
Následující pøíklad uvádí adresáø s dvìmi polokami:</p>

<pre>
>>> adresy = [
... ['Mirek', 'Kolbenova 15', 'Olomouc', '585 456 231'],
... ['Hanka', 'Ypsilantiho 42', 'Brno', '525 698 444']
... ]
</pre>

<p>Povšimnìte si, e jsme celı zanoøenı seznam vytvoøili zápisem na jednom
øádku <span class="trnote" title="Poznámka&nbsp;pøekladatele">(je zalomen
jen kvùli nedostatku prostoru &mdash; teèky znázoròují pokraèování
øádku)</span>. Python sleduje, zda poèet uzavøenıch závorek odpovídá poètu
otevøenıch. Pokud ne, pokraèuje v naèítání vstupu, a do doby, kdy se poèty
srovnají. Uvedenı zápis pøedstavuje velmi efektivní zpùsob rychlého budování
sloitıch datovıch struktur. Celková struktura &mdash; v tomto pøípadì
seznam seznamù &mdash; pøitom zùstává pro ètenáøe kódu pøehledná.</p>

<p>Cviènì zkuste získat Mirkovo telefonní èíslo &mdash; ètvrtı prvek z
prvního øádku. Uvìdomte si, e indexy zaèínají nulou. Zkuste pøidat nìkolik
svıch záznamù pouitím operace <code>append()</code>, o které jsme se
zmiòovali vıše.</p>

<p>Jakmile Python ukonèíte, vaše data budou ztracena. A se budeme bavit
o&nbsp;souborech, zjistíte, jak mùete data <span class="trnote"
title="Poznámka&nbsp;pøekladatele">ze seznamu</span> uloit pro další
pouití.</p>

<p>Opaènou operací k pøidávání poloky je, samozøejmì, rušení poloky.
Provedeme ji pøíkazem <code>del</code>:</p>

<pre>
>>> del seznam[1]
>>> print seznam
[42]
</pre>

<p>Pokud chceme spojit dva seznamy do jednoho, mùeme pouít stejnı operátor
pro zøetìzení '<code>+</code>', kterı jsme ji pouili døíve pro
øetìzce:</p>

<pre>
>>> print seznam
[42]
>>> print jinySeznam
[1, 2, 7]
>>> novySeznam = seznam + jinySeznam
>>> print novySeznam
[42, 1, 2, 7]
</pre>

<p>Povšimnìte si, e se vısledek tentokrát liší od døíve uvedeného pøíkladu,
kdy jsme spojovali dva seznamy operací <code>append()</code>. Tehdy jsme
dostali seznam s dvìmi prvky, pøièem druhım prvkem byl <span class="trnote"
title="Poznámka&nbsp;pøekladatele">pøipojovanı</span> seznam. V tomto
pøípadì dostáváme seznam s ètyømi prvky, protoe do nového seznamu byly
vloeny prvky z obou spojovanıch seznamù &mdash; kadı prvek samostatnì.
Pokud v tomto pøípadì pøistupujeme k prvku <span class="trnote"
title="Poznámka&nbsp;pøekladatele">s indexem</span>&nbsp;1, nedostaneme se
tentokrát k podseznamu, jak tomu bylo v pøedchozím pøípadì, ale pouze k
prvku <span class="trnote" title="Poznámka&nbsp;pøekladatele">s
hodnotou</span> <code>1</code>:</p>

<pre>
>>> print novySeznam[1]
1
</pre>

<p>Pro naplnìní seznamu více polokami se stejnou hodnotou mùeme vyuít
operátoru pro opakování &mdash; zápis se podobá násobení:</p>

<pre>
>>> seznamNul = [0] * 5
>>> print seznamNul
[0, 0, 0, 0, 0]
</pre>

<p>Pro prvek seznamu s urèitou hodnotou mùeme nalézt jeho index operací
<code>index()</code>:</p>

<pre>
>>> print [1,3,5,7].index(5)
2
>>> print [1,3,5,7].index(9)
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in ?
ValueError: list.index(x): x not in list
</pre>

<p>Povšimnìte si, e pokus o nalezení nìèeho, co není prvkem seznamu, má za
následek chybu. V dalších èástech uèebnice si ukáeme zpùsoby, jak lze
zjistit, zda se nìco v seznamu nachází, èi nikoliv.</p>


<p>Délku seznamu <span class="trnote" title="Poznámka&nbsp;pøekladatele"
>(poèet jeho poloek)</span> mùeme zjistit voláním zabudované funkce
<code>len()</code>:</p>

<pre>
>>> print len(seznam)
1
>>> print len(novySeznam)
4
>>> print len(seznamNul)
5
</pre>

<p>Ani JavaScript ani VBScript typ seznam pøímo nepodporují. Ale o kousek
dál si ukáeme, e podporují typ <code>Array</code> <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(pole)</span>, se kterım lze napodobit
funkènost pythonovskıch seznamù.</p>


<h4>N-tice</h4>

<p>Typ n-tice <span class="trnote" title="Poznámka pøekladatele">(anglicky
<em>tuple</em>)</span> není øadou jazykù vùbec podporován. Ale v tìch
jazycích, kde jsou n-tice podporovány, se ukazuje, e je to velmi uiteènı
rys. N-tice je ve skuteènosti jen libovolná <span class="trnote"
title="Poznámka&nbsp;pøekladatele">uspoøádaná</span> kolekce hodnot, se
kterou mùeme zacházet jako s jedním celkem. V mnoha ohledech se n-tice
podobá seznamu, ale jeden vıznamnı rozdíl spoèívá v tom, e n-tice jsou
<em>nemìnné</em> <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(anglicky <em>immutable</em>)</span>. To
znamená, e jakmile je jednou n-tice vytvoøena, nelze ji mìnit (tj. nelze
mìnit, pøidávat nebo rušit jednotlivé poloky n-tice). V jazyce Python se
n-tice zapisují jako posloupnost hodnot oddìlenıch èárkami, která je
uzavøená v kulatıch závorkách &mdash; takto:</p>

<pre>
>>> ntice = (1, 3, 5)
>>> print ntice[1] <span class="comment"># zpøístupníme poloku indexem, jako u seznamu</span>
3
>>> ntice[2] = 7   <span class="comment"># chyba: poloku n-tice nelze mìnit</span>
Traceback (most recent call last):
  File "", line 1, in ?
    ntice[2] = 7
TypeError: object doesn't support item assignment
           <span class="trnote" title="Poznámka pøekladatele">objekt nepodporuje pøiøazování hodnot do poloek</span>
</pre>

<p>Zapamatujme si hlavnì to, e kulaté závorky pouíváme pøi vytváøení
n-tice, e hranaté závorky se pouívají pro uvedení indexu pøi pøístupu
k&nbsp;jejím polokám a e jednou vytvoøenou n-tici nelze pozdìji mìnit.
V&nbsp;ostatních pøípadech lze na n-tice aplikovat vìtšinu operací, které se
pouívají pro seznamy.</p>

<p>Aèkoliv n-tici nemùeme mìnit, mùeme operátorem pro sèítání (plus)
jakoby pøidat další èleny. Ve skuteènosti se tím toti vytvoøí nová
n-tice:</p>

<pre>
>>> ntice1 = (1, 2, 3)
>>> ntice2 = ntice1 + (4,) <span class="comment"># èárka zpùsobí, e se zápis chápe jako n-tice a ne jako èíslo</span>
>>> print ntice2
(1, 2, 3, 4)
</pre>

<p>Pokud bychom za èíslem 4 neuvedli èárku, Python by to chápal jako zápis
celého èísla uzavøeného v závorkách a ne jako zápis n-tice. Ale protoe
k n-ticím nelze pøièítat èísla, vedlo by to k chybì. Pøidáním èárky Pythonu
øíkáme, aby zápis v závorkách chápal jako zápis n-tice. Kdykoliv budete
chtít Pythonu dát najevo, e jednoprvková n-tice skuteènì <em>je</em> n-ticí,
pøidejte k zápisu èárku stejnì, jako jsme to udìlali zde.</p>

<p>VBScript ani JavaScript koncept n-tic nepodporují.</p>

 
<h4 id="dictionary">Slovník (vyhledávací tabulka)</h4>

<p>V tištìném slovníku je k jednotlivım slovùm uveden jejich vıznam. Podobnì
je tomu i u datového typu slovník <span class="trnote" title="Poznámka
pøekladatele">(anglicky <em>dictionary</em> [dykšnri])</span>, kde jsou k
jednotlivım klíèùm pøidrueny hodnoty. Pøitom hodnoty mohou, ale nemusí, mít
podobu øetìzce. Hodnotu mùeme získat tím, e klíè pouijeme pro slovník
jako <em>index</em>. Narozdíl od tištìného slovníku, ani klíè nemusí bıt
znakovım øetìzcem &mdash; aèkoliv øetìzec se èasto pouívá. Mùe to bıt
hodnota libovolného nemìnného typu <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(immutable)</span>, vèetnì èísel a n-tic.
Hodnota, která je s klíèem svázaná, mùe bıt libovolného datového typu
jazyka Python. Slovníky jsou obvykle implementovány s vyuitím programovací
techniky známé jako <em>hash table</em><sup class="trnote" id="Bdata_hash"
title="Poznámka k pøekladu pojmu hash table" ><a
href="cztuttrn.html#Pdata_hash">[5]</a></sup> <span class="trnote"
title="Poznámka pøekladatele">[heš tejbl]</span>. Z tohoto dùvodu se pro
datovı typ slovník obèas pouívá zkrácenı pojem <em>hash</em>. <span
class="trnote" title="Poznámka pøekladatele">V èeské terminologii se spíše
vyuívá druhá èást úplného pojmu, tedy tabulka</span>. Nemá to nic
spoleèného s drogami. :-)</p>

<a name="addressbook"></a>

<p>K hodnotám ve slovníku mùeme pøistupovat pouze prostøednictvím klíèe,
take do slovníku mùeme vloit pouze prvky s jednoznaènım klíèem <span
class="trnote" title="Poznámka pøekladatele">(pro jeden klíè nelze souèasnì
uchovávat dvì hodnoty)</span>. Slovníky jsou velmi uiteènımi strukturami.
Python je poskytuje jako zabudovanı typ, aèkoliv v mnoha dalších jazycích
musíte pouít odpovídající modul nebo si dokonce musíte typ slovník
naprogramovat sami. Slovníky mùeme pouívat mnoha zpùsoby a pozdìji si
ještì ukáeme øadu pøíkladù. V tomto okamiku si ukame alespoò to, jak v
jazyce Python slovník vytvoøíme, jak do nìj vloíme nìkteré poloky a jak je
opìt zpøístupníme (pøeèteme):</p>

<pre>
>>> dct = {}
>>> dct['boolean'] = "Hodnota, která je buï True nebo False"
>>> dct['integer'] = "Celé èíslo"
>>> print dct['boolean']
Hodnota, která je buï True nebo False
</pre>

<p>Všimnìte si, e poèáteèní hodnotu slovníku nastavíme pomocí sloenıch
závorek <span class="trnote" title="Poznámka pøekladatele">(zde prázdnı
slovník &mdash; sloené závorky jsou konstruktorem slovníku tak, jako jsou
hranaté závorky konstruktorem seznamu nebo kulaté závorky konstruktorem
n-tice)</span>. Poté pouíváme hranaté závorky pro pøiøazování a ètení
hodnot.</p>

<p>Slovník mùeme naplnit poèáteèními hodnotami v okamiku jeho vytvoøení
podobnì, jako jsme si to ukázali u seznamù:</p>

<pre>
>>> adresy = {
... 'Mirek' : ['Mirek', 'Kolbenova 15', 'Olomouc', '585 456 231'],
... 'Hanka' : ['Hanka', 'Ypsilantiho 42', 'Brno', '525 698 444']
... }
</pre>

<p>Klíè a hodnota se od sebe oddìlují dvojteèkou a tyto páry se od dalších
oddìlují èárkou. Tentokrát jsme náš adresáø vytvoøili jako slovník, kde jsme
jako klíè pouili jméno a jako slovníkovou hodnotu ukládáme pùvodní seznamy
s hodnotami. Místo zjišování a pouívání èíselného indexu nyní mùeme
potøebné informace získat na základì jména, a to takto:</p>

<pre>
>>> print adresy['Hanka']
['Hanka', 'Ypsilantiho 42', 'Brno', '525 698 444']
>>> print adresy['Mirek'][3]
585 456 231
</pre>

<p>V druhém pøípadì jsme vrácenı seznam dále indexovali, abychom obdreli
jen telefonní èíslo. Práci si mùeme dále zjednodušit zavedením pomocnıch
promìnnıch, které naplníme pøíslušnımi hodnotami indexù:</p>

<pre>
>>> jmeno = 0
>>> ulice = 1
>>> mesto = 2
>>> tel = 3
</pre>

<p>Pokud nyní chceme zjistit, ve kterém mìstì bydlí Hanka, mùeme napsat:</p>

<pre>
>>> print adresy['Hanka'][mesto]
Brno
</pre>

<p>Povšimnìte si, e zatímco jméno <code>'Hanka'</code> uvádíme v
apostrofech, protoe jde o klíè typu øetìzec, zápis <code>mesto</code>
uvádíme bez apostrofù, protoe jde o jméno promìnné, které Python pøevede na
hodnotu indexu, kterou jsme do ní uloili (konkrétnì 2). V tomto okamiku
zaèíná náš adresáø pøipomínat pouitelnou databázovou aplikaci. Mùeme za to
podìkovat síle <span class="trnote"
title="Poznámka&nbsp;pøekladatele">datového typu</span> slovník. Moc práce
nám nedá ani doplnìní kódu pro ukládání a naèítání dat a pøidání
dotazovacího øádku, pøes kterı budeme moci urèit, jaká data poadujeme. Pøi
probírání dalších témat této uèebnice si to ukáeme.</p>

<p>Øada operací nad kolekcemi, se kterımi jsme se do této chvíle seznámili,
není u slovníkù &mdash; vzhledem k jejich vnitøní struktuøe &mdash;
podporována. Nefunguje zde ani operátor zøetìzení, operátor opakování, ani
operace <code>append()</code>. Abychom si mohli zpøístupnit hodnoty <span
class="trnote" title="Poznámka&nbsp;pøekladatele">všech</span> klíèù, máme k
dispozici operaci <code>keys()</code>. Ta vrací seznam všech klíèù, které
seznam pouívá. Pokud napøíklad chceme získat seznam všech jmen z našeho
adresáøe, mùeme napsat:</p>

<pre>
>>> print adresy.keys()
['Hanka', 'Mirek']
</pre>

<p>Zde musíme upozornit na to, e klíèe nejsou ve slovníku uloeny v poøadí,
v jakém byly vkládány. Z tohoto dùvodu se vám mùe zdát, e se objevují v
nìjakém divném poøadí, které se dokonce mùe bìhem pouívání slovníku mìnit.
Nedìlejte si s tím starosti. Nic to nemìní na skuteènosti, e
prostøednictvím klíèù mùete pøistupovat k vašim datùm. Vdy korektnì
obdríte tu správnou hodnotu.</p>


<h4>Slovníky ve VBScript</h4>

<p>V jazyce VBScript máme k dispozici objekt typu slovník, kterı má podobné
vlastnosti, jako slovník v jazyce Python, ale pouívá se trochu jinak.
Nejdøíve musíme deklarovat promìnnou, která bude objekt zpøístupòovat. Poté
vytvoøíme vlastní objekt typu slovník a nakonec do nìj pøidáme poloky:</p>

<pre>
Dim dict               <span class="comment">' Vytvoøíme promìnnou.</span>
Set dict = CreateObject("Scripting.Dictionary")
dict.Add "a", "Athens" <span class="comment">' Pøidáme nìjaké poloky.</span>
dict.Add "b", "Belgrade"
dict.Add "c", "Cairo"
</pre>

<p>Povšimnìte si, e ve funkci <code>CreateObject()</code> <span
class="trnote" title="Poznámka&nbsp;pøekladatele" >(tj. <em>vytvoø
objekt</em>)</span> uvádíme, e chceme vytvoøit objekt
<code>"Scripting.Dictionary"</code>. To znamená, e chceme vytvoøit objekt
<code>Dictionary</code> <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(slovník)</span>, kterı je pro interpret
VBScript definován v modulu <code>Scripting</code>. Podrobnostmi se zatím
nebudeme zatìovat. Dostaneme se k nim pozdìji, a se budeme zabıvat
objekty. Doufám, e se vám alespoò vybavuje koncepce pouívání objektù
definovanıch v modulech &mdash; zmínili jsme se o ní v podkapitole <a
href="cztutseq1.html">Jednoduché posloupnosti</a>. Povšimnìte si také, e
pøi pøiøazování objektu do promìnné musíme v jazyce VBScript pouít klíèové
slovo <code>Set</code> <span class="trnote"
title="Poznámka&nbsp;pøekladatele">([set] = nastavit)</span>.</p>

<p>Nyní mùeme k datùm pøistupovat takto:</p>

<pre>
item = dict.Item("c")         <span class="comment">' Získání hodnoty poloky.</span>
dict.Item("c") = "Casablanca" <span class="comment">' Zmìna hodnoty poloky.</span>
</pre>

<p>Kromì toho máme k dispozici i operace k odstranìní poloky, k získání
seznamu všech klíèù, k otestování existence klíèe a podobnì.</p>

<p>Následující pøíklad pøedstavuje úplnou (i kdy trochu zjednodušenou)
podobu našeho adresáøe, zapsaného v jazyce VBScript:</p>

<pre>
&lt;script type="text/vbscript">
Dim adresy
Set adresy = CreateObject("Scripting.Dictionary")
adresy.Add "Mirek", "Mirek, Kolbenova 15, Olomouc, 585 456 231" 
adresy.Add "Hanka", "Hanka, Ypsilantiho 42, Brno, 525 698 444"

MsgBox adresy.Item("Hanka")
&lt;/script>
</pre>

<p>Pro uchovávání informací tentokrát místo seznamu pouíváme jedinı
øetìzec. Na ukázku zpøístupòujeme data záznamu s klíèem <code>Hanka</code> a
zobrazujeme je v dialogovém oknì.</p>

<h4>Slovníky v JavaScript</h4>

<p>JavaScript nemá k dispozici svùj datovı typ slovník. Pokud ovšem
pouíváte prohlíeè Internet Explorer, mùete pouít objekt typu
<code>Scripting.Dictionary</code>, kterı je souèástí VBScript. Bavili jsme
se o nìm v pøedešlém textu. <span class="trnote"
title="Poznámka&nbsp;pøekladatele">I pøi pouití z JavaScript</span> má
naprosto stejné vlastnosti. Je to tentı typ objektu a proto se jím zde
nebudeme dále zabıvat. Místo slovníkù mùeme v JavaScript vyuít podobnım
zpùsobem typ pole &mdash; viz níe.</p>


<blockquote><i>Pokud u toho zaèínáte mít plné zuby, mùete v tomto místì
pøejít k&nbsp;<a href="cztutseq2.html">další kapitole</a>. Jakmile se zaènete
setkávat s datovımi typy o kterıch jsme se ještì nezmínili, nezapomeòte se
vrátit zpìt k této kapitole a doèíst si ji.</i></blockquote> 


<h3>Další typy kolekcí</h3>

<h4>Pole nebo vektor</h4>

<p>Z hlediska historie poèítaèù patøí pole k jednomu z prvních typù kolekcí.
V podstatì se jedná o seznam prvkù, ke kterım lze snadno a rychle
pøistupovat na základì indexu. Obvykle musíme pøedem urèit, kolik prvkù má
pole uchovávat. A právì pevná velikost je tím rysem, kterı se pole liší od
seznamu, o nìm byla øeè vıše. V Pythonu máme typ pole k dispozici
prostøednictvím modulu <code>array</code>. Pouívá se však velmi zøídka,
protoe místo nìj mùeme obvykle pouít vestavìnı typ seznam.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> Modul <code>array</code>
umoòuje v Pythonu definovat pole pouze pro prvky základních typù a to znak,
celé èíslo a reálné èíslo. Pro jeho pouití se rozhodneme pravdìpodobnì jen
v pøípadì, kdy nám velmi záleí na efektivnosti pouití ve smyslu
vıkonnìjšího kódu.</p>

<p>V jazycích VBScript i JavaScript jsou pole k dispozici v podobì datového
typu. Podívejme se, jak se pouívají.</p>


<h4>Pole v jazyce VBScript</h4>

<p>V jazyce VBScript mají pole podobu kolekce dat s pevnou délkou. K prvkùm
se pøistupuje pøes èíselnı index. Deklarace a pøístup k prvkùm se zapisují
takto:</p>

<pre>
Dim pole(42)       <span class="comment">' Pole s 43 prvky.</span>
pole(0) = 27       <span class="comment">' Indexovat se zaèíná od nuly.</span>
pole(1) = 49
promenna = pole(1) <span class="comment">' Ètení hodnoty.</span>
</pre>

<p>Povšimnìte si, e pouíváme klíèové slovo <code>Dim</code>, které
vyjadøuje, e promìnné bude pøidìlen pamìovı prostor. Tímto zpùsobem
interpretu VBScript øekneme, e chceme pracovat s uvedenou promìnnou. Pokud
na zaèátku skriptu uvedeme <code>OPTION&nbsp;EXPLICIT</code>, pak bude
VBScript vyadovat, abychom klíèovım slovem <code>Dim</code> uvedli kadou
promìnnou, kterou budeme chtít pouívat. Øada odborníkù pøes programování
pokládá tento pøístup za ádoucí, protoe vìøí, e vede k tvorbì
spolehlivìjších programù. Povšimnìte si také, e v deklaraci uvádíme hodnotu
posledního platného indexu &mdash; v našem pøípadì <code>42</code>.
Indexovat se zaèíná od nuly, take to znamená, e deklarujeme pole o&nbsp;43
prvcích.</p>

<p>Povšimnìte si také, e u jazyka VBScript pouíváme pro deklaraci rozmìru
pole a pro indexování kulaté závorky, nikoliv hranaté závorky, jak je tomu
u&nbsp;jazyka Python (viz dále), JavaScript <span class="trnote"
title="Poznámka&nbsp;pøekladatele">a u øady dalších programovacích
jazykù</span>.</p>

<p>Deklarovat mùeme i vícerozmìrná pole &mdash; modelujeme datovou tabulku.
Podobnı efekt jsme si ukázali v pøípadì pythonovskıch seznamù. Pro náš
pøíklad adresáøe bychom mohli psát:</p>

<pre>
Dim MojeTabulka(2, 3)              <span class="comment">' 3 øádky, 4 sloupce</span>
MojeTabulka(0,0) = "Mirek"         <span class="comment">' Naplníme poloky pro Mirka.</span>
MojeTabulka(0,1) = "Kolbenova 15"
MojeTabulka(0,2) = "Olomouc"
MojeTabulka(0,3) = "585 456 231"
MojeTabulka(1,0) = "Hanka"         <span class="comment">' Naplníme poloky pro Hanku.</span>
... a tak dále...
</pre>

<p>Bohuel však neexistuje zpùsob, jak bychom mohli pøedepsat naplnìní
tabulky daty najednou &mdash; jak jsme to ukázali u pythonovskıch seznamù.
Poloky tabulky musíme plnit jednu po druhé. Pokud zkombinujeme vlastnosti
polí a slovníkù, dosáhneme pro verzi ve VBScript stejnıch uitkovıch
vlastností, jako tomu bylo u pythonovské verze:</p>

<pre>
&lt;script type="text/vbscript">
Dim adresy
Set adresy = CreateObject("Scripting.Dictionary")
Dim Mirek(3)
Mirek(0) = "Mirek"
Mirek(1) = "Kolbenova 15"
Mirek(2) = "Olomouc"
Mirek(3) = "585 456 231"
adresy.Add "Mirek", Mirek

MsgBox adresy.Item("Mirek")(3) <span class="comment">' Vytiskneme telefonní èíslo.</Span>
&lt;/script>
</pre>

<p>Poslední vìc, o které bych se chtìl zmínit, je skuteènost, e pole v
jazyce VBScript nemusí mít vùbec pevnou velikost. To ovšem neznamená, e si
mùeme dovolit jednoduše pøidávat prvky zpùsobem, jak jsme to dìlali u
seznamù. Zmìnu rozmìrù pole musíme pøedepsat pøíkazem. Abychom to mohli
udìlat, musíme pole deklarovat jako <em>dynamické pole</em>. Dosáhneme toho
jednoduše tím, e neuvedeme jeho rozmìr:</p>

<pre>
&lt;script type="text/vbscript">
Dim DynPole()
ReDim DynPole(5)  <span class="comment">' Poèáteèní velikost.</span>
DynPole(0) = 42
DynPole(4) = 26
MsgBox "Pøed: " &amp; DynPole(4) <span class="comment">' Dokame, e to funguje.</span>

<span class="comment">' Rozmìr pole zmìníme na 21 prvkù pøi zachování stávajících dat.</span>
ReDim Preserve DynPole(20)
DynPole(15) = 73
MsgBox "Po: " &amp; DynPole(4)   <span class="comment">' Hodnota byla zachována.</span>

<span class="comment">' Opìt zmìníme rozmìr (51 prvkù), ale dojde ke ztrátì dat.</span>
ReDim DynPole(50)
MsgBox "A ještì... " &amp; DynPole(4) &amp; " Kam se podìla data?"
&lt;/script>
</pre>

<p>Z pøíkladu je zøejmé, e pouití dynamického pole není tak pøíjemné, jako
pouití seznamu, kterı automaticky pøizpùsobuje svou délku. Na druhou stranu
má ale programátor k dispozici více prostøedkù pro jemné ovládání chování
programu. Uvedená úroveò kontroly nad chováním programu mùe mimo jiné
zvıšit bezpeènost, protoe napøíklad nìkteré viry mohou datové struktury s
dynamicky mìnitelnou velikostí zneuít.</p>


<h4>Pole v jazyce JavaScript</h4>

<p>Typem <em>pole</em> (<code>Array</code>) je v jazyce JavaScript z mnoha
pohledù vyjádøeno nìco jiného, ne co bychom typicky èekali. To, èemu se zde
øíká pole, ve skuteènosti vykazuje podivnou smìsici vlastností seznamù,
slovníkù a klasickıch polí. V nejjednodušším pøípadì mùeme pole
10&nbsp;prvkù nìjakého typu deklarovat takto:</p>

<pre>
var pole = new Array(10);
</pre>

<p>Prvky poté mùeme naplnit a zpøístupòovat takto:</p>

<pre>
pole[4] = 42;
pole[7] = 21;
var hodnota = pole[4];
</pre>

<p>Ale typ hodnoty není u prvkù pole v JavaScript omezen pouze na jedinı. Do
kadého z prvkù pole mùeme pøiøadit cokoliv:</p>

<pre>
pole[9] = "Krátkı øetìzec.";
var zprava = pole[9];
</pre>

<p>Pøi vytváøení pole mùeme zadat dokonce seznam poloek:</p>

<pre>
var jinePole = new Array("jedna", "dvì", "tøi", 4, 5, 6);
hodnota = jinePole[3];
zprava = jinePole[0];
</pre>

<p>K dalším rysùm polí v jazyce JavaScript patøí to, e mùeme zjistit jejich
délku <span class="trnote" title="Poznámka&nbsp;pøekladatele">(poèet
prvkù)</span> pouitím skryté vlastnosti nazvané <code>length</code> <span
class="trnote" title="Poznámka&nbsp;pøekladatele">(tj. délka)</span>:</p>

<pre>
var velikost = pole.length
</pre>

<p>Všimnìte si, formát zápisu <code>jméno.vlastnost</code> pøipomíná volání
funkce z pythonovského modulu, ale bez závorek.</p>

<p>Jak je obvyklé <span class="trnote" title="Poznámka&nbsp;pøekladatele">i
v jinıch jazycích</span>, pole se v JavaScript indexují od nuly. Nicménì v
roli indexu nemusí u JavaScript vystupovat jen èíslo. Mùeme pouít i
øetìzec! V takovém pøípadì se vlastnosti polí témìø shodují s vlastnostmi
slovníkù. Pole mùeme zvìtšit jednoduše tím, e pøiøadíme nìjakou hodnotu
prvku s indexem, kterı pøesahuje aktuální maximální index. Následující
kousky kódu zmínìné vlastnosti ilustrují:</p>

<pre>
pole[42] = 7;
jinePole["nìco"] = 42;
zprava = jinePole["nìco"]; 
</pre>

<p>A nakonec se podívejme, jak by pøi vyuití polí v JavaScript vypadal náš
pøíklad adresáøe:</p>

<pre>
&lt;script type="text/javascript">
var adresy = new Array();
adresy["Mirek"] = "Mirek, Kolbenova 15, Olomouc, 585 456 231"; 
adresy["Hanka"] = "Hanka, Ypsilantiho 42, Brno, 525 698 444";

document.write(adresy.Hanka);
&lt;/script>
</pre>

<p>Povšimnìte si, e <span class="trnote"
title="Poznámka&nbsp;pøekladatele">v posledním pøíkazu</span> se ke klíèi
chováme, jako kdyby to byla vlastnost objektu &mdash; podobnì jako k vıše
zmínìné vlastnosti <code>length</code>.</p>


<h4>Zásobník</h4>

<p>O zásobníku <span class="trnote" title="Poznámka pøekladatele">(anglicky
<em>stack</em> [stek])</span> mùeme uvaovat jako o na sobì naskládanıch
podnosech v <span class="trnote" title="Poznámka
pøekladatele">samoobsluné</span> restauraci. Zamìstnanec restaurace pøidává
èisté podnosy na vrchol sloupce podnosù a zákazníci je jeden po druhém z
vrcholu zase odebírají. Podnosy ve spodní èásti zásobníku se pouívají jako
poslední (a také nejménì). Datovı zásobník se chová stejnì: kadou poloku
buï do zásobníku vloíme <span class="trnote" title="Poznámka
pøekladatele">(operace se oznaèuje <code>push</code> [puš])</span> nebo ji
ze zásobníku vybereme <span class="trnote" title="Poznámka
pøekladatele">(<code>pop</code>)</span>. Vybírá se vdy ta poloka, která
byla do zásobníku vloena jako poslední. Tato vlastnost zásobníku je nìkdy
oznaèována jako <em>Last In First Out</em> <span class="trnote"
title="Poznámka pøekladatele">(poslední dovnitø, první ven)</span> nebo
<em>LIFO</em>. Jednou z uiteènıch vlastností zásobníku je to, e jej mùeme
vyuít k obrácení poøadí poloek seznamu tím, e jednotlivé poloky seznamu
postupnì vloíme do zásobníku a poté je postupnì vybíráme z vrcholu
zásobníku a vkládáme do seznamu. Vısledkem bude poèáteèní seznam s obrácenım
poøadím poloek.</p>

<p>Typ zásobník není vestavìnım typem jazykù Python, VBScript ani
JavaScript. Jeho chování musíme vyjádøit v kódu programu. Nejvhodnìjší bıvá
obvykle vyjít z typu seznam, protoe &mdash; jako v pøípadì zásobníku
&mdash; poèet poloek seznamu mùe narùstat podle potøeby.</p>

<div class="trnote" id="noteStack">

<p><b>Poznámka pøekladatele k zásobníku:</b> Pokud pouijeme seznam v roli
zásobníku, pak jeho metoda <code>append()</code> realizuje stejnou funkènost
jako operace <code>push()</code>. Kromì toho Python pro seznam (ale i pro
další struktury) definuje metodu <code>pop()</code> s typickım vıznamem.
Pokud nám vadí, e nemáme k dispozici pøímo metodu <code>push()</code>, ale
staèí nám zavedení <em>nìjakého</em> zásobníku a vlastních funkcí
<code>push()</code> a <code>pop()</code>, které pracují právì a jen s tímto
zásobníkem, není to ani tak sloité &mdash; viz následující ukázka:</p>

<pre>
>>> zasobnik = []
>>> push = zasobnik.append
>>> pop = zasobnik.pop
>>> push
&lt;built-in method append of list object at 0x009C5B70>
>>> pop
&lt;built-in method pop of list object at 0x009C5B70>
>>> push(1)
>>> push(2)
>>> push(3)
>>> zasobnik
[1, 2, 3]
>>> print pop()
3
>>> zasobnik
[1, 2]
>>> pop()
2
>>> pop()
1
>>> zasobnik
[]
>>> pop()

Traceback (most recent call last):
  File "&lt;pyshell#13>", line 1, in -toplevel-
    pop()
IndexError: pop from empty list
>>>
</pre>

<p>Na prvním øádku vytvoøíme prázdnı seznam a na dalších dvou øádcích
naváeme jména <code>push</code> a <code>pop</code> na pøíslušnı kód objektu
<code>zasobnik</code> (viz vıpis na dalších øádcích). Pokud potom napíšeme
<code>push(1)</code>, provede se naprosto stejná èinnost, jako kdybychom
provedli <code>zasobnik.append(1)</code>. Povšimnìte si také, e pokus
o <code>pop()</code> nad prázdnım zásobníkem nelze tolerovat &mdash; je
vyvolána vıjimka.</p>

<p>Jakmile se nauèíte pracovat s tøídami a objekty, zjistíte, e není
obtíné vytvoøit pro zásobník vlastní tøídu, která bude zveøejòovat jen
poadované operace <code>push()</code> a <code>pop()</code>, pøípadnì další,
dle vaší volby. Pokud se vám nastínìné, èistì objektové øešení zdá pøi
vašich momentálních schopnostech a dovednostech nedostiné, <em>nepropadejte
panice</em>. Je to naprosto normální.</p>

</div>

<h4>Multimnoina</h4>

<p>Multimnoina <span class="trnote" title="Poznámka pøekladatele">(anglicky
<em>bag</em>)</span> pøedstavuje kolekci poloek, u kterıch není definováno
poøadí a která mùe obsahovat více poloek se stejnou hodnotou. Tento datovı
typ obvykle poskytuje operace pro pøidávání, vyhledávání a odstraòování
poloek. V našich jazycích se pro tento úèel pouívají seznamy.</p>


<h4>Mnoina</h4>

<p>Mnoina <span class="trnote" title="Poznámka pøekladatele">(anglicky
<em>set</em>)</span> mùe uchovávat pouze jeden vıskyt kadé poloky.
Obvykle mùeme testovat, zda daná poloka je èi není prvkem mnoiny. Poloky
mùeme do mnoiny pøidávat a odstraòovat. Dvì mnoiny mùeme spojovat
dohromady rùznımi zpùsoby, které známe z matematické teorie mnoin (jako je
napøíklad sjednocení, prùnik, atd.). Jazyky VBScript a JavaScript datovı typ
mnoiny pøímo nepodporují, ale vlastnosti mnoin mùeme docela snadno
napodobit pouitím slovníkù.</p>

<p>V jazyce Python jsou od verze 2.3 mnoiny dostupné v podobì modulu
<code>sets</code>. Jeho implementace se povauje za experimentální. Od verze
2.4 se podpora mnoin stane souèástí jádra jazyka. <span
class="trnote">Poznámka&nbsp;pøekladatele: Zabudování do jádra jazyka bylo
potvrzeno pøi vydání alfa verze Python 2.4. Mnoiny jsou implementovány v
jazyce C, take budou efektivnìjší, ne v Python 2.3.</span></p>

<p>Základní pouití mnoin (Python 2.3) vypadá nìjak takto:</p>

<pre>
>>> import sets
>>> A = sets.Set()        <span class="comment"># Vytvoø prázdnou mnoinu.</span>
>>> B = sets.Set([1,2,3]) <span class="comment"># Vytvo 3prvkovou mnoinu.</span>
>>> C = sets.Set([3,4,5])
>>> D = sets.Set([6,7,8])
>>> <span class="comment"># Teï si vyzkoušíme nìjaké operace.</span>
>>> B.union(C)                     <span class="comment"># sjednocení</span>
Set([1,2,3,4,5])
>>> B.intersection(C)              <span class="comment"># prùnik</span> 
Set([3])
>>> B.issuperset(sets.Set([2]))    <span class="comment"># je nadmnoinou</span>
True
>>> sets.Set([3]).issubset(C)      <span class="comment"># je podmnoinou</span>
True
>>> C.intersection(D) == A         <span class="comment"># rovnost mnoin</span>
True
</pre>

<p>Vıèet mnoinovıch operací je mnohem širší, ale pro tento okamik povauji
vıše uvedené za dostaèující.</p>


<h4>Fronta</h4>

<p>Fronta <span class="trnote" title="Poznámka pøekladatele">(anglicky
<em>queue</em> [kjú])</span> se podobá zásobníku ale s tím rozdílem, e
první poloka, která se dostane dovnitø, je zároveò první polokou, která se
dostane ven. Tomuto chování se øíká <em>First In First Out</em> <span
class="trnote" title="Poznámka pøekladatele">(první dovnitø, první
ven)</span> nebo <em>FIFO</em>. K implementaci fronty se obvykle vyuívá
pole nebo seznam.</p>

<p>Existuje celá øada dalších datovıch typù s vlastnostmi kolekce, ale ty, o
kterıch jsme se zmínili, patøí mezi hlavní, se kterımi se pravdìpodobnì
setkáte. (V této uèebnici se ve skuteènosti budeme zabıvat jen nìkterımi z
vıše zmínìnıch, ale o dalších typech se mùete dozvìdìt v rùznıch èláncích a
v diskusních skupinách vìnovanıch programování.)</p>

<p class="trnote" id="noteQueue"><b>Poznámka pøekladatele k frontì:</b>
Podobnì, jako v pøípadì zásobníku, mùeme i frontu v jazyce Python jednoduše
implementovat s vyuitím operací nad seznamem. Pro operaci zaøazení do
fronty opìt pouijeme metodu <code>append()</code> (této operaci se nìkdy
øíká <code>queueUp()</code> nebo <code>pushBack()</code>). Pro operaci
vıbìru ze zaèátku fronty mùeme pouít <code>pop(0)</code>. Parametr øíká, z
kterého místa prvek odstraòujeme. V pøípadì zásobníku jsme parametr
nezadávali, take se pouila jeho implicitní hodnota <code>-1</code> s
vıznamem <em>index posledního prvku</em>.</p>


<h3>Soubory</h3>

<p>Jako uivatelùm poèítaèe by vám pojem soubor mìl bıt dobøe známı, protoe
soubory tvoøí základ pro témìø vše, co s poèítaèi dìláme. Zjištìní, e
vìtšina programovacích jazykù poskytuje speciální datovı typ <em>file</em>
<span class="trnote" title="Poznámka pøekladatele">(soubor)</span>, by vás
tedy nemìlo pøekvapit. Soubory a jejich zpracování jsou natolik dùleité, e
se jimi budeme zabıvat a o nìco pozdìji, v samostatné kapitole <span
class="trnote" title="Poznámka&nbsp;pøekladatele">(<a
href="cztutfiles.html">Práce se soubory</a>)</span>.</p>


<h3>Datum a èas</h3>

<p>Pro datum a èas bıvá èasto vyhrazen samostatnı datovı typ. Nìkdy se pro
jejich reprezentaci jednoduše pouívá velké èíslo (typicky se jím vyjadøuje
poèet sekund, které uplynuly od zvoleného pevného data a èasu). Jindy se pro
jejich uloení pouívá datovı typ, kterı oznaèujeme jako <em>sloenı</em> a
kterı bude popsán v následujícím textu. Takovı datovı typ obvykle umoòuje
snadnìjší zjištìní mìsíce, dne, hodiny atd. V dalších tématech se struènì
seznámíme s pouíváním pythonovského modulu <code>time</code>. Jazyky
VBScript i JavaScript pouívají pro práci s èasem své vlastní mechanismy,
ale tìmi se zabıvat nebudeme.</p>


<h3 id="class">Sloenı, uivatelem definovanı typ</h3>

<p>Nìkdy se ukáe, e vıše popsané základní <span class="trnote"
title="Poznámka pøekladatele">jednoduché</span> typy nevyhovují a to ani po
jejich uspoøádání s vyuitím kolekcí. Nìkdy prostì chceme sdruit skupinu
<span class="trnote" title="Poznámka&nbsp;pøekladatele">rùznorodıch</span>
datovıch poloek dohromady a pracovat s nimi jako s celkem. Pøíkladem mùe
bıt poloka adresy: èíslo domu, ulice, mìsto a smìrovací èíslo.</p>

<p>Vìtšina programovacích jazykù dovoluje podobné informace sdruit to
takzvaného <em>záznamu</em> <span class="trnote"
title="Poznámka&nbsp;pøekladatele" >(anglicky <em>record</em>
[rikód])</span> nebo <em>struktury</em> <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(<em>structure</em> [strakèr])</span>
nebo její modernìjší, objektovì orientované podoby, <em>tøídy</em> <span
class="trnote" title="Poznámka&nbsp;pøekladatele">(<em>class</em>
[klás])</span>.</p>


<h4>VBScript</h4>

<p>V jazyce VBScript vypadá definice takového záznamu následovnì:</p>

<pre>
Class Adresa
     Public CisloDomu
     Public Ulice
     Public Mesto
     Public PSC
End Class
</pre>

<p>Klíèové slovo <code>Public</code> zajistí pøístupnost dat v celém
zbytku programu. Datové poloky mohou bıt oznaèeny také jako
<code>Private</code>, ale k tomu se v této uèebnici dostaneme a
pozdìji.</p>


<h4>Python</h4>

<p>Zápis stejného pøípadu v jazyce Python se pøíliš neliší:</p>

<pre id="address">
>>> class Adresa:
...     def __init__(self, Dum, Ul, Mesto, PSC):
...         self.CisloDomu = Dum
...         self.Ulice = Ul
...         self.Mesto = Mesto
...         self.PSC = PSC
...
</pre>

<p>Zápis se vám mùe zdát ponìkud záhadnı, ale nemìjte obavy. V kapitole
o&nbsp;<a href="cztutclass.html">objektovì orientovaném programování</a> si
vysvìtlíme, co znamená <code>def&nbsp;__init__(...)</code> a
<code>self</code>. Povšimnìme si jen toho, e identifikátor
<code>__init__</code> obsahuje na obou stranách <em>dvojici znakù
podtrení</em>. Jde o pythonovskou konvenci, o které se zmíníme pozdìji.
Kdy nìkteøí lidé zkoušeli zapsat uvedenı pøíklad na vyzıvacím øádku
interpretu jazyka Python, mìli s tím urèité poblémy. Na konci této kapitoly
naleznete zvıraznìnı úsek textu, kterı èásti pøíkladu podrobnìji vysvìtluje.
Ale pokud vám to víc vyhovuje, mùete s jeho studiem poèkat a na pozdìjší
dobu, a se v prùbìhu kurzu dozvíte všechny podrobnosti. Pokud se pokoušíte
o zapsání pøíkladu na vyzıvací øádek <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(anglicky <em>prompt</em>)</span> jazyka
Python, ujistìte se, e jste pouili stejnı zpùsob odsazení. Jak uvidíme
pozdìji, Python je v otázce odsazování úrovní <span class="trnote"
title="Poznámka&nbsp;pøekladatele">zdrojového textu</span> velmi
puntièkáøskı.</p>

<p>Hlavní poznatek, kterı byste si mìli z tohoto pøíkladu odnést, by mìl bıt
ten, e lze slouèit nìkolik kouskù dat do jediné struktury.</p>


<h4>JavaScript</h4>

<p>V jazyce JavaScript se pro definici struktury pouívá ponìkud podivné
jméno, a to <code>function</code>. Funkce si obvykle spojujeme s operacemi,
ne s datovımi kolekcemi, ale v pøípadì jazyka JavaScript se funkce pouívají
i pro tento úèel. Vytváøení objektu Adresa se v jazyce JavaScript zapisuje
takto:</p>

<pre>
function Adresa(Dum, Ul, Mesto, PSC)
{
    this.CisloDomu = Dum;
    this.Ulice = Ul;
    this.Mesto = Mesto;
    this.PSC = PSC;
}
</pre>

<p>Zopakujme to ještì jednou. Vısledkem je skupina datovıch poloek, na
kterou se díváme jako na jeden celek.</p>


<h3>Pøístup ke sloenım datovım typùm</h3>

<p>Hodnotu sloeného datového typu mùeme také pøiøadit do promìnné. Ale
abychom mohli pøistupovat k jednotlivım <em>slokám</em> hodnoty sloeného
typu, musíme pouít speciální zápis, kterı je urèen konkrétním programovacím
jazykem. Obvykle se k zápisu pouívá teèka.</p>

<h4>V jazyce VBScript</h4>

<p>Pokud budeme uvaovat vıše uvedenou tøídu Adresa, pak bychom v jazyce
VBScript mohli napsat:</p>
 
<pre>
Dim Adr
Set Adr = New Adresa

Adr.CisloDomu = 7
Adr.Ulice = "Havlíèkova"
Adr.Mesto = "Staré Mìsto"
Adr.PSC = "790 58"

MsgBox Adr.Ulice &amp; " " &amp; Adr.CisloDomu &amp; ", " &amp; Adr.Mesto
</pre>

<p>Nejdøíve jsme pouitím klíèového slova <code>Dim</code> vyhradili prostor
pro novou promìnnou <code>Adr</code>. S vyuitím <code>Set</code> vytvoøíme
novou <em>instanci</em> tøídy <code>Adresa</code>. Poté do poloek instance
nového objektu adresy pøiøadíme hodnoty a nakonec obsah zobrazíme v
dialogovém oknì pro zprávu (message box).</p>


<h4>V jazyce Python</h4>

<p>V jazyce Python &mdash; za pøedpokladu, e jste ji napsali vıše uvedenou 
definici tøídy Adresa &mdash; mùeme psát:</p>

<pre>
Adr = Adresa(7, "Havlíèkova", "Staré Mìsto", "790 58")
print Adr.Ulice, Adr.CisloDomu
print Adr.Mesto 
</pre>

<p>Tím se vytvoøí instance našeho typu <code>Adresa</code> a pøiøadí se do
promìnné <code>Adr</code>. V Pythonu mùeme pøedat hodnoty poloek v
okamiku vytváøení <em>objektu</em>. <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(Konstruktoru objektu lze pøedávat
parametry.)</span> Poté s vyuitím teèkového operátoru tiskneme sloky
<code>CisloDomu</code>, <code>Ulice</code> a <code>Mesto</code>. Mùete,
samozøejmì, vytvoøit více instancí tøídy <code>Adresa</code> a do kadé z nich pøiøadit
jiné èíslo domu, ulici, a tak dále. Vyzkoušejte si to. Tušíte, jak byste
mohli tøídu <code>Adresa</code> vyuít pro náš pøíklad adresáøe?</p>


<h4>A ještì v jazyce JavaScript</h4>

<p>Mechanismus pouívanı v jazyce JavaScript se velmi podobá mechanismùm v
ostatních jazycích. Pøesto zde mùeme nalézt &mdash; jak uvidíme za chvíli
&mdash; pár zvláštností. Nicménì, základní mechanismus je jednoduchı:</p>

<pre>
var Adr = new Adresa(7, "Havlíèkova", "Staré Mìsto", "790 58");
document.write(Adr.Ulice + " " + Adr.CisloDomu + ", " + Adr.Mesto);
</pre>

<p>K zpøístupnìní poloek mùeme pouít ještì jeden mechanismus, kdy se na
objekt díváme jako na slovník a jméno pole pouíváme jako klíè:</p>

<pre>
document.write(Adr['Ulice'] + " " + Adr['CisloDomu'] + " " + Adr['Mesto']);
</pre>

<p>Jedinı rozumnı dùvod k pouití tohoto zpùsobu, kterı mì napadá, je ten,
e jména poloek získáváte <span class="trnote"
title="Poznámka&nbsp;pøekladatele">za bìhu programu</span> v podobì øetìzce
&mdash; tøeba jako vısledek ètení ze souboru nebo jako vstup zadanı
uivatelem (viz dále).</p>


<h3 id="object">Operace definované uivatelem</h3>

<p>V nìkterıch programovacích jazycích mohou mít uivatelské datové typy
<span class="trnote" title="Poznámka pøekladatele">uivatelem</span>
definovány i operace. Tento rys patøí k základùm takzvaného <em>objektovì
orientovaného programování</em>. Tomuto tématu bude vìnována <a
href="cztutclass.html">samostatná kapitola</a>, ale v tomto okamiku si
uveïme alespoò to, e objekt se v podstatì tvoøen datovımi slokami a
operacemi definovanımi nad tìmito datovımi slokami. Vše je zabaleno
dohromady a vystupuje to jako jedinı celek. Python objekty široce vyuívá ve
své standardní knihovnì modulù a souèasnì nám jako programátorùm umoòuje
vytváøení svıch vlastních typù objektù.</p>

<p>Operace objektu se zpøístupòují stejnım zpùsobem, jako datové èleny
uivatelsky definovaného typu &mdash; prostøednictvím teèkového operátoru
&mdash;, ale jinak vypadají jako funkce. Tìmto zvláštním funkcím se øíká
<em>metody</em>. U jsme se s tím setkali u seznamu v podobì operace
<code>append()</code>. Vzpomeòte si, e abychom ji mohli pouít, museli jsme
volanou funkci spojit se jménem promìnné:</p>

<pre>
>>> seznam = []       <span class="comment"># prázdnı seznam</span>
>>> seznam.append(42) <span class="comment"># volání metody objektu seznam</span>
>>> print seznam
[42]
</pre>

<p>Pokud je typ objektu &mdash; øíká se mu <em>tøída</em> &mdash; definován
uvnitø nìjakého modulu, musíme tento modul importovat (jako jsme si ji
døíve ukázali v pøípadì modulu <code>sys</code>). Jménu objektového typu
pøedøadíme jméno modulu a vytvoøíme instanci tøídy <span class="trnote"
title="Poznámka pøekladatele">(tj. objekt)</span>, kterı bude uloen v
promìnné. Tu ji mùeme pouívat ani bychom uvádìli jméno modulu.</p>

<p>Ukáeme si to na fiktivním modulu <code>meat</code>, kterı definuje tøídu
<code>Spam</code><sup class="trnote"><a href="cztuttrn.html#Pdata_spam"
id="Bdata_spam" title="Co to je Spam?">[6]</a></sup>. Importujeme uvedenı
modul, vytvoøíme instanci tøídy Spam, dáme jí jméno <code>mySpam</code> a poté
pouijeme <code>mySpam</code> pro pøístup k jejím operacím a datovım slokám
takto:</p>

<pre>
>>> import meat
>>> mySpam = meat.Spam()     <span class="comment"># vytvoøení instance, uití jména modulu a tøídy</span>
>>> mySpam.slice()           <span class="comment"># uití operace objektu tøídy Spam (ukrojit)</span>
>>> print mySpam.ingredients <span class="comment"># pøístup k datùm objektu</span>
{'Pork': '40%', 'Ham': '45%', 'Fat': '15%'}
</pre>

<p>Na prvním øádku importujeme do našeho programu modul nazvanı
<code>meat</code> (jde o fiktivní, neexistující modul). Na druhém øádku
pouíváme modul <code>meat</code> k vytvoøení instance tøídy <code>Spam</code>
tím, e <span class="trnote" title="Poznámka&nbsp;pøekladatele">identifikátor
tøídy</span> pouijeme, jako kdyby se jednalo o volání funkce. Na tøetím øádku
pouíváme jednu z operací tøídy <code>Spam</code>, a sice
<code>slice()</code>. K objektu <code>mySpam</code> se chováme, jako kdyby to
byl modul a operace jako kdyby byla funkcí definovanou uvnitø modulu. Nakonec
zpøístupòujeme nìkterá data uchovávaná uvnitø objektu <code>mySpam</code>.
Opìt pouíváme zápis, kterı se podobá práci s modulem.</p>

<p>Pokud pomineme nutnost vytvoøení instance objektu, pak neexistuje
podstatnı rozdíl mezi pouíváním objektù, které moduly poskytují, a funkcí,
které se v modulech nacházejí. O jménu objektu mùeme uvaovat jako o
visaèce, která drí odpovídající funkce a promìnné seskupené dohromady.</p>

<p>Jinı zpùsob v pohledu na vìc je takovı, e objekty reprezentují skuteèné
vìci v našem svìtì, se kterımi mùeme &mdash; jako programátoøi &mdash; nìco
dìlat. Právì toto je pohled, kterı pùvodnì vedl ke zrození myšlenky
pouívání objektù v programech. Tıkal se zápisu poèítaèové simulace situací
v reálném svìtì.</p>

<p>S objekty mùeme pracovat i v jazycích VBScript i JavaScript. Ve vıše
uvedenıch pøíkladech s typem Adresa jsme ve skuteènosti nedìlali nic jiného.
Definovali jsme tøídu, vytvoøili jsme její instanci a promìnnou, pøes kterou
mùeme zpøístupòovat vlastnosti instance. Znovu si projdìte pøedchozí text a
zamìøte se na to, co jsme si øekli o tøídách a objektech. Zamyslete se nad
tím, e tøídy poskytují mechanismus pro definici novıch datovıch typù tím,
e svazují dohromady data a operace.</p>


<h4>Specifické operátory jazyka Python</h4>

<p>Mım prvotním cílem, kterému jsem zasvìtil tuto uèebnici, je nauèit vás
programovat. A aèkoliv zde pouívám jazyk Python, nevidím ádnı dùvod, proè
byste si po pøeètení tohoto textu nemohli nastudovat nìco o jiném jazyce a
zamìøit se na nìj. Dokonce oèekávám, e právì toto udìláte, protoe
neexistuje jedinı programovací jazyk, kterı se hodí na všechno. Python není
vıjimkou. Na druhou stranu, protoe jsem si vytknul takovı cíl, nevìnuji se
vıuce všech rysù jazyka Python, ale zamìøuji se na ty, které mùete obvykle
nalézt i u jinıch jazykù. Vısledkem tohoto rozhodnutí je skuteènost, e
nìkteré specifické rysy jazyka Python &mdash; i kdy jsou pomìrnì mocné
&mdash; nepopisuji vùbec. Patøí mezi nì i speciální operátory.
U&nbsp;vìtšiny programovacích jazykù mùeme nalézt nìkteré operace, které
jiné jazyky nepodporují. Èasto jsou to právì tyto <em>unikátní</em>
operátory, které dávají novım programovacím jazykùm vzniknout a které jsou
urèitì dùleitım faktorem urèujícím jak populárním se jazyk stane.</p>

<p>Python napøíklad podporuje takové netradièní operace, jako jsou získání
vıøezu vnitøní èásti seznamu (nebo øetìzce nebo n-tice <span class="trnote"
title="Poznámka&nbsp;pøekladatele"> &mdash; anglicky <em>slicing</em>
[slajsing]</span>, zapisujeme <code>spam[X:Y]</code>) a operaci pøiøazení
n-tice (<code>X, Y = 12, 34</code>), které nám umoòuje zapsat pøiøazení
více hodnot více promìnnım najednou. <span class="trnote" title="Poznámka
pøekladatele">(Poslednì uvedenému pøíkazu se øíká také násobnı nebo
paralelní pøiøazovací pøíkaz.)</span></p> 

<p>Python poskytuje i prostøedek k provedení poadované operace nad kadım
èlenem kolekce &mdash; slouí k tomu funkce <code>map()</code>. Takovıch
vìcí je mnohem více. Èasto se øíká, e "Python dostáváte i s pøiloenımi
bateriemi". Pokud se budete chtít dozvìdìt, jak tyto specifické operace
jazyka Python fungují, budete muset nahlédnout do jeho dokumentace.</p>

<p>Nakonec bych chtìl upozornit na to, e aèkoliv øíkám, e tyto operace
jsou specifické pro jazyk Python, neøíkám, e je nemùete nalézt v ádném
jiném jazyce. Spíše chci øíci, e je v kadém jazyce nenaleznete
<em>všechny</em>. Operace, kterımi se zabıváme v hlavním textu, jsou v
nìjaké podobì obecnì dostupné ve všech moderních programovacích
jazycích.</p>

<p>Tím uzavíráme náš pohled na programátorské suroviny. Nyní se posuòme k
více vzrušujícímu tématu postupù <span class="trnote"
title="Poznámka pøekladatele">(programovacích technik)</span> a uvidíme, 
jak mùeme zmínìné suroviny vyuít.</p>


<div class="details">
<h4>Podrobnìji vysvìtlenı pøíklad Adresa</h4>

<p>Jak u jsem øekl døíve, detaily tohoto pøíkladu budou vysvìtleny pozdìji.
Nìkteøí ètenáøi však mìli se zprovoznìním pythonovského pøíkladu problémy.
Tato poznámka vysvìtluje jeho kód øádek po øádku. Úplnı zápis pøíkladu
vypadá následovnì:</p>

<pre>
>>> class Adresa:
...     def __init__(self, Dum, Ul, Mesto, PSC):
...         self.CisloDomu = Dum
...         self.Ulice = Ul
...         self.Mesto = Mesto
...         self.PSC = PSC
...
>>> Adr = Adresa(7, "Havlickova", "Stare Mesto", "790 58")
>>> print Adr.CisloDomu, Adr.Ulice
</pre>

<p>Zde je vysvìtlení:</p> 

<pre>
>>> class Adresa:
</pre>

<p>Pøíkaz <code>class</code> (tøída) øíká, e hodláme definovat novı typ,
kterı se v tomto pøípadì nazıvá <code>Adresa</code>. Dvojteèka vyjadøuje
skuteènost, e všechny následující odsazené øádky budou souèástí definice
tøídy. Definice konèí prvním neprázdnım øádkem, kterı není vùèi prvnímu
øádku definice tøídy Adresa odsazen. Pokud pouíváte prostøedí IDLE, pak si
mùete všimnout, e editor <span class="trnote" title="Poznámka pøekladatele"
>po stisku klávesy Enter</span> další øádek automaticky odsadil. Pokud jste
Python spustili z pøíkazového øádku okna MS-DOS, pak na vyzıvacím øádku
pøekladaèe jazyka Python musíte provést poadované odsazení ruènì<span
class="trnote" title="Poznámka pøekladatele">, vloením mezer</span>.
Pøekladaèi jazyka Python nezáleí na tom, o kolik pozic odsadíte, pokud
budete odsazovat poøád o stejnou hodnotu.</p>

<pre>
...     def __init__(self, Dum, Ul, Mesto, PSC):
</pre>

<p>První polokou uvnitø definice naší tøídy je to, èemu øíkáme <em>definice
metody</em>. Dùleitım detailem je to, e jméno <span class="trnote"
title="Poznámka&nbsp;pøekladatele">konkrétnì této</span> metody zaèíná a
konèí dvojicí znakù podtrení. Jde o konvenci pro zápis jmen, kterım Python
pøisuzuje zvláštní vıznam. Tato konkrétní metoda se nazıvá
<code>__init__</code> a jde o speciální operaci, kterou Python <span
class="trnote" title="Poznámka&nbsp;pøekladatele">automaticky</span> provede
hned po vytvoøení instance naší nové tøídy &mdash; jak uvidíme za chvíli.
Dvojteèka, tak jako v pøedchozím pøípadì, jednoduše pøekladaèi jazyka Python
øíká, e následující skupina odsazenıch øádkù tvoøí definici této
metody.</p>

<pre>
...         self.CisloDomu = Dum
</pre>

<p>Tento øádek a tøi následující øádky pøiøazují hodnoty vnitøním <span
class="trnote" title="Poznámka pøekladatele">(datovım)</span> polokám
našeho objektu. Jsou odsazeny vùèi øádku s pøíkazem <code>def</code>,
abychom pøekladaèi jazyka Python naznaèili, e pøedstavují skuteènou
definici tìla operace <code>__init__</code>. Prázdnı øádek øíká interpretu
jazyka Python, e definice tøídy byla ukonèena, take Python znovu zobrazí
vyzıvací øádek ve tvaru '<code>>>>&nbsp;</code>'.</p>

<pre>
>>> Adr = Adresa(7, "Havlickova", "Stare Mesto", "790 58")
</pre>

<p>Tento øádek zajistí vytvoøení nové instance <span class="trnote"
title="Poznámka pøekladatele">(tj. nového objektu)</span> typu
<code>Adresa</code> a Python <span class="trnote" title="Poznámka pøekladatele" 
>automaticky</span> pouije vıše definovanou operaci <code>__init__</code> k
pøiøazení zadanıch hodnot do vnitøních poloek <span class="trnote"
title="Poznámka pøekladatele">objektu</span>. Vytvoøená instance je
pøiøazena do promìnné <code>Adr</code> stejnım zpùsobem, jako by byla
pøiøazena hodnota jiného datového typu.</p>

<pre>
>>> print Adr.CisloDomu, Adr.Ulice
</pre>

<p>Nyní tiskneme hodnoty dvou vnitøních poloek objektu, které jsme
zpøístupnili pomocí teèkového operátoru.</p>

<p>Jak jsem ji øekl, dalšími detaily se budeme v této uèebnici zabıvat
pozdìji. Klíèovı poznatek, kterı byste si z tohoto mìli odnést je, e nám
Python umoòuje vytvoøit náš vlastní datovı typ a pouívat ho stejnì snadno
jako vestavìné typy.</p>
</div>

<div class="remember">
<p class="title">Zapamatujte si</p>
<ul>

<li>Pøes promìnné se odkazujeme na data. Nìkdy musí bıt promìnné deklarovány
pøed tím, ne je definována jejich hodnota.</li>

<li>Hodnoty dat mohou bıt rùznıch typù. Operace, které lze úspìšnì
pouít, souvisí s typem dat, se kterımi pracujeme.</li>

<li>K jednoduchım datovım typùm patøí typy pro znakové øetìzce<sup
class="trnote"><a href="cztuttrn.html#Pdata_string" id="Bdata_string"
title="Jinı&nbsp;názor..." >[7]</a></sup>, èísla a boolovské neboli
pravdivostní hodnoty.</li>

<li>Ke sloenım datovım typùm mùeme øadit kolekce, soubory, datum <span
class="trnote" title="Poznámka pøekladatele">(v podobì záznamu se slokami
pro den, mìsíc, atd.)</span> a uivatelem definované datové typy.</li>

<li>Kadı programovací jazyk definuje øadu operátorù. Souèástí jeho studia
je vdy seznámení se s jeho datovımi typy a s operacemi, které jsou pro tyto
typy k dispozici.</li>

<li>Stejnı operátor (napøíklad sèítání) mùe bıt uíván pro rùzné datové
typy, ale vısledky se nemusí shodovat nebo dokonce spolu nemusí nijak
souviset. <span class="trnote" title="Poznámka pøekladatele">(Viz pøíklad
sèítání èísel a 'sèítání' øetìzcù.)</span></li>

</ul>
</div>

<div class="foot">
<p class="navig">[ 
<a href="cztutseq1.html" title="Jednoduché posloupnosti">pøedchozí</a> |
<a href="cztutcont.html">obsah</a> | 
<a href="cztutseq2.html" title="Další posloupnosti">další</a> 
]</p>

<p class="note">Pokud vás napadne, co by se dalo na pøekladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztutdata.html,v 1.14 2005/09/03 13:07:39 petr Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka' 
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20') 
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script> 

Tím budou do dopisu automaticky vloeny informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztutdata.html,v 1.14 2005/09/03 13:07:39 petr Exp $</p>
</div>
</body>
</html>


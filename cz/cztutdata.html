<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se naučit programovat: Data, datové typy a proměnné</title>
</head>
<body>


<h2>Data, datové typy a proměnné</h2>

<div class="whatcovered">
<p class="title">O čem si budeme povídat?</p>
<ul>
<li>Co jsou data.</li>
<li>Co jsou proměnné.</li>
<li>Datové typy a co se s nimi dá dělat.</li>
<li>Definování našich vlastních datových typů.</li>
</ul>
</div>

<h3>Úvod</h3>

<p>Při jakékoliv kreativní tvorbě potřebujeme tři základní položky:
nástroje, suroviny a techniky (postupy). Když si například budeme chtít něco
namalovat, našimi nástroji budou štětce, tužky a paleta. Technikami budeme
rozumět malování vlhkým do vlhkého, rozmývání, sprejování a podobně. A
konečně surovinami budou barvy, papír a voda. Při programování je to
podobné. Našimi nástroji jsou programovací jazyky, operační systémy a
hardware. Za techniky budeme považovat používání programových konstrukcí, o
kterých jsme se zmínili v předchozí části <span class="trnote"
title="Poznámka překladatele">(Koncepty &mdash; <a href="cztutwhat.html">Co
je to <em>programování</em>?</a> &mdash; <a
href="cztutwhat.html#Dijkstra">Společné vlastnosti programů</a>)</span>.
Surovinami budou data, se kterými budeme manipulovat. V této kapitole se
zaměříme právě na tyto suroviny.</p>

<p>Tato kapitola je docela dlouhá a ze své podstaty poněkud nezáživná. Dobrá
zpráva je, že si ji nemusíte přečíst celou najednou. Kapitola začíná
pohledem na nezákladnější datové typy, které máme k dispozici. Dále si
řekneme něco o tom, jak zacházet s kolekcemi položek. A nakonec se podíváme
na některá pokročilejší témata. Čtení kapitoly můžete přerušit po přečtení
části o kolekcích. Poté si můžete přečíst několik dalších kapitol a dočíst
ji můžete v okamžiku, kdy začneme používat složitější věci.</p>


<h3>Data</h3>

<p>Pojem <em>data</em> je jedním z těch, který lidé často používají, ale
málokdo rozumí jeho přesnému významu. V mém slovníku je pojem data definován
takto:</p>

 <blockquote>
 <em>"fakta nebo údaje, ze kterých je možné odvodit závěry; informace"</em>
 </blockquote>

<a name="type"></a> <p>Příliš nám to sice nepomůže, ale tuto definici můžeme
použít alespoň jako odrazový můstek. Uvidíme, zda se věci neozřejmí, když se
podíváme na to, jak je pojem data používán v oblasti programování. Data jsou
oním <em>materiálem</em>, surovými informacemi, se kterými manipuluje váš
program. Bez dat nemůže program provádět žádnou užitečnou činnost. Programy
mohou s&nbsp;daty manipulovat různými způsoby. Často to závisí na
<em>typu</em> dat. S každým datovým typem je spojena skupina
<em>operací</em> &mdash; tj. činností, které lze s daty <span class="trnote"
title="Poznámka překladatele">daného typu</span> provést. U čísel jsme si
například ukázali, že je můžeme sčítat. Sčítání je tedy operace, kterou
můžeme použít pro data typu číslo. Datových typů může být velké množství.
Postupně se podíváme na nejběžnější z nich a na operace, které lze pro ně
použít.</p>

<h3>Proměnné</h3>

<p>Data jsou uložena v paměti vašeho počítače. Můžeme ji přirovnat k velké
stěně plné skříněk, která se na poštách používá k třídění poštovních
zásilek. Dopis můžete strčit do libovolné skříňky, ale pokud by na těchto
skříňkách nebyly štítky s konkrétní cílovou adresou, nedávalo by jejich
použití smysl. Proměnné přestavují ty popisné štítky<sup
class="trnote"><a href="cztuttrn.html#Pdata_variable" id="Bdata_variable"
title="Poznámka k odlišnosti chápání pojmu proměnná v různých jazycích."
>[1]</a></sup> na skříňkách a ony skříňky jsou vytvořeny v paměti vašeho
počítače.</p>

<p>Zatím tedy víme, jak data vypadají. To je sice pěkné, ale k tomu, abychom
s nimi mohli manipulovat, musíme být schopni se k nim dostat. Právě k tomuto
účelu se používají proměnné. V programátorské terminologii říkáme, že
vytváříme <em>instance</em> datových typů a přiřazujeme je do proměnných<sup
class="trnote" id="Bdata_refinstance" title="Instance a její identifikace"
><a href="cztuttrn.html#Pdata_refinstance">[2]</a></sup>. Proměnná
představuje <em>odkaz</em> (nebo jinými slovy <em>referenci</em>) na určitou
oblast, která leží někde v paměti počítače. V těchto paměťových oblastech
jsou data uložena. V některých počítačových jazycích musí proměnná odpovídat
typu dat, na která odkazuje. Jakýkoliv pokus o přiřazení chybného typu dat
do takové proměnné způsobí ohlášení chyby. Někteří programátoři dávají
takovým jazykům přednost &mdash; říká se jim jazyky se <em>statickou typovou
kontrolou</em><sup class="trnote" id="Bdata_stattype"
title="Statická typová kontrola..."><a href="cztuttrn.html#Pdata_stattype"
>[3]</a></sup> &mdash;, protože umožňují předcházet určitým záludným chybám,
které se obtížně hledají.</p>

<p>Pravidla pro tvorbu jmen proměnných jsou závislá na konkrétním
programovacím jazyce. Každý jazyk předepisuje, které znaky mohou být součástí
jména proměnné, a které ne. V některých jazycích &mdash; a patří k nim i
Python a JavaScript &mdash; záleží na <em>velikosti</em> písmen a v angličtině
jsou označovány jako <em>case sensitive</em> [keis sensitiv], čili <em>citlivé
na velikost</em>. Jiné jazyky, jako například VBScript, velká a malá písmena
nerozlišují. Jazyky citlivé na velikost písmen po programátorovi vyžadují
trošku pečlivější přístup. Velmi nám pomůže, když budeme při volbě jmen
proměnných používat určitý systém. Jeden z běžných stylů, který budeme často
používat, zahajuje jméno proměnné malými písmeny a u každého dalšího slova
uvádí první písmeno velké:</p>

<pre>
velmiDlouheJmenoPromenneSOddelovanimSlovVelkymiPismeny
</pre>

<p class="trnote"><b>Poznámka překladatele:</b> Pro jména proměnných musíme
v&nbsp;jazyce Python volit písmena bez diakritických znamének.</p>

<p>Nebudeme zde podrobněji probírat pravidla popisující, které znaky můžeme v
našich jazycích používat. Při dodržování stylu používaného v
ukázkách byste se neměli setkat s nějakými problémy.</p>

<p>V jazyce Python proměnná získává typ podle do ní přiřazených dat. Datový
typ si tato proměnná zapamatuje a pokud se pokusíte kombinovat data různého
typu nedovoleným způsobem &mdash; jako je například sčítání řetězce a čísla
&mdash;, budete varováni. (Vzpomínáte si na dříve uvedený příklad s chybovým
hlášením? Ten byl příkladem právě takového typu chyby.) Pokud později
proměnné přiřadíte data jiného typu, pak se typ proměnné změní. <span
class="trnote" title="Poznámka&nbsp;překladatele">(To není například u výše
zmíněných jazyků se statickou typovou kontrolou možné.)</span></p>

<pre>
>>> q = 7       <span class="comment"># v q je nyní číslo</span>
>>> print q
7
>>> q = "Sedm"  <span class="comment"># do q jsme přiřadili řetězec</span>
>>> print q
Sedm
</pre>

<p>Povšimněte si, že na začátku byl proměnné <code>q</code> přiřazen odkaz
na <em>číslo</em> <code>7</code>. V proměnné se hodnota odkazu udržovala až
do té doby, než jsme ji přinutili, aby ukazovala na řetězec "Sedm". Takže
ještě jednou: proměnné jazyka Python si uchovávají typ dat, na která
ukazují. Ale to, na co ukazují, můžeme změnit jednoduše dalším přiřazením do
této proměnné. V tomto okamžiku jsou původní data prohlášena za 'ztracená' a
Python je odstraní z paměti (pokud na ně současně neodkazuje jiná proměnná).
Tento proces je znám jako <em>garbage collection</em>. <span
class="trnote">(Poznámka překladatele: Čti gábidž kolekšn. Tento pojem je
natolik specifický, že se obvykle nepřekládá; doslova by se dal přeložit
jako <em>sbírání smetí</em>.)</span></p>

<p>Garbage collection můžeme přirovnat k činnosti poštovního úředníka, který
jednou a čas odstraní všechny dopisy a balíčky ze skříněk, které nemají
žádný nápis. Pokud tyto dopisy na sobě nemají cílovou adresu nebo adresu
odesílatele, hodí je do smetí.</p>


<h3>Proměnné v jazycích VBScript a JavaScript</h3>

<p>Při používání proměnných v jazycích VBScript a JavaScript se navíc
setkáváme s drobnou odlišností. Oba uvedené jazyky vyžadují, abychom
proměnnou před jejím použitím <em>deklarovali</em>. Jde o obecný rys, se
kterým se setkáme u kompilovaných jazyků a u jazyků se <em>silnou typovou
kontrolou</em>. Jednou z velkých výhod tohoto přístupu je to, že překladač
může odhalit pokus o použití neznámé proměnné. K této situaci může dojít
tím, že se při zápisu použití proměnné dopustíme překlepu v jejím jméně.
Nevýhodou je samozřejmě to, že programátor toho musí napsat o něco víc.</p>

<div class="trnote">

<p><b>Poznámka překladatele:</b> Uvedená nevýhoda je zanedbatelná tím více,
čím větší projekt se realizuje. V takových případech programátor věnuje
mnohem více úsilí ostatním věcem, než je jednoduché klapání do klávesnice.
Za skutečnou nevýhodu můžeme považovat nutnost deklarace proměnných pouze u
jazyků, kde musíme deklaraci uvést na výrazně jiném místě zdrojového textu,
než se objevuje její první použití. (Při pohledu do zdrojového textu &mdash;
typicky přes okno editoru s omezeným počtem řádků na obrazovce &mdash; může
programátor ztratit přehled o deklaraci proměnné. Musí ji dohledávat a
ztrácí tím část svého času a mentální kapacity.) Příkladem takového jazyka
je například jazyk <code>C</code>. Naproti tomu například modernější jazyk
<code>C++</code> dovoluje uvést deklaraci přímo v místě prvního použití
proměnné.</p>

<p>Zajímavější diskusi lze vést na téma <em>silná</em> versus <em>slabá
typová kontrola</em>. Donedávna se tradovalo, že silná typová kontrola je
vždy a jednoznačně lepší, protože umožňuje odhalit určitou kategorii chyb
již při překladu. V poslední době již nejsou názory tak vyhraněné. Silná
typová může mít i nevýhody (komplikuje například <em>generické
programování</em>) a navíc nezaručí odhalení jiné kategorie chyb &mdash;
špatnou interpretaci hodnoty formálně správného typu. Odpovědi na tyto
problémy se nyní nehledají pouze v technikách fungování překladačů, ale i v
technologiích a technikách vývoje aplikací, v postupech programátorů. Jedním
z přístupů, který prokázal svou užitečnost, je psaní <em>testů
funkčnosti</em> (<em>unit testing</em> &mdash; jednotkové testy a
<em>acceptance testing</em> &mdash; uživatelské testy). Poučení i zajímavé
náměty k zamyšlení naleznete v článku <a
href="http://www.artima.com/intv/strongweak.html" target="_blank">Strong
versus Weak Typing</a>.</p>

</div>

<h4>VBScript</h4>

<p>Deklaraci proměnné zajistíme v jazyce VBScript použitím příkazu
<code>Dim</code>, což je zkratka slova <em>Dimension</em> <span
class="trnote" title="Poznámka překladatele">([dajmenžn] = rozměr)</span>.
Jde o projev dávných kořenů jazyka VBScript v jazyce BASIC a přes něj ještě
dále v jazycích typu assembler. V těchto jazycích jste museli uvést, jak
velký paměťový prostor bude proměnná vyžadovat &mdash; tedy její rozměr,
velikost. Zkratka <code>Dim</code> se dochovala z těchto dob.</p>

<p>Deklarace proměnné v jazyce VBScript vypadá takto:</p>
<pre>
Dim promenna
</pre>

<p>Jakmile je proměnná jednou deklarována, můžeme ji používat stejně, jako
jsme to ukázali u Pythonu. Jedním příkazem <code>Dim</code> můžeme
deklarovat více proměnných. Jejich seznam oddělujeme čárkami:</p>

<pre>
Dim promenna, druha, treti
</pre>

<p>Přiřazení provedeme takto:</p>

<pre>
promenna = 42
druha = "Toto je krátká větička."
treti = 3.14159
</pre>

<p>Dalším klíčovým slovem, se kterým se můžete občas setkat, je
<code>Let</code> <span class="trnote" title="Poznámka překladatele">([let] =
nechť)</span>. Jde opět o pozůstatek z jazyka BASIC a ve skutečnosti jej
nemusíte vůbec používat. Pokud přesto někdy uvidíte jeho použití, bude
vypadat nějak takto:</p>

<pre>
Let promenna = 22
</pre>

<p>V této učebnici nebudeme <code>Let</code> používat.</p>


<h4>JavaScript</h4>

<p>V jazyce JavaScript je deklarace proměnných uvedena klíčovým slovem
<code>var</code> a v jedné deklaraci můžeme uvést více proměnných, jako v
případě VBScript:</p>

<pre>
var promenna, druha, treti;
</pre>

<p>Součástí příkazu <code>var</code> může být v jazyce JavaScript i
inicializace (nebo <em>definice</em>, <span class="trnote"
title="Poznámka&nbsp;překladatele">tj. určení počáteční hodnoty</span>)
proměnných:</p>

<pre>
var promenna = 42;
var druha = "Krátká věta.", treti = 3.14159;
</pre>

<p>Ušetříme tím trochu psaní, ale jinak se tato forma <span class="trnote"
title="Poznámka&nbsp;překladatele">funkčně</span> od dvoukrokové definice
proměnných v jazyce VBScript nijak neliší.</p>

<p>Doufám, že tento stručný pohled proměnné v jazycích VBScript a JavaScript
objasnil rozdíl mezi jejich <em>deklarací</em> a <em>definicí</em>. V jazyce
Python dojde k <em>deklaraci</em> proměnné v okamžiku, kdy je uvedena její
<span class="trnote" title="Poznámka&nbsp;překladatele">první</span>
definice.</p>

<p>Nyní se podívejme na příklady datových typů a uvidíme, jak to všechno
pasuje dohromady.</p>


<h3>Jednoduché datové typy</h3>

<p>Jednoduché datové typy se nazývají jednoduchými proto, že patří k
nejzákladnějším typům dat, se kterými se dá manipulovat. Složitější datové
typy jsou ve skutečnosti jen kombinacemi jednoduchých datových typů.
Jednoduché datové typy jsou stavebními kameny, ze kterých se ostatní typy
budují. Jednoduché datové typy představují opravdový základ veškerých
výpočtů. Patří k nim písmena, čísla a něco, čemu se říká boolovský typ
(boolean).</p>


<h3 id="string">Znakové řetězce</h3>

<p>Už jsme se s nimi setkali. Patří k nim doslova libovolné řetězce, neboli
posloupnosti znaků, které mohou být zobrazeny na vaší obrazovce. (Ve
skutečnosti mohou obsahovat i netisknutelné <em>řídicí znaky</em>.)</p>

<p>V jazyce Python mohou být řetězce zapsány několika způsoby:</p>

<dl>
<dt>S jednoduchými apostrofy</dt>
<dd><pre>'Toto je retezec'</pre></dd>

<dt>S uvozovkami</dt>
<dd><pre>"Toto je velmi podobny retezec"</pre></dd>

<dt>S trojitými uvozovkami</dt>
<dd><pre>"""Tady je velmi dlouhy retezec, ktery -- pokud
   si to budeme prat -- muze byt zapsan na vice
   radcich. Python zachova viceradkovy retezec
   ve tvaru, v jakem jej zapiseme..."""
</pre>
</dd>
</dl>

<p>Naposledy zmíněná forma má jedno speciální použití. Používá se k
dokumentování funkcí, které jsme v jazyce Python sami napsali &mdash; k tomu
se ještě dostaneme.</p>

<p>K jednotlivým znakům řetězce můžeme přistupovat jako ke složkám znakového
pole (viz <em>pole</em> dále v textu). Každý programovací jazyk obvykle
poskytuje operace pro manipulaci s řetězci &mdash; nalezni podřetězec, spoj
dva řetězce, okopíruj jeden řetězec jinam a podobné.</p>

<p>Za zmínku stojí skutečnost, že některé jazyky používají zvláštní typ pro
ukládání znaků &mdash; tedy typ pro jeden znak. V takovém případě můžeme o
řetězcích uvažovat jako o kolekcích hodnot typu znak. Ve srovnání s tímto
přístupem Python používá pro uložení jednoho znaku jednoduše řetězec o délce
jedna. To znamená, že nepotřebuje jiný syntaktický předpis pro zápis řetězce
a jiný pro zápis jednoho znaku.</p>

<h4>Řetězcové operátory</h4>

<p>Nad řetězci lze provádět celou řadu operací. Některé z nich jsou přímo
zabudovány do jazyka Pyhon, ale řada dalších je poskytována moduly, které
musíme zapojit do činnosti příkazem <code>import</code> (tak, jak jsme to
udělali s modulem <code>sys</code> v kapitole <a
href="cztutseq1.html">Jednoduché posloupnosti</a>).</p>

<div class="center">
<table summary="Řetězcové operátory">
<col span="2" style="padding: 0 1em">
<caption>Řetězcové operátory</caption>
<tr><td>S1 + S2</td><td>Spojení řetězce S1 a S2</td></tr>
<tr><td>S1 * N</td><td>N-násobné opakování řetězce S1</td></tr>
</table>
</div>

<p>Následující příklady demonstrují jejich funkci:</p>

<pre>
>>> print 'Znovu a ' + 'znovu'        <span class="comment"># spojení řetězců</span>
Znovu a znovu
>>> print 'Opakuj ' * 3               <span class="comment"># opakování řetězce</span>
Opakuj Opakuj Opakuj
>>> print 'Znova ' + ('a znova ' * 3) <span class="comment"># kombinace '+' a '*'</span>
Znova a znova a znova a znova
</pre>

<p>Řetězce znaků můžeme přiřazovat do proměnných:</p>

<pre>
>>> s1 = 'Znova '
>>> s2 = 'a znova '
>>> print s1 + (s2 * 3)
Znova a znova a znova a znova
</pre>

<p>Všimněte si, že poslední dva příklady dávají stejný výstup.</p>

<p>S řetězci se dá dělat spousta dalších věcí, ale k tomu se podrobněji
dostaneme až v dalších tématech. Nejdříve si musíme osvojit základnější
znalosti.</p>


<h4>Řetězcové proměnné v jazyce VBScript</h4>

<p>V jazyce VBScript jsou proměnné <span class="trnote" title="Poznámka
překladatele">(v angličtině)</span> označovány jako <em>variants</em>,
protože mohou obsahovat libovolný typ dat. <span class="trnote"
title="Poznámka překladatele">(Nepřekládal jsem jako <em>varianty</em>,
protože by se to pletlo s <em>možnostmi</em>.)</span> VBScript se je podle
potřeby pokouší převádět na požadovaný typ. To znamená, že do proměnné
můžete přiřadit číslo, ale v okamžiku, kdy proměnnou použijete v místě, kde
se očekává řetězec, VBScript provede potřebný převod. Dá se říci, že se to
podobá chování pythonovského příkazu <code>print</code>, ale podobné chování
je rozšířeno na všechny příkazy jazyka VBScript. Pokud chceme překladači
napovědět, že se na nějakou číselnou hodnotu má dívat jako na řetězec,
uzavřeme ji do uvozovek:</p>

<pre>
&lt;script type="text/vbscript">
retezec = "42"
MsgBox retezec
&lt;/script>
</pre>

<p class="trnote"><b>Poznámka překladatele:</b> Zatímco <code>print</code>
se snaží převést vše na řetězec, automatické konverze ve VBScript se
principiálně snaží převádět cokoliv na cokoliv. Můžeme se na to také podívat
také jinak. Snaha o převod do použitelné podoby je v Pythonu vlastností
příkazu <code>print</code>, zatímco ve VBScript je vlastností proměnných
samotných. Tuto vlastnost jazyka VBScript ocení především začátečníci a dá
se dobře využít u jednoduchých skriptů. U složitějších a rozsáhlejších
programů může být podobné chování zdrojem obtížně odhalitelných chyb.</p>

<p>Řetězce můžeme spojovat dohromady. Této operaci se říká
<em>zřetězení</em> (konkatenace) a v jazyce VBScript k ní používáme operátor
<code>&amp;</code> takto:</p>

<pre>
&lt;script type="text/vbscript">
retezec = "Ahoj, " &amp; "vy tam!"
MsgBox retezec
&lt;/script>
</pre>

<h4>Řetězce v JavaScript</h4>

<p>V jazyce JavaScript mohou být řetězce uzavřeny buď v apostrofech nebo v
uvozovkách. Proměnné<span class="trnote"
title="Poznámka&nbsp;překladatele">, které použijeme pro jejich
zpřístupnění,</span> musíme před použitím <em>deklarovat</em>. Používáme k
tomu klíčové slovo <code>var</code>. Takže deklaraci a <em>definici</em>
dvou řetězcových proměnných provedeme v jazyce JavaScript takto:</p>

<pre>
&lt;script type="text/javascript">
var retezec1, retezec2;
retezec1 = "Ahoj, ";
retezec2 = "vy tam!";
document.write(retezec1 + retezec2)
&lt;/script>
</pre>

<p>Jako poznámku na závěr uveďme, že v jazyce JavaScript můžeme vytvářet
řetězce i jako <em>objekty</em> typu <code>String</code>. O objektech se
budeme bavit o něco později. Prozatím můžeme o objektech typu
<code>String</code> uvažovat jako o obyčejných řetězcích s určitými
vlastnostmi navíc. Hlavní rozdíl spočívá v tom, že je vytváříme trochu
jinak:</p>

<pre>
&lt;script type="text/javascript">
var retezec1, retezec2;
retezec1 = String("Ahoj, ");
retezec2 = String("vy tam!");
document.write(retezec1 + retezec2)
&lt;/script>
</pre>


<h3>Celá čísla</h3>

<p>Celá čísla &mdash; <span class="trnote" title="Poznámka překladatele">v
různých programovacích jazycích známá jako <em>integer</em>, nemají
desetinnou část &mdash; </span> jejich hodnoty se pohybují od velkých
záporných hodnot až po velké kladné hodnoty. Tuto důležitou skutečnost
bychom si měli zapamatovat. Obvykle neuvažujeme o tom, že by čísla měla být
co do velikosti nějak omezena, ale u počítačů existují jejich horní a dolní
hranice. Hodnota horní hranice je známa jako MAXINT a závisí na počtu bitů,
které váš počítač používá pro reprezentaci čísla. Na většině současných
počítačů je to 32&nbsp;bitů, takže konstanta MAXINT odpovídá hodnotě kolem 2
miliard. (V jazyce VBScript je to jen kolem 32 tisíc. <span class="trnote"
title="Poznámka překladatele">Pro reprezentaci čísla se používá jen 16 bitů,
čili dva bajty, takže můžeme vyjádřit čísla v rozmezí přibližně +/-32
tisíc</span>.)</p>

<p>Čísla, která mohou nabývat jak kladných, tak záporných hodnot jsou
označována jako <em>celá čísla se znaménkem</em> (<em>signed integer</em>).
Někdy se využívají i čísla, která jsou omezena pouze na kladné hodnoty a
nulu. Označujeme je jako <em>celá čísla bez znaménka</em> (<em>unsigned
integer</em>). <span class="trnote">(Poznámka překladatele: Pokud na chvíli
zapomeneme na omezení horní hranicí, pak v matematice takovým číslům říkáme
<em>přirozená čísla</em>.)</span> V takovém případě se horní hranice zvětší
na dvojnásobek hodnoty MAXINT &mdash; u 32bitových čísel na hodnotu kolem 4
miliard &mdash;, protože prostor, který byl jinak vyhrazen pro reprezentaci
záporných čísel, může být využit pro reprezentaci dalších kladných
čísel.</p>

<p>Protože jsou celá čísla <span class="trnote"
title="Poznámka&nbsp;překladatele" >(budeme říkat také <em>čísla typu
integer</em>)</span> shora omezena konstantou MAXINT, může nastat situace, kdy
součet dvou čísel přesáhne konstantu MAXINT a výsledný součet bude chybný<span
class="trnote" title="Poznámka&nbsp;překladatele">, protože správný výsledek
nelze do vyhrazeného prostoru 32 bitů uložit</span>. V některých
systémech/jazycích se vrací tato špatná hodnota přímo tak jak vyšla (často je
současně nastaven skrytý příznak chyby, který můžete testovat, pokud
předpokládáte, že k chybě mohlo dojít). Obvykle se však v této situaci vyvolá
chybový stav, který můžete vaším programem zjistit a ošetřit. Pokud tak
neučiníte, program se ukončí. Jazyky VBScript a JavaScript se chovají posledně
zmíněným způsobem. Poslední verze jazyka Python se v chování mírně liší. Od
verze 2.3 výše Python automaticky převádí celé číslo na něco, čemu se říká
<em>velké celé číslo</em> (<em>long integer</em>; <span class="trnote"
title="Poznámka&nbsp;překladatele">nezaměňujte s typem <code>long</code> v
jazycích C a C++, kdy se číslo ukládá na 32 bitech</span>). Jde o specifickou
vlastnost jazyka, která umožňuje pracovat s celými čísly o prakticky neomezené
velikosti. Nic ovšem není zadarmo. Platíme za to cenou mnohem pomalejšího
zpracování. Přinejmenším si však můžeme být jisti tím, že naše výpočty nakonec
skončí korektně. Navíc rychlost je v počítačovém světě velmi relativní. Pokud
takových velmi velkých celých čísel nezpracováváme mnoho, pravděpodobně si
rozdílu ani nevšimnete. To, že se skutečně jedná o velké celé číslo můžeme
poznat podle toho, že je Python zobrazuje s připojeným 'L' (jako long):</p>

<pre>
>>> 1234567 * 3456789
4267637625363L
>>> _
</pre>

<p>Povšimněte si, že jsme zde nepoužili příkaz <code>print</code>. Pokud
bychom tak učinili, zmíněné 'L' by zůstalo skryto. Python umožňuje <span
class="trnote" title="Poznámka&nbsp;překladatele">v interaktivním
režimu</span> dva způsoby zobrazování hodnot. Výsledek použití příkazu
<code>print</code> je obvykle hezčí (ve smyslu snadnější čitelnosti), ale
prosté použití hodnoty, jako ve výše uvedeném příkladu, nám občas odhalí více
detailů. Zkuste si příklady z předchozích témat zapsat bez použití příkazu
<code>print</code> a zaměřte se na pozorování drobných rozdílů v zobrazení.
Příkaz <code>print</code> budu používat také z toho důvodu, že mnohé jazyky
jeho použití vyžadují. A také chci, aby vám do krve přešly dobré obecné návyky
a ne pouze podlné postupy, které vám umožňuje Python.</p>


<h4>Aritmetické operátory</h4>

<p>S většinou aritmetických operátorů, které budeme potřebovat, jsme se již
setkali v kapitole <a href="cztutseq1.html">Jednoduché posloupnosti</a>.
Zopakujme si je:</p>

<table summary="Aritmetické operátory v jazyce Python">
<caption>Aritmetické operátory v jazyce Python</caption>
<col span="2" valign="top" style="padding: 0 1em">
<tr><th>Příklad</th><th>Popis významu</th></tr>
<tr>
<td>M + N</td>
<td>Sčítání M a N</td>
</tr>

<tr>
<td>M - N</td>
<td>Odčítání N od M</td>
</tr>

<tr>
<td>M * N</td>
<td>Násobení M a N</td>
</tr>

<tr>
<td>M / N</td>
<td>Dělení, jak čísel typu integer tak reálných čísel. Výsledek
záleží na typu čísel M a N. Když je alespoň jedno z čísel M a N reálné,
výsledek bude též reálný.</td>
</tr>

<tr>
<td>M&nbsp;%&nbsp;N</td>
<td>Modulo: nalezne zbytek po celočíselném dělení M : N</td>
</tr>

<tr>
<td>M**N</td>
<td>Umocňování: M na N-tou</td>
</tr>
</table>

<p>O posledním z nich jsme se ještě nezmínili. Podívejme se na příklad v
němž vytvoříme několik proměnných typu integer a poté použijeme operátor pro
umocňování:</p>


<pre>
>>> i1 = 2    <span class="comment"># vytvoř proměnnou i1 a přiřaď jí hodnotu celého čísla</span>
>>> i2 = 4
>>> i3 = 2**4 <span class="comment"># přiřaď výsledek dvě na čtvrtou do i3</span>
>>> print i3
16
</pre>


<h4>Celá čísla v jazyce VBScript</h4>

<p>Jak již bylo uvedeno výše, hodnoty typu integer jsou v jazyce VBScript
omezeny menší hodnotou MAXINT, která odpovídá uložení na 16 bitech &mdash;
konkrétně zhruba +/-32 tisíc. Pokud potřebujete pracovat s větší
celočíselnou hodnotou, můžete použít <code>long</code>. Ten <span
class="trnote" title="Poznámka&nbsp;překladatele" >co do rozsahu</span>
odpovídá typu integer, který je standardně používán v jazyce Python. Ve
VBScript lze používat i typ <code>byte</code>, který definuje čísla uložená
na 8 bitech, s maximální hodnotou 255 <span class="trnote"
title="Poznámka&nbsp;překladatele">(interval 0 až 255)</span>. V praktických
případech vám většinou bude vyhovovat použití standardního typu integer.</p>

<p>Podporovány jsou všechny aritmetické operátory.</p>


<h4>Čísla v jazyce JavaScript</h4>

<p>Jistě není žádným překvapením, že JavaScript také definuje numerický typ.
Čísla mají opět podobu objektu, viz dále, a nazývají se <code>Number</code>
<span class="trnote" title="Poznámka&nbsp;překladatele" >(tj. číslo)</span>.
Jak originální, že? :-)</p>

<p>V jazyce JavaScript lze použít i takzvané <em>Not a Number</em> neboli
<em>NaN</em> <span class="trnote" title="Poznámka&nbsp;překladatele"
>(<em>ne-číslo</em> nebo <em>toto-není-číslo</em>)</span>. Jde o speciální
verzi objektu Number a reprezentuje neplatné číslo. Většinou se používá v
roli výsledku nějaké operace, která je z matematického hlediska nepřípustná.
Hlavní myšlenka zavedení NaN spočívá v možnosti testovat některé typy chyb
aniž by došlo k přerušení programu. JavaScript definuje i další speciální
verze typu Number, které reprezentují kladné a záporné nekonečno. V
programovacích jazycích se tento rys objevuje zřídka. Číselné objekty v
jazyce JavaScript reprezentují buď celá čísla nebo reálná čísla &mdash; viz
dále.</p>


<h3>Reálná čísla</h3>

<p>Jde o čísla s desetinnou částí, o zlomky<sup class="trnote"
id="Bdata_real" title="Jsou to tedy reálná nebo racionální čísla?"><a
href="cztuttrn.html#Pdata_real">[4]</a></sup>. Mohou reprezentovat čísla
velmi velká, mnohem větší než MAXINT, ale s menší přesností. To znamená, že
dvě čísla, která by měla být shodná, ve skutečnosti pro počítač stejná
nejsou. Je to dáno tím, že počítač ukládá jen přibližnou hodnotu v
závislosti na tom, jakou úroveň detailů čísla je schopen zachytit. Například
číslo 4.0 by mohlo být uloženo jako 3.9999999&hellip; nebo
4.000000&hellip;01. Ve většině případů taková přibližnost postačuje, ale
občas může mít důležité dopady. Pokud při používání reálných čísel dostanete
nějaké legrační výsledky, mějte tuto skutečnost na paměti.</p>

<p>S reálnými čísly, známými také jako čísla <em>s plovoucí řádovou
čárkou</em> (<em>floating-point numbers)</em>, můžeme provádět stejné
operace jako s čísly typu integer. Navíc máme k dispozici operace pro převod
na celá čísla odseknutím <span class="trnote"
title="Poznámka&nbsp;překladatele" >nebo zaokrouhlením</span> desetinné
části.</p>

<p>Python, VBScript i JavaScript práci s reálnými čísly podporují. V jazyce
Python je vytvoříme jednoduše tím, že uvedeme zápis čísla, ve kterém se
vyskytuje desetinná tečka &mdash; jak jsme si ukázali v části <a
href="cztutseq1.html">Jednoduché posloupnosti</a>. V jazycích VBScript a
JavaScript nejsou celá čísla a reálná čísla <span class="trnote"
title="Poznámka&nbsp;překladatele">při používání</span> jasně rozlišována.
Jednoduše je používáme a překladač jazyka si s tím většinou dobře
poradí.</p>


<h3>Komplexní nebo imaginární čísla</h3>

<p>Pokud máte základy matematického nebo jiného vědeckého vzdělání, pak vás
možná napadlo: A co komplexní čísla? Pokud tyto základy nemáte, možná jste o
komplexních číslech vůbec neslyšeli. V takovém případě můžete tuto část
přeskočit, protože vám zde uvedená fakta k ničemu nebudou. Nicméně, některé
programovací jazyky, včetně jazyku Python, mají podporu pro typ komplexních
čísel zabudovánu přímo do jazyka, zatímco k jiným jazykům se dodávají
knihovny nebo funkce, které práci s komplexními čísly umožňují. A ještě než
se zeptáte &mdash; totéž platí pro matice.</p>

<p>V jazyce Python jsou komplexní čísla reprezentována jako:</p>

<pre>
(<span class="comment">real</span>+<span class="comment">imaginary</span>j)
</pre>

<p><span class="trnote" title="Poznámka&nbsp;překladatele">... kde
<code>real</code> představuje reálnou složku a <code>imaginary</code> složku
imaginární.</span></p>

<p>Takže sčítání komplexních čísel zapisujeme následovně:</p>

<pre>
>>> M = (2+4j)
>>> N = (7+6j)
>>> print M + N
(9+10j)
</pre>

<p>Všechny operace používané pro čísla typu integer je možno použít i pro
komplexní čísla.</p>

<p>VBScript ani JavaScript práci s komplexními čísly nepodporují.</p>



<h3 id="Boolean">Hodnoty typu Boolean &mdash; True a False</h3>

<p>Tento podivně vypadající název typu je pojmenován po matematikovi
19.&nbsp;století, George Boolovi, který se zabýval studiem logiky. Jak už
nadpis napovídá, tento typ má pouze dvě hodnoty &mdash; <em>true</em>
(pravda) a <em>false</em> (nepravda). Některé jazyky podporují boolovské
hodnoty přímo, jiné používají konvence, kdy vybraná číselná hodnota (často
nula) reprezentuje false a jiná hodnota (často 1 nebo -1) reprezentuje true.
Bylo tomu tak i u jazyka Python, a to až do verze 2.2 včetně. Od verze 2.3
podporuje Python boolovské hodnoty přímo &mdash; používá hodnoty
<code>True</code> a <code>False</code>.</p>

<p>Boolovské hodnoty jsou známy také jako <em>pravdivostní hodnoty</em>,
protože vyjadřují skutečnost, zda je něco pravdivé nebo nepravdivé. Dejme
tomu, že píšete program, který má zálohovat všechny soubory v adresáři.
Můžeme <span class="trnote" title="Poznámka překladatele">v cyklu</span>
postupovat tak, že uložíme soubor jednoho jména a potom se operačního
systému zeptáme, jak se jmenuje další soubor. Pokud už žádný další soubor
neexistuje <span class="trnote" title="Poznámka překladatele">(tj. byly
zpracovány všechny soubory v adresáři)</span>, vrátí se prázdný řetězec.
Vrácené jméno souboru tedy můžete porovnat s hodnotou prázdného řetězce a
výsledek můžete uložit jako boolovskou hodnotu (pokud je vrácený řetězec
prázdný, uloží se True, pokud ne, uložíme False). Později si ukážeme, jak
můžeme takto uložený výsledek použít.</p>

<table summary="Boolovské operátory">
<caption>Boolovské (nebo také logické) operátory</caption>
<col span="3" style="padding: 0 1em" valign="top">
<tr><th>Zápis</th><th>Jméno operace</th><th>Popis významu</th></tr>
<tr>
<td>A&nbsp;and&nbsp;B</td>
<td>A&nbsp;<small class="trnote">současně</small></td>
<td>True, když A i B jsou True. V jiném případě je výsledkem False.</td>
</tr>

<tr>
<td>A&nbsp;or&nbsp;B</td>
<td>NEBO</td>
<td>True když oba nebo jeden z A, B jsou True. False, když oba A i B
jsou False.</td>
</tr>

<tr>
<td>A == B</td>
<td>ROVNOST</td>
<td>True když A je rovno B.</td>
</tr>

<tr>
<td>A&nbsp;!=&nbsp;B<br><small>nebo</small><br>A&nbsp;&lt;&gt;&nbsp;B</td>
<td>NEROVNOST</td>
<td>True když A není rovno B.</td>
</tr>

<tr>
<td>not B</td>
<td>NEGACE</td>
<td>True když B není True.</td>
</tr>
</table>

<p><b>Poznámka:</b> poslední operace se týká jedné hodnoty, zatímco
ostatní porovnávají dvě hodnoty.</p>

<p>Jazyk VBScript, stejně jako Python, používá typ Boolean s hodnotami
<code>True</code> a <code>False</code>. Jazyk JavaScript rovněž používá typ
Boolean, ale jeho hodnoty jsou tentokrát pojmenovány <code>true</code> a
<code>false</code> (první písmeno se píše malé).</p>

<p>Různé jazyky používají pro pojmenování boolovského typu mírně odlišná
jména. Python mu říká <em>bool</em>, VBScript a JavaScript <em>Boolean</em>.
Většinou se tím nemusíte vůbec zabývat, protože budete spíše používat
boolovské výsledky v testech, než abyste je ukládali do boolovských
proměnných.</p>


<h3>Kolekce</h3>

<p>Pro studium <em>kolekcí</em> a jejich chování byla v počítačové vědě
vybudována celá disciplína. Někdy bývají kolekce označovány pojmem
<em>kontejnery</em>. V této sekci se nejdříve podíváme na kolekce, které
podporují jazyky Python, VBScript a JavaScript. Nakonec stručně shrneme, s
jakými dalšími typy kolekcí se můžeme setkat v jiných jazycích.</p>


<h4>Seznam</h4>

<p>Seznamy dobře známe z každodenního života. <p>Seznam <span class="trnote"
title="Poznámka&nbsp;překladatele">(anglicky <em>list</em> [list])</span> je
jednoduše tvořen posloupností položek. Do seznamu můžeme položky přidávat
nebo je můžeme naopak odstraňovat. Pokud máme seznam napsaný na papíru, pak
můžeme stěží vkládat položky doprostřed. Můžeme je přidávat pouze na konec.
Ale pokud seznam udržujeme v elektronické podobě, dejme tomu v textovém
editoru, můžeme nové položky vkládat do libovolného místa seznamu.</p>

<p>V seznamu můžeme také vyhledávat &mdash; pokud chceme zjistit, zda v něm
něco už je, nebo ne. V takovém prípadě ale musíme seznam procházet postupně,
od začátku do konce, a kontrolovat, zda se jedná o položku, kterou hledáme.
Seznamy patří v mnoha moderních programovacích jazycích k základním typům s
charakterem kolekce.</p>

<p>V jazyce Python jsou seznamy přímo jeho součástí (jsou zabudovány do
jazyka). Můžeme s nimi provádět všechny základní operace, o kterých jsme se
zmínili výše. Navíc můžeme položky seznamu
zpřístupňovat i prostřednicvím <em>indexu</em>. To znamená, že k prvku
seznamu můžem přistupovat na základě znalosti jeho pořadového čísla.
(Prvnímu prvku je přiděleno pořadové číslo nula.)</p>

<p>V jazyce VBScript neexistují seznamy jako takové, ale jejich vlastnosti
můžeme simulovat jinými typy kolekcí, o kterých se zmíníme později.</p>

<p>V jazyce JavaScript rovněž nemáme přímo typ seznam, ale téměř ke všemu,
co potřebujete dělat se seznamem, můžete využít jeho typ <em>pole</em>
(array [erey]). Jde o jiný typ kolekce, o kterém se budeme bavit o něco
později.</p>


<h4>Operace nad seznamem</h4>

<p>Python definuje nad kolekcemi řadu operací. Téměř všechny z nich lze
aplikovat na seznamy. Část operací lze aplikovat na další typy kolekcí a
také na řetězce, které jsou vlastně jen speciálním případem seznamu &mdash;
jde o&nbsp;<em>seznam znaků</em>. V jazyce Python seznam vytvoříme a
zpřístupníme použitím hranatých závorek. <span class="trnote"
title="Poznámka&nbsp;překladatele">(Tímto zápisem seznam
<em>konstruujeme</em>, proto se takto použité dvojici hranatých závorek říká
také <em>konstruktor seznamu</em>.)</span> Pokud použijeme pouze hranaté
závorky a nic do nich nevepíšeme, vytvoříme prázdný seznam. Seznam s
hodnotami vytvoříme tak, že požadované hodnoty zapíšeme dovnitř závorek a
oddělíme je čárkami:</p>

<pre>
>>> seznam = []
>>> jinySeznam = [1, 2, 3]
>>> print jinySeznam
[1, 2, 3]
</pre>

<p>K jednotlivým položkám můžeme přistupovat pomocí indexu, který uvedeme v
hranatých závorkách. První položka seznamu má přidělen index 0 (nula). Pokud
například chceme zpřístupnit třetí prvek, použijeme index 2:</p>

<pre>
>>> print jinySeznam[2]
3
</pre>

<p>Hodnoty položek seznamu můžeme podobným způsobem i měnit:</p>

<pre>
>>> jinySeznam[2] = 7
>>> print jinySeznam
[1, 2, 7]
</pre>

<p>Povšimněte si, že třetí prvek (index 2) změnil svou hodnotu z 3 na 7.</p>

<p>Záporné hodnoty indexového čísla používáme pro zpřístupnění položek
indexovaných vůči konci seznamu. Nejčastěji se používá index -1 (mínus
jedna), který zajistí zpřístupnění poslední položky seznamu:</p>

<pre>
>>> print jinySeznam[-1]
7
</pre>

<p>Operátorem <code>append()</code> můžeme přidávat nové položky na konec
seznamu:</p>

<pre>
>>> seznam.append(42)
>>> print seznam
[42]
</pre>

<p>Položkou seznamu může být dokonce i jiný seznam, takže pokud připojíme na
konec prvního seznamu náš druhý seznam, dopadne to takto:</p>

<pre>
>>> seznam.append(jinySeznam)
>>> print seznam
[42, [1, 2, 7]]
</pre>

<p>Všimněte si, že výsledkem je seznam složený ze dvou položek, kde druhou
položku tvoří opět seznam (jak je znázorněno párem okolních hranatých
závorek). V posledním případě můžeme prvek s hodnotou 7 zpřístupnit pomocí
dvojitého indexu:</p>

<pre>
>>> print seznam[1][2]
7
</pre>

<p>Hodnota prvního indexu (tj. 1) zpřístupní druhou položku seznamu, která
je vlastně seznamem. Hodnota druhého indexu (tj. 2) zpřístupní třetí položku
zmíněného podseznamu.</p>

<p>Možnost vnořování seznamů jednoho do druhého je velmi užitečná. Tato
vlastnost nám umožňuje budovat datové tabulky, jako je například
následující:</p>

<pre>
>>> radek1 = [1, 2, 3]
>>> radek2 = ['a', 'b', 'c']
>>> tabulka = [radek1, radek2]
>>> print tabulka
[[1, 2, 3], ['a', 'b', 'c']]
>>> prvek2 = tabulka[0][1]
</pre>

<p>Tímto způsobem si můžeme vybudovat například adresář <span class="trnote"
title="Poznámka&nbsp;překladatele">(pro ukládání adres lidí)</span>, kde
každá položka představuje seznam se jménem a dalšími detaily adresy.
Následující příklad uvádí adresář s dvěmi položkami:</p>

<pre>
>>> adresy = [
... ['Mirek', 'Kolbenova 15', 'Olomouc', '585 456 231'],
... ['Hanka', 'Ypsilantiho 42', 'Brno', '525 698 444']
... ]
</pre>

<p>Povšimněte si, že jsme celý zanořený seznam vytvořili zápisem na jednom
řádku <span class="trnote" title="Poznámka&nbsp;překladatele">(je zalomen
jen kvůli nedostatku prostoru &mdash; tečky znázorňují pokračování
řádku)</span>. Python sleduje, zda počet uzavřených závorek odpovídá počtu
otevřených. Pokud ne, pokračuje v načítání vstupu, až do doby, kdy se počty
srovnají. Uvedený zápis představuje velmi efektivní způsob rychlého budování
složitých datových struktur. Celková struktura &mdash; v tomto případě
seznam seznamů &mdash; přitom zůstává pro čtenáře kódu přehledná.</p>

<p>Cvičně zkuste získat Mirkovo telefonní číslo &mdash; čtvrtý prvek z
prvního řádku. Uvědomte si, že indexy začínají nulou. Zkuste přidat několik
svých záznamů použitím operace <code>append()</code>, o které jsme se
zmiňovali výše.</p>

<p>Jakmile Python ukončíte, vaše data budou ztracena. Až se budeme bavit
o&nbsp;souborech, zjistíte, jak můžete data <span class="trnote"
title="Poznámka&nbsp;překladatele">ze seznamu</span> uložit pro další
použití.</p>

<p>Opačnou operací k přidávání položky je, samozřejmě, rušení položky.
Provedeme ji příkazem <code>del</code>:</p>

<pre>
>>> del seznam[1]
>>> print seznam
[42]
</pre>

<p>Pokud chceme spojit dva seznamy do jednoho, můžeme použít stejný operátor
pro zřetězení '<code>+</code>', který jsme již použili dříve pro
řetězce:</p>

<pre>
>>> print seznam
[42]
>>> print jinySeznam
[1, 2, 7]
>>> novySeznam = seznam + jinySeznam
>>> print novySeznam
[42, 1, 2, 7]
</pre>

<p>Povšimněte si, že se výsledek tentokrát liší od dříve uvedeného příkladu,
kdy jsme spojovali dva seznamy operací <code>append()</code>. Tehdy jsme
dostali seznam s dvěmi prvky, přičemž druhým prvkem byl <span class="trnote"
title="Poznámka&nbsp;překladatele">připojovaný</span> seznam. V tomto
případě dostáváme seznam s čtyřmi prvky, protože do nového seznamu byly
vloženy prvky z obou spojovaných seznamů &mdash; každý prvek samostatně.
Pokud v tomto případě přistupujeme k prvku <span class="trnote"
title="Poznámka&nbsp;překladatele">s indexem</span>&nbsp;1, nedostaneme se
tentokrát k podseznamu, jak tomu bylo v předchozím případě, ale pouze k
prvku <span class="trnote" title="Poznámka&nbsp;překladatele">s
hodnotou</span> <code>1</code>:</p>

<pre>
>>> print novySeznam[1]
1
</pre>

<p>Pro naplnění seznamu více položkami se stejnou hodnotou můžeme využít
operátoru pro opakování &mdash; zápis se podobá násobení:</p>

<pre>
>>> seznamNul = [0] * 5
>>> print seznamNul
[0, 0, 0, 0, 0]
</pre>

<p>Pro prvek seznamu s určitou hodnotou můžeme nalézt jeho index operací
<code>index()</code>:</p>

<pre>
>>> print [1,3,5,7].index(5)
2
>>> print [1,3,5,7].index(9)
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in ?
ValueError: list.index(x): x not in list
</pre>

<p>Povšimněte si, že pokus o nalezení něčeho, co není prvkem seznamu, má za
následek chybu. V dalších částech učebnice si ukážeme způsoby, jak lze
zjistit, zda se něco v seznamu nachází, či nikoliv.</p>


<p>Délku seznamu <span class="trnote" title="Poznámka&nbsp;překladatele"
>(počet jeho položek)</span> můžeme zjistit voláním zabudované funkce
<code>len()</code>:</p>

<pre>
>>> print len(seznam)
1
>>> print len(novySeznam)
4
>>> print len(seznamNul)
5
</pre>

<p>Ani JavaScript ani VBScript typ seznam přímo nepodporují. Ale o kousek
dál si ukážeme, že podporují typ <code>Array</code> <span class="trnote"
title="Poznámka&nbsp;překladatele">(pole)</span>, se kterým lze napodobit
funkčnost pythonovských seznamů.</p>


<h4>N-tice</h4>

<p>Typ n-tice <span class="trnote" title="Poznámka překladatele">(anglicky
<em>tuple</em>)</span> není řadou jazyků vůbec podporován. Ale v těch
jazycích, kde jsou n-tice podporovány, se ukazuje, že je to velmi užitečný
rys. N-tice je ve skutečnosti jen libovolná <span class="trnote"
title="Poznámka&nbsp;překladatele">uspořádaná</span> kolekce hodnot, se
kterou můžeme zacházet jako s jedním celkem. V mnoha ohledech se n-tice
podobá seznamu, ale jeden významný rozdíl spočívá v tom, že n-tice jsou
<em>neměnné</em> <span class="trnote"
title="Poznámka&nbsp;překladatele">(anglicky <em>immutable</em>)</span>. To
znamená, že jakmile je jednou n-tice vytvořena, nelze ji měnit (tj. nelze
měnit, přidávat nebo rušit jednotlivé položky n-tice). V jazyce Python se
n-tice zapisují jako posloupnost hodnot oddělených čárkami, která je
uzavřená v kulatých závorkách &mdash; takto:</p>

<pre>
>>> ntice = (1, 3, 5)
>>> print ntice[1] <span class="comment"># zpřístupníme položku indexem, jako u seznamu</span>
3
>>> ntice[2] = 7   <span class="comment"># chyba: položku n-tice nelze měnit</span>
Traceback (most recent call last):
  File "", line 1, in ?
    ntice[2] = 7
TypeError: object doesn't support item assignment
           <span class="trnote" title="Poznámka překladatele">objekt nepodporuje přiřazování hodnot do položek</span>
</pre>

<p>Zapamatujme si hlavně to, že kulaté závorky používáme při vytváření
n-tice, že hranaté závorky se používají pro uvedení indexu při přístupu
k&nbsp;jejím položkám a že jednou vytvořenou n-tici nelze později měnit.
V&nbsp;ostatních případech lze na n-tice aplikovat většinu operací, které se
používají pro seznamy.</p>

<p>Ačkoliv n-tici nemůžeme měnit, můžeme operátorem pro sčítání (plus)
jakoby přidat další členy. Ve skutečnosti se tím totiž vytvoří nová
n-tice:</p>

<pre>
>>> ntice1 = (1, 2, 3)
>>> ntice2 = ntice1 + (4,) <span class="comment"># čárka způsobí, že se zápis chápe jako n-tice a ne jako číslo</span>
>>> print ntice2
(1, 2, 3, 4)
</pre>

<p>Pokud bychom za číslem 4 neuvedli čárku, Python by to chápal jako zápis
celého čísla uzavřeného v závorkách a ne jako zápis n-tice. Ale protože
k n-ticím nelze přičítat čísla, vedlo by to k chybě. Přidáním čárky Pythonu
říkáme, aby zápis v závorkách chápal jako zápis n-tice. Kdykoliv budete
chtít Pythonu dát najevo, že jednoprvková n-tice skutečně <em>je</em> n-ticí,
přidejte k zápisu čárku stejně, jako jsme to udělali zde.</p>

<p>VBScript ani JavaScript koncept n-tic nepodporují.</p>


<h4 id="dictionary">Slovník (vyhledávací tabulka)</h4>

<p>V tištěném slovníku je k jednotlivým slovům uveden jejich význam. Podobně
je tomu i u datového typu slovník <span class="trnote" title="Poznámka
překladatele">(anglicky <em>dictionary</em> [dykšnri])</span>, kde jsou k
jednotlivým klíčům přidruženy hodnoty. Přitom hodnoty mohou, ale nemusí, mít
podobu řetězce. Hodnotu můžeme získat tím, že klíč použijeme pro slovník
jako <em>index</em>. Narozdíl od tištěného slovníku, ani klíč nemusí být
znakovým řetězcem &mdash; ačkoliv řetězec se často používá. Může to být
hodnota libovolného neměnného typu <span class="trnote"
title="Poznámka&nbsp;překladatele">(immutable)</span>, včetně čísel a n-tic.
Hodnota, která je s klíčem svázaná, může být libovolného datového typu
jazyka Python. Slovníky jsou obvykle implementovány s využitím programovací
techniky známé jako <em>hash table</em><sup class="trnote" id="Bdata_hash"
title="Poznámka k překladu pojmu hash table" ><a
href="cztuttrn.html#Pdata_hash">[5]</a></sup> <span class="trnote"
title="Poznámka překladatele">[heš tejbl]</span>. Z tohoto důvodu se pro
datový typ slovník občas používá zkrácený pojem <em>hash</em>. <span
class="trnote" title="Poznámka překladatele">V české terminologii se spíše
využívá druhá část úplného pojmu, tedy tabulka</span>. Nemá to nic
společného s drogami. :-)</p>

<a name="addressbook"></a>

<p>K hodnotám ve slovníku můžeme přistupovat pouze prostřednictvím klíče,
takže do slovníku můžeme vložit pouze prvky s jednoznačným klíčem <span
class="trnote" title="Poznámka překladatele">(pro jeden klíč nelze současně
uchovávat dvě hodnoty)</span>. Slovníky jsou velmi užitečnými strukturami.
Python je poskytuje jako zabudovaný typ, ačkoliv v mnoha dalších jazycích
musíte použít odpovídající modul nebo si dokonce musíte typ slovník
naprogramovat sami. Slovníky můžeme používat mnoha způsoby a později si
ještě ukážeme řadu příkladů. V tomto okamžiku si ukažme alespoň to, jak v
jazyce Python slovník vytvoříme, jak do něj vložíme některé položky a jak je
opět zpřístupníme (přečteme):</p>

<pre>
>>> dct = {}
>>> dct['boolean'] = "Hodnota, která je buď True nebo False"
>>> dct['integer'] = "Celé číslo"
>>> print dct['boolean']
Hodnota, která je buď True nebo False
</pre>

<p>Všimněte si, že počáteční hodnotu slovníku nastavíme pomocí složených
závorek <span class="trnote" title="Poznámka překladatele">(zde prázdný
slovník &mdash; složené závorky jsou konstruktorem slovníku tak, jako jsou
hranaté závorky konstruktorem seznamu nebo kulaté závorky konstruktorem
n-tice)</span>. Poté používáme hranaté závorky pro přiřazování a čtení
hodnot.</p>

<p>Slovník můžeme naplnit počátečními hodnotami v okamžiku jeho vytvoření
podobně, jako jsme si to ukázali u seznamů:</p>

<pre>
>>> adresy = {
... 'Mirek' : ['Mirek', 'Kolbenova 15', 'Olomouc', '585 456 231'],
... 'Hanka' : ['Hanka', 'Ypsilantiho 42', 'Brno', '525 698 444']
... }
</pre>

<p>Klíč a hodnota se od sebe oddělují dvojtečkou a tyto páry se od dalších
oddělují čárkou. Tentokrát jsme náš adresář vytvořili jako slovník, kde jsme
jako klíč použili jméno a jako slovníkovou hodnotu ukládáme původní seznamy
s hodnotami. Místo zjišťování a používání číselného indexu nyní můžeme
potřebné informace získat na základě jména, a to takto:</p>

<pre>
>>> print adresy['Hanka']
['Hanka', 'Ypsilantiho 42', 'Brno', '525 698 444']
>>> print adresy['Mirek'][3]
585 456 231
</pre>

<p>V druhém případě jsme vrácený seznam dále indexovali, abychom obdrželi
jen telefonní číslo. Práci si můžeme dále zjednodušit zavedením pomocných
proměnných, které naplníme příslušnými hodnotami indexů:</p>

<pre>
>>> jmeno = 0
>>> ulice = 1
>>> mesto = 2
>>> tel = 3
</pre>

<p>Pokud nyní chceme zjistit, ve kterém městě bydlí Hanka, můžeme napsat:</p>

<pre>
>>> print adresy['Hanka'][mesto]
Brno
</pre>

<p>Povšimněte si, že zatímco jméno <code>'Hanka'</code> uvádíme v
apostrofech, protože jde o klíč typu řetězec, zápis <code>mesto</code>
uvádíme bez apostrofů, protože jde o jméno proměnné, které Python převede na
hodnotu indexu, kterou jsme do ní uložili (konkrétně 2). V tomto okamžiku
začíná náš adresář připomínat použitelnou databázovou aplikaci. Můžeme za to
poděkovat síle <span class="trnote"
title="Poznámka&nbsp;překladatele">datového typu</span> slovník. Moc práce
nám nedá ani doplnění kódu pro ukládání a načítání dat a přidání
dotazovacího řádku, přes který budeme moci určit, jaká data požadujeme. Při
probírání dalších témat této učebnice si to ukážeme.</p>

<p>Řada operací nad kolekcemi, se kterými jsme se do této chvíle seznámili,
není u slovníků &mdash; vzhledem k jejich vnitřní struktuře &mdash;
podporována. Nefunguje zde ani operátor zřetězení, operátor opakování, ani
operace <code>append()</code>. Abychom si mohli zpřístupnit hodnoty <span
class="trnote" title="Poznámka&nbsp;překladatele">všech</span> klíčů, máme k
dispozici operaci <code>keys()</code>. Ta vrací seznam všech klíčů, které
seznam používá. Pokud například chceme získat seznam všech jmen z našeho
adresáře, můžeme napsat:</p>

<pre>
>>> print adresy.keys()
['Hanka', 'Mirek']
</pre>

<p>Zde musíme upozornit na to, že klíče nejsou ve slovníku uloženy v pořadí,
v jakém byly vkládány. Z tohoto důvodu se vám může zdát, že se objevují v
nějakém divném pořadí, které se dokonce může během používání slovníku měnit.
Nedělejte si s tím starosti. Nic to nemění na skutečnosti, že
prostřednictvím klíčů můžete přistupovat k vašim datům. Vždy korektně
obdržíte tu správnou hodnotu.</p>


<h4>Slovníky ve VBScript</h4>

<p>V jazyce VBScript máme k dispozici objekt typu slovník, který má podobné
vlastnosti, jako slovník v jazyce Python, ale používá se trochu jinak.
Nejdříve musíme deklarovat proměnnou, která bude objekt zpřístupňovat. Poté
vytvoříme vlastní objekt typu slovník a nakonec do něj přidáme položky:</p>

<pre>
Dim dict               <span class="comment">' Vytvoříme proměnnou.</span>
Set dict = CreateObject("Scripting.Dictionary")
dict.Add "a", "Athens" <span class="comment">' Přidáme nějaké položky.</span>
dict.Add "b", "Belgrade"
dict.Add "c", "Cairo"
</pre>

<p>Povšimněte si, že ve funkci <code>CreateObject()</code> <span
class="trnote" title="Poznámka&nbsp;překladatele" >(tj. <em>vytvoř
objekt</em>)</span> uvádíme, že chceme vytvořit objekt
<code>"Scripting.Dictionary"</code>. To znamená, že chceme vytvořit objekt
<code>Dictionary</code> <span class="trnote"
title="Poznámka&nbsp;překladatele">(slovník)</span>, který je pro interpret
VBScript definován v modulu <code>Scripting</code>. Podrobnostmi se zatím
nebudeme zatěžovat. Dostaneme se k nim později, až se budeme zabývat
objekty. Doufám, že se vám alespoň vybavuje koncepce používání objektů
definovaných v modulech &mdash; zmínili jsme se o ní v podkapitole <a
href="cztutseq1.html">Jednoduché posloupnosti</a>. Povšimněte si také, že
při přiřazování objektu do proměnné musíme v jazyce VBScript použít klíčové
slovo <code>Set</code> <span class="trnote"
title="Poznámka&nbsp;překladatele">([set] = nastavit)</span>.</p>

<p>Nyní můžeme k datům přistupovat takto:</p>

<pre>
item = dict.Item("c")         <span class="comment">' Získání hodnoty položky.</span>
dict.Item("c") = "Casablanca" <span class="comment">' Změna hodnoty položky.</span>
</pre>

<p>Kromě toho máme k dispozici i operace k odstranění položky, k získání
seznamu všech klíčů, k otestování existence klíče a podobně.</p>

<p>Následující příklad představuje úplnou (i když trochu zjednodušenou)
podobu našeho adresáře, zapsaného v jazyce VBScript:</p>

<pre>
&lt;script type="text/vbscript">
Dim adresy
Set adresy = CreateObject("Scripting.Dictionary")
adresy.Add "Mirek", "Mirek, Kolbenova 15, Olomouc, 585 456 231"
adresy.Add "Hanka", "Hanka, Ypsilantiho 42, Brno, 525 698 444"

MsgBox adresy.Item("Hanka")
&lt;/script>
</pre>

<p>Pro uchovávání informací tentokrát místo seznamu používáme jediný
řetězec. Na ukázku zpřístupňujeme data záznamu s klíčem <code>Hanka</code> a
zobrazujeme je v dialogovém okně.</p>

<h4>Slovníky v JavaScript</h4>

<p>JavaScript nemá k dispozici svůj datový typ slovník. Pokud ovšem
používáte prohlížeč Internet Explorer, můžete použít objekt typu
<code>Scripting.Dictionary</code>, který je součástí VBScript. Bavili jsme
se o něm v předešlém textu. <span class="trnote"
title="Poznámka&nbsp;překladatele">I při použití z JavaScript</span> má
naprosto stejné vlastnosti. Je to tentýž typ objektu a proto se jím zde
nebudeme dále zabývat. Místo slovníků můžeme v JavaScript využít podobným
způsobem typ pole &mdash; viz níže.</p>


<blockquote><i>Pokud už toho začínáte mít plné zuby, můžete v tomto místě
přejít k&nbsp;<a href="cztutseq2.html">další kapitole</a>. Jakmile se začnete
setkávat s datovými typy o kterých jsme se ještě nezmínili, nezapomeňte se
vrátit zpět k této kapitole a dočíst si ji.</i></blockquote>


<h3>Další typy kolekcí</h3>

<h4>Pole nebo vektor</h4>

<p>Z hlediska historie počítačů patří pole k jednomu z prvních typů kolekcí.
V podstatě se jedná o seznam prvků, ke kterým lze snadno a rychle
přistupovat na základě indexu. Obvykle musíme předem určit, kolik prvků má
pole uchovávat. A právě pevná velikost je tím rysem, který se pole liší od
seznamu, o němž byla řeč výše. V Pythonu máme typ pole k dispozici
prostřednictvím modulu <code>array</code>. Používá se však velmi zřídka,
protože místo něj můžeme obvykle použít vestavěný typ seznam.</p>

<p class="trnote"><b>Poznámka překladatele:</b> Modul <code>array</code>
umožňuje v Pythonu definovat pole pouze pro prvky základních typů a to znak,
celé číslo a reálné číslo. Pro jeho použití se rozhodneme pravděpodobně jen
v případě, kdy nám velmi záleží na efektivnosti použití ve smyslu
výkonnějšího kódu.</p>

<p>V jazycích VBScript i JavaScript jsou pole k dispozici v podobě datového
typu. Podívejme se, jak se používají.</p>


<h4>Pole v jazyce VBScript</h4>

<p>V jazyce VBScript mají pole podobu kolekce dat s pevnou délkou. K prvkům
se přistupuje přes číselný index. Deklarace a přístup k prvkům se zapisují
takto:</p>

<pre>
Dim pole(42)       <span class="comment">' Pole s 43 prvky.</span>
pole(0) = 27       <span class="comment">' Indexovat se začíná od nuly.</span>
pole(1) = 49
promenna = pole(1) <span class="comment">' Čtení hodnoty.</span>
</pre>

<p>Povšimněte si, že používáme klíčové slovo <code>Dim</code>, které
vyjadřuje, že proměnné bude přidělen paměťový prostor. Tímto způsobem
interpretu VBScript řekneme, že chceme pracovat s uvedenou proměnnou. Pokud
na začátku skriptu uvedeme <code>OPTION&nbsp;EXPLICIT</code>, pak bude
VBScript vyžadovat, abychom klíčovým slovem <code>Dim</code> uvedli každou
proměnnou, kterou budeme chtít používat. Řada odborníků přes programování
pokládá tento přístup za žádoucí, protože věří, že vede k tvorbě
spolehlivějších programů. Povšimněte si také, že v deklaraci uvádíme hodnotu
posledního platného indexu &mdash; v našem případě <code>42</code>.
Indexovat se začíná od nuly, takže to znamená, že deklarujeme pole o&nbsp;43
prvcích.</p>

<p>Povšimněte si také, že u jazyka VBScript používáme pro deklaraci rozměru
pole a pro indexování kulaté závorky, nikoliv hranaté závorky, jak je tomu
u&nbsp;jazyka Python (viz dále), JavaScript <span class="trnote"
title="Poznámka&nbsp;překladatele">a u řady dalších programovacích
jazyků</span>.</p>

<p>Deklarovat můžeme i vícerozměrná pole &mdash; modelujeme datovou tabulku.
Podobný efekt jsme si ukázali v případě pythonovských seznamů. Pro náš
příklad adresáře bychom mohli psát:</p>

<pre>
Dim MojeTabulka(2, 3)              <span class="comment">' 3 řádky, 4 sloupce</span>
MojeTabulka(0,0) = "Mirek"         <span class="comment">' Naplníme položky pro Mirka.</span>
MojeTabulka(0,1) = "Kolbenova 15"
MojeTabulka(0,2) = "Olomouc"
MojeTabulka(0,3) = "585 456 231"
MojeTabulka(1,0) = "Hanka"         <span class="comment">' Naplníme položky pro Hanku.</span>
... a tak dále...
</pre>

<p>Bohužel však neexistuje způsob, jak bychom mohli předepsat naplnění
tabulky daty najednou &mdash; jak jsme to ukázali u pythonovských seznamů.
Položky tabulky musíme plnit jednu po druhé. Pokud zkombinujeme vlastnosti
polí a slovníků, dosáhneme pro verzi ve VBScript stejných užitkových
vlastností, jako tomu bylo u pythonovské verze:</p>

<pre>
&lt;script type="text/vbscript">
Dim adresy
Set adresy = CreateObject("Scripting.Dictionary")
Dim Mirek(3)
Mirek(0) = "Mirek"
Mirek(1) = "Kolbenova 15"
Mirek(2) = "Olomouc"
Mirek(3) = "585 456 231"
adresy.Add "Mirek", Mirek

MsgBox adresy.Item("Mirek")(3) <span class="comment">' Vytiskneme telefonní číslo.</Span>
&lt;/script>
</pre>

<p>Poslední věc, o které bych se chtěl zmínit, je skutečnost, že pole v
jazyce VBScript nemusí mít vůbec pevnou velikost. To ovšem neznamená, že si
můžeme dovolit jednoduše přidávat prvky způsobem, jak jsme to dělali u
seznamů. Změnu rozměrů pole musíme předepsat příkazem. Abychom to mohli
udělat, musíme pole deklarovat jako <em>dynamické pole</em>. Dosáhneme toho
jednoduše tím, že neuvedeme jeho rozměr:</p>

<pre>
&lt;script type="text/vbscript">
Dim DynPole()
ReDim DynPole(5)  <span class="comment">' Počáteční velikost.</span>
DynPole(0) = 42
DynPole(4) = 26
MsgBox "Před: " &amp; DynPole(4) <span class="comment">' Dokažme, že to funguje.</span>

<span class="comment">' Rozměr pole změníme na 21 prvků při zachování stávajících dat.</span>
ReDim Preserve DynPole(20)
DynPole(15) = 73
MsgBox "Po: " &amp; DynPole(4)   <span class="comment">' Hodnota byla zachována.</span>

<span class="comment">' Opět změníme rozměr (51 prvků), ale dojde ke ztrátě dat.</span>
ReDim DynPole(50)
MsgBox "A ještě... " &amp; DynPole(4) &amp; " Kam se poděla data?"
&lt;/script>
</pre>

<p>Z příkladu je zřejmé, že použití dynamického pole není tak příjemné, jako
použití seznamu, který automaticky přizpůsobuje svou délku. Na druhou stranu
má ale programátor k dispozici více prostředků pro jemné ovládání chování
programu. Uvedená úroveň kontroly nad chováním programu může mimo jiné
zvýšit bezpečnost, protože například některé viry mohou datové struktury s
dynamicky měnitelnou velikostí zneužít.</p>


<h4>Pole v jazyce JavaScript</h4>

<p>Typem <em>pole</em> (<code>Array</code>) je v jazyce JavaScript z mnoha
pohledů vyjádřeno něco jiného, než co bychom typicky čekali. To, čemu se zde
říká pole, ve skutečnosti vykazuje podivnou směsici vlastností seznamů,
slovníků a klasických polí. V nejjednodušším případě můžeme pole
10&nbsp;prvků nějakého typu deklarovat takto:</p>

<pre>
var pole = new Array(10);
</pre>

<p>Prvky poté můžeme naplnit a zpřístupňovat takto:</p>

<pre>
pole[4] = 42;
pole[7] = 21;
var hodnota = pole[4];
</pre>

<p>Ale typ hodnoty není u prvků pole v JavaScript omezen pouze na jediný. Do
každého z prvků pole můžeme přiřadit cokoliv:</p>

<pre>
pole[9] = "Krátký řetězec.";
var zprava = pole[9];
</pre>

<p>Při vytváření pole můžeme zadat dokonce seznam položek:</p>

<pre>
var jinePole = new Array("jedna", "dvě", "tři", 4, 5, 6);
hodnota = jinePole[3];
zprava = jinePole[0];
</pre>

<p>K dalším rysům polí v jazyce JavaScript patří to, že můžeme zjistit jejich
délku <span class="trnote" title="Poznámka&nbsp;překladatele">(počet
prvků)</span> použitím skryté vlastnosti nazvané <code>length</code> <span
class="trnote" title="Poznámka&nbsp;překladatele">(tj. délka)</span>:</p>

<pre>
var velikost = pole.length
</pre>

<p>Všimněte si, formát zápisu <code>jméno.vlastnost</code> připomíná volání
funkce z pythonovského modulu, ale bez závorek.</p>

<p>Jak je obvyklé <span class="trnote" title="Poznámka&nbsp;překladatele">i
v jiných jazycích</span>, pole se v JavaScript indexují od nuly. Nicméně v
roli indexu nemusí u JavaScript vystupovat jen číslo. Můžeme použít i
řetězec! V takovém případě se vlastnosti polí téměř shodují s vlastnostmi
slovníků. Pole můžeme zvětšit jednoduše tím, že přiřadíme nějakou hodnotu
prvku s indexem, který přesahuje aktuální maximální index. Následující
kousky kódu zmíněné vlastnosti ilustrují:</p>

<pre>
pole[42] = 7;
jinePole["něco"] = 42;
zprava = jinePole["něco"];
</pre>

<p>A nakonec se podívejme, jak by při využití polí v JavaScript vypadal náš
příklad adresáře:</p>

<pre>
&lt;script type="text/javascript">
var adresy = new Array();
adresy["Mirek"] = "Mirek, Kolbenova 15, Olomouc, 585 456 231";
adresy["Hanka"] = "Hanka, Ypsilantiho 42, Brno, 525 698 444";

document.write(adresy.Hanka);
&lt;/script>
</pre>

<p>Povšimněte si, že <span class="trnote"
title="Poznámka&nbsp;překladatele">v posledním příkazu</span> se ke klíči
chováme, jako kdyby to byla vlastnost objektu &mdash; podobně jako k výše
zmíněné vlastnosti <code>length</code>.</p>


<h4>Zásobník</h4>

<p>O zásobníku <span class="trnote" title="Poznámka překladatele">(anglicky
<em>stack</em> [stek])</span> můžeme uvažovat jako o na sobě naskládaných
podnosech v <span class="trnote" title="Poznámka
překladatele">samoobslužné</span> restauraci. Zaměstnanec restaurace přidává
čisté podnosy na vrchol sloupce podnosů a zákazníci je jeden po druhém z
vrcholu zase odebírají. Podnosy ve spodní části zásobníku se používají jako
poslední (a také nejméně). Datový zásobník se chová stejně: každou položku
buď do zásobníku vložíme <span class="trnote" title="Poznámka
překladatele">(operace se označuje <code>push</code> [puš])</span> nebo ji
ze zásobníku vybereme <span class="trnote" title="Poznámka
překladatele">(<code>pop</code>)</span>. Vybírá se vždy ta položka, která
byla do zásobníku vložena jako poslední. Tato vlastnost zásobníku je někdy
označována jako <em>Last In First Out</em> <span class="trnote"
title="Poznámka překladatele">(poslední dovnitř, první ven)</span> nebo
<em>LIFO</em>. Jednou z užitečných vlastností zásobníku je to, že jej můžeme
využít k obrácení pořadí položek seznamu tím, že jednotlivé položky seznamu
postupně vložíme do zásobníku a poté je postupně vybíráme z vrcholu
zásobníku a vkládáme do seznamu. Výsledkem bude počáteční seznam s obráceným
pořadím položek.</p>

<p>Typ zásobník není vestavěným typem jazyků Python, VBScript ani
JavaScript. Jeho chování musíme vyjádřit v kódu programu. Nejvhodnější bývá
obvykle vyjít z typu seznam, protože &mdash; jako v případě zásobníku
&mdash; počet položek seznamu může narůstat podle potřeby.</p>

<div class="trnote" id="noteStack">

<p><b>Poznámka překladatele k zásobníku:</b> Pokud použijeme seznam v roli
zásobníku, pak jeho metoda <code>append()</code> realizuje stejnou funkčnost
jako operace <code>push()</code>. Kromě toho Python pro seznam (ale i pro
další struktury) definuje metodu <code>pop()</code> s typickým významem.
Pokud nám vadí, že nemáme k dispozici přímo metodu <code>push()</code>, ale
stačí nám zavedení <em>nějakého</em> zásobníku a vlastních funkcí
<code>push()</code> a <code>pop()</code>, které pracují právě a jen s tímto
zásobníkem, není to ani tak složité &mdash; viz následující ukázka:</p>

<pre>
>>> zasobnik = []
>>> push = zasobnik.append
>>> pop = zasobnik.pop
>>> push
&lt;built-in method append of list object at 0x009C5B70>
>>> pop
&lt;built-in method pop of list object at 0x009C5B70>
>>> push(1)
>>> push(2)
>>> push(3)
>>> zasobnik
[1, 2, 3]
>>> print pop()
3
>>> zasobnik
[1, 2]
>>> pop()
2
>>> pop()
1
>>> zasobnik
[]
>>> pop()

Traceback (most recent call last):
  File "&lt;pyshell#13>", line 1, in -toplevel-
    pop()
IndexError: pop from empty list
>>>
</pre>

<p>Na prvním řádku vytvoříme prázdný seznam a na dalších dvou řádcích
navážeme jména <code>push</code> a <code>pop</code> na příslušný kód objektu
<code>zasobnik</code> (viz výpis na dalších řádcích). Pokud potom napíšeme
<code>push(1)</code>, provede se naprosto stejná činnost, jako kdybychom
provedli <code>zasobnik.append(1)</code>. Povšimněte si také, že pokus
o <code>pop()</code> nad prázdným zásobníkem nelze tolerovat &mdash; je
vyvolána výjimka.</p>

<p>Jakmile se naučíte pracovat s třídami a objekty, zjistíte, že není
obtížné vytvořit pro zásobník vlastní třídu, která bude zveřejňovat jen
požadované operace <code>push()</code> a <code>pop()</code>, případně další,
dle vaší volby. Pokud se vám nastíněné, čistě objektové řešení zdá při
vašich momentálních schopnostech a dovednostech nedostižné, <em>nepropadejte
panice</em>. Je to naprosto normální.</p>

</div>

<h4>Multimnožina</h4>

<p>Multimnožina <span class="trnote" title="Poznámka překladatele">(anglicky
<em>bag</em>)</span> představuje kolekci položek, u kterých není definováno
pořadí a která může obsahovat více položek se stejnou hodnotou. Tento datový
typ obvykle poskytuje operace pro přidávání, vyhledávání a odstraňování
položek. V našich jazycích se pro tento účel používají seznamy.</p>


<h4>Množina</h4>

<p>Množina <span class="trnote" title="Poznámka překladatele">(anglicky
<em>set</em>)</span> může uchovávat pouze jeden výskyt každé položky.
Obvykle můžeme testovat, zda daná položka je či není prvkem množiny. Položky
můžeme do množiny přidávat a odstraňovat. Dvě množiny můžeme spojovat
dohromady různými způsoby, které známe z matematické teorie množin (jako je
například sjednocení, průnik, atd.). Jazyky VBScript a JavaScript datový typ
množiny přímo nepodporují, ale vlastnosti množin můžeme docela snadno
napodobit použitím slovníků.</p>

<p>V jazyce Python jsou od verze 2.3 množiny dostupné v podobě modulu
<code>sets</code>. Jeho implementace se považuje za experimentální. Od verze
2.4 se podpora množin stane součástí jádra jazyka. <span
class="trnote">Poznámka&nbsp;překladatele: Zabudování do jádra jazyka bylo
potvrzeno při vydání alfa verze Python 2.4. Množiny jsou implementovány v
jazyce C, takže budou efektivnější, než v Python 2.3.</span></p>

<p>Základní použití množin (Python 2.3) vypadá nějak takto:</p>

<pre>
>>> import sets
>>> A = sets.Set()        <span class="comment"># Vytvoř prázdnou množinu.</span>
>>> B = sets.Set([1,2,3]) <span class="comment"># Vytvož 3prvkovou množinu.</span>
>>> C = sets.Set([3,4,5])
>>> D = sets.Set([6,7,8])
>>> <span class="comment"># Teď si vyzkoušíme nějaké operace.</span>
>>> B.union(C)                     <span class="comment"># sjednocení</span>
Set([1,2,3,4,5])
>>> B.intersection(C)              <span class="comment"># průnik</span>
Set([3])
>>> B.issuperset(sets.Set([2]))    <span class="comment"># je nadmnožinou</span>
True
>>> sets.Set([3]).issubset(C)      <span class="comment"># je podmnožinou</span>
True
>>> C.intersection(D) == A         <span class="comment"># rovnost množin</span>
True
</pre>

<p>Výčet množinových operací je mnohem širší, ale pro tento okamžik považuji
výše uvedené za dostačující.</p>


<h4>Fronta</h4>

<p>Fronta <span class="trnote" title="Poznámka překladatele">(anglicky
<em>queue</em> [kjú])</span> se podobá zásobníku ale s tím rozdílem, že
první položka, která se dostane dovnitř, je zároveň první položkou, která se
dostane ven. Tomuto chování se říká <em>First In First Out</em> <span
class="trnote" title="Poznámka překladatele">(první dovnitř, první
ven)</span> nebo <em>FIFO</em>. K implementaci fronty se obvykle využívá
pole nebo seznam.</p>

<p>Existuje celá řada dalších datových typů s vlastnostmi kolekce, ale ty, o
kterých jsme se zmínili, patří mezi hlavní, se kterými se pravděpodobně
setkáte. (V této učebnici se ve skutečnosti budeme zabývat jen některými z
výše zmíněných, ale o dalších typech se můžete dozvědět v různých článcích a
v diskusních skupinách věnovaných programování.)</p>

<p class="trnote" id="noteQueue"><b>Poznámka překladatele k frontě:</b>
Podobně, jako v případě zásobníku, můžeme i frontu v jazyce Python jednoduše
implementovat s využitím operací nad seznamem. Pro operaci zařazení do
fronty opět použijeme metodu <code>append()</code> (této operaci se někdy
říká <code>queueUp()</code> nebo <code>pushBack()</code>). Pro operaci
výběru ze začátku fronty můžeme použít <code>pop(0)</code>. Parametr říká, z
kterého místa prvek odstraňujeme. V případě zásobníku jsme parametr
nezadávali, takže se použila jeho implicitní hodnota <code>-1</code> s
významem <em>index posledního prvku</em>.</p>


<h3>Soubory</h3>

<p>Jako uživatelům počítače by vám pojem soubor měl být dobře známý, protože
soubory tvoří základ pro téměř vše, co s počítači děláme. Zjištění, že
většina programovacích jazyků poskytuje speciální datový typ <em>file</em>
<span class="trnote" title="Poznámka překladatele">(soubor)</span>, by vás
tedy nemělo překvapit. Soubory a jejich zpracování jsou natolik důležité, že
se jimi budeme zabývat až o něco později, v samostatné kapitole <span
class="trnote" title="Poznámka&nbsp;překladatele">(<a
href="cztutfiles.html">Práce se soubory</a>)</span>.</p>


<h3>Datum a čas</h3>

<p>Pro datum a čas bývá často vyhrazen samostatný datový typ. Někdy se pro
jejich reprezentaci jednoduše používá velké číslo (typicky se jím vyjadřuje
počet sekund, které uplynuly od zvoleného pevného data a času). Jindy se pro
jejich uložení používá datový typ, který označujeme jako <em>složený</em> a
který bude popsán v následujícím textu. Takový datový typ obvykle umožňuje
snadnější zjištění měsíce, dne, hodiny atd. V dalších tématech se stručně
seznámíme s používáním pythonovského modulu <code>time</code>. Jazyky
VBScript i JavaScript používají pro práci s časem své vlastní mechanismy,
ale těmi se zabývat nebudeme.</p>


<h3 id="class">Složený, uživatelem definovaný typ</h3>

<p>Někdy se ukáže, že výše popsané základní <span class="trnote"
title="Poznámka překladatele">jednoduché</span> typy nevyhovují a to ani po
jejich uspořádání s využitím kolekcí. Někdy prostě chceme sdružit skupinu
<span class="trnote" title="Poznámka&nbsp;překladatele">různorodých</span>
datových položek dohromady a pracovat s nimi jako s celkem. Příkladem může
být položka adresy: číslo domu, ulice, město a směrovací číslo.</p>

<p>Většina programovacích jazyků dovoluje podobné informace sdružit to
takzvaného <em>záznamu</em> <span class="trnote"
title="Poznámka&nbsp;překladatele" >(anglicky <em>record</em>
[rikód])</span> nebo <em>struktury</em> <span class="trnote"
title="Poznámka&nbsp;překladatele">(<em>structure</em> [strakčr])</span>
nebo její modernější, objektově orientované podoby, <em>třídy</em> <span
class="trnote" title="Poznámka&nbsp;překladatele">(<em>class</em>
[klás])</span>.</p>


<h4>VBScript</h4>

<p>V jazyce VBScript vypadá definice takového záznamu následovně:</p>

<pre>
Class Adresa
     Public CisloDomu
     Public Ulice
     Public Mesto
     Public PSC
End Class
</pre>

<p>Klíčové slovo <code>Public</code> zajistí přístupnost dat v celém
zbytku programu. Datové položky mohou být označeny také jako
<code>Private</code>, ale k tomu se v této učebnici dostaneme až
později.</p>


<h4>Python</h4>

<p>Zápis stejného případu v jazyce Python se příliš neliší:</p>

<pre id="address">
>>> class Adresa:
...     def __init__(self, Dum, Ul, Mesto, PSC):
...         self.CisloDomu = Dum
...         self.Ulice = Ul
...         self.Mesto = Mesto
...         self.PSC = PSC
...
</pre>

<p>Zápis se vám může zdát poněkud záhadný, ale nemějte obavy. V kapitole
o&nbsp;<a href="cztutclass.html">objektově orientovaném programování</a> si
vysvětlíme, co znamená <code>def&nbsp;__init__(...)</code> a
<code>self</code>. Povšimněme si jen toho, že identifikátor
<code>__init__</code> obsahuje na obou stranách <em>dvojici znaků
podtržení</em>. Jde o pythonovskou konvenci, o které se zmíníme později.
Když někteří lidé zkoušeli zapsat uvedený příklad na vyzývacím řádku
interpretu jazyka Python, měli s tím určité poblémy. Na konci této kapitoly
naleznete zvýrazněný úsek textu, který části příkladu podrobněji vysvětluje.
Ale pokud vám to víc vyhovuje, můžete s jeho studiem počkat až na pozdější
dobu, až se v průběhu kurzu dozvíte všechny podrobnosti. Pokud se pokoušíte
o zapsání příkladu na vyzývací řádek <span class="trnote"
title="Poznámka&nbsp;překladatele">(anglicky <em>prompt</em>)</span> jazyka
Python, ujistěte se, že jste použili stejný způsob odsazení. Jak uvidíme
později, Python je v otázce odsazování úrovní <span class="trnote"
title="Poznámka&nbsp;překladatele">zdrojového textu</span> velmi
puntičkářský.</p>

<p>Hlavní poznatek, který byste si měli z tohoto příkladu odnést, by měl být
ten, že lze sloučit několik kousků dat do jediné struktury.</p>


<h4>JavaScript</h4>

<p>V jazyce JavaScript se pro definici struktury používá poněkud podivné
jméno, a to <code>function</code>. Funkce si obvykle spojujeme s operacemi,
ne s datovými kolekcemi, ale v případě jazyka JavaScript se funkce používají
i pro tento účel. Vytváření objektu Adresa se v jazyce JavaScript zapisuje
takto:</p>

<pre>
function Adresa(Dum, Ul, Mesto, PSC)
{
    this.CisloDomu = Dum;
    this.Ulice = Ul;
    this.Mesto = Mesto;
    this.PSC = PSC;
}
</pre>

<p>Zopakujme to ještě jednou. Výsledkem je skupina datových položek, na
kterou se díváme jako na jeden celek.</p>


<h3>Přístup ke složeným datovým typům</h3>

<p>Hodnotu složeného datového typu můžeme také přiřadit do proměnné. Ale
abychom mohli přistupovat k jednotlivým <em>složkám</em> hodnoty složeného
typu, musíme použít speciální zápis, který je určen konkrétním programovacím
jazykem. Obvykle se k zápisu používá tečka.</p>

<h4>V jazyce VBScript</h4>

<p>Pokud budeme uvažovat výše uvedenou třídu Adresa, pak bychom v jazyce
VBScript mohli napsat:</p>

<pre>
Dim Adr
Set Adr = New Adresa

Adr.CisloDomu = 7
Adr.Ulice = "Havlíčkova"
Adr.Mesto = "Staré Město"
Adr.PSC = "790 58"

MsgBox Adr.Ulice &amp; " " &amp; Adr.CisloDomu &amp; ", " &amp; Adr.Mesto
</pre>

<p>Nejdříve jsme použitím klíčového slova <code>Dim</code> vyhradili prostor
pro novou proměnnou <code>Adr</code>. S využitím <code>Set</code> vytvoříme
novou <em>instanci</em> třídy <code>Adresa</code>. Poté do položek instance
nového objektu adresy přiřadíme hodnoty a nakonec obsah zobrazíme v
dialogovém okně pro zprávu (message box).</p>


<h4>V jazyce Python</h4>

<p>V jazyce Python &mdash; za předpokladu, že jste již napsali výše uvedenou
definici třídy Adresa &mdash; můžeme psát:</p>

<pre>
Adr = Adresa(7, "Havlíčkova", "Staré Město", "790 58")
print Adr.Ulice, Adr.CisloDomu
print Adr.Mesto
</pre>

<p>Tím se vytvoří instance našeho typu <code>Adresa</code> a přiřadí se do
proměnné <code>Adr</code>. V Pythonu můžeme předat hodnoty položek v
okamžiku vytváření <em>objektu</em>. <span class="trnote"
title="Poznámka&nbsp;překladatele">(Konstruktoru objektu lze předávat
parametry.)</span> Poté s využitím tečkového operátoru tiskneme složky
<code>CisloDomu</code>, <code>Ulice</code> a <code>Mesto</code>. Můžete,
samozřejmě, vytvořit více instancí třídy <code>Adresa</code> a do každé z nich přiřadit
jiné číslo domu, ulici, a tak dále. Vyzkoušejte si to. Tušíte, jak byste
mohli třídu <code>Adresa</code> využít pro náš příklad adresáře?</p>


<h4>A ještě v jazyce JavaScript</h4>

<p>Mechanismus používaný v jazyce JavaScript se velmi podobá mechanismům v
ostatních jazycích. Přesto zde můžeme nalézt &mdash; jak uvidíme za chvíli
&mdash; pár zvláštností. Nicméně, základní mechanismus je jednoduchý:</p>

<pre>
var Adr = new Adresa(7, "Havlíčkova", "Staré Město", "790 58");
document.write(Adr.Ulice + " " + Adr.CisloDomu + ", " + Adr.Mesto);
</pre>

<p>K zpřístupnění položek můžeme použít ještě jeden mechanismus, kdy se na
objekt díváme jako na slovník a jméno pole používáme jako klíč:</p>

<pre>
document.write(Adr['Ulice'] + " " + Adr['CisloDomu'] + " " + Adr['Mesto']);
</pre>

<p>Jediný rozumný důvod k použití tohoto způsobu, který mě napadá, je ten,
že jména položek získáváte <span class="trnote"
title="Poznámka&nbsp;překladatele">za běhu programu</span> v podobě řetězce
&mdash; třeba jako výsledek čtení ze souboru nebo jako vstup zadaný
uživatelem (viz dále).</p>


<h3 id="object">Operace definované uživatelem</h3>

<p>V některých programovacích jazycích mohou mít uživatelské datové typy
<span class="trnote" title="Poznámka překladatele">uživatelem</span>
definovány i operace. Tento rys patří k základům takzvaného <em>objektově
orientovaného programování</em>. Tomuto tématu bude věnována <a
href="cztutclass.html">samostatná kapitola</a>, ale v tomto okamžiku si
uveďme alespoň to, že objekt se v podstatě tvořen datovými složkami a
operacemi definovanými nad těmito datovými složkami. Vše je zabaleno
dohromady a vystupuje to jako jediný celek. Python objekty široce využívá ve
své standardní knihovně modulů a současně nám jako programátorům umožňuje
vytváření svých vlastních typů objektů.</p>

<p>Operace objektu se zpřístupňují stejným způsobem, jako datové členy
uživatelsky definovaného typu &mdash; prostřednictvím tečkového operátoru
&mdash;, ale jinak vypadají jako funkce. Těmto zvláštním funkcím se říká
<em>metody</em>. Už jsme se s tím setkali u seznamu v podobě operace
<code>append()</code>. Vzpomeňte si, že abychom ji mohli použít, museli jsme
volanou funkci spojit se jménem proměnné:</p>

<pre>
>>> seznam = []       <span class="comment"># prázdný seznam</span>
>>> seznam.append(42) <span class="comment"># volání metody objektu seznam</span>
>>> print seznam
[42]
</pre>

<p>Pokud je typ objektu &mdash; říká se mu <em>třída</em> &mdash; definován
uvnitř nějakého modulu, musíme tento modul importovat (jako jsme si již
dříve ukázali v případě modulu <code>sys</code>). Jménu objektového typu
předřadíme jméno modulu a vytvoříme instanci třídy <span class="trnote"
title="Poznámka překladatele">(tj. objekt)</span>, který bude uložen v
proměnné. Tu již můžeme používat aniž bychom uváděli jméno modulu.</p>

<p>Ukážeme si to na fiktivním modulu <code>meat</code>, který definuje třídu
<code>Spam</code><sup class="trnote"><a href="cztuttrn.html#Pdata_spam"
id="Bdata_spam" title="Co to je Spam?">[6]</a></sup>. Importujeme uvedený
modul, vytvoříme instanci třídy Spam, dáme jí jméno <code>mySpam</code> a poté
použijeme <code>mySpam</code> pro přístup k jejím operacím a datovým složkám
takto:</p>

<pre>
>>> import meat
>>> mySpam = meat.Spam()     <span class="comment"># vytvoření instance, užití jména modulu a třídy</span>
>>> mySpam.slice()           <span class="comment"># užití operace objektu třídy Spam (ukrojit)</span>
>>> print mySpam.ingredients <span class="comment"># přístup k datům objektu</span>
{'Pork': '40%', 'Ham': '45%', 'Fat': '15%'}
</pre>

<p>Na prvním řádku importujeme do našeho programu modul nazvaný
<code>meat</code> (jde o fiktivní, neexistující modul). Na druhém řádku
používáme modul <code>meat</code> k vytvoření instance třídy <code>Spam</code>
tím, že <span class="trnote" title="Poznámka&nbsp;překladatele">identifikátor
třídy</span> použijeme, jako kdyby se jednalo o volání funkce. Na třetím řádku
používáme jednu z operací třídy <code>Spam</code>, a sice
<code>slice()</code>. K objektu <code>mySpam</code> se chováme, jako kdyby to
byl modul a operace jako kdyby byla funkcí definovanou uvnitř modulu. Nakonec
zpřístupňujeme některá data uchovávaná uvnitř objektu <code>mySpam</code>.
Opět používáme zápis, který se podobá práci s modulem.</p>

<p>Pokud pomineme nutnost vytvoření instance objektu, pak neexistuje
podstatný rozdíl mezi používáním objektů, které moduly poskytují, a funkcí,
které se v modulech nacházejí. O jménu objektu můžeme uvažovat jako o
visačce, která drží odpovídající funkce a proměnné seskupené dohromady.</p>

<p>Jiný způsob v pohledu na věc je takový, že objekty reprezentují skutečné
věci v našem světě, se kterými můžeme &mdash; jako programátoři &mdash; něco
dělat. Právě toto je pohled, který původně vedl ke zrození myšlenky
používání objektů v programech. Týkal se zápisu počítačové simulace situací
v reálném světě.</p>

<p>S objekty můžeme pracovat i v jazycích VBScript i JavaScript. Ve výše
uvedených příkladech s typem Adresa jsme ve skutečnosti nedělali nic jiného.
Definovali jsme třídu, vytvořili jsme její instanci a proměnnou, přes kterou
můžeme zpřístupňovat vlastnosti instance. Znovu si projděte předchozí text a
zaměřte se na to, co jsme si řekli o třídách a objektech. Zamyslete se nad
tím, že třídy poskytují mechanismus pro definici nových datových typů tím,
že svazují dohromady data a operace.</p>


<h4>Specifické operátory jazyka Python</h4>

<p>Mým prvotním cílem, kterému jsem zasvětil tuto učebnici, je naučit vás
programovat. A ačkoliv zde používám jazyk Python, nevidím žádný důvod, proč
byste si po přečtení tohoto textu nemohli nastudovat něco o jiném jazyce a
zaměřit se na něj. Dokonce očekávám, že právě toto uděláte, protože
neexistuje jediný programovací jazyk, který se hodí na všechno. Python není
výjimkou. Na druhou stranu, protože jsem si vytknul takový cíl, nevěnuji se
výuce všech rysů jazyka Python, ale zaměřuji se na ty, které můžete obvykle
nalézt i u jiných jazyků. Výsledkem tohoto rozhodnutí je skutečnost, že
některé specifické rysy jazyka Python &mdash; i když jsou poměrně mocné
&mdash; nepopisuji vůbec. Patří mezi ně i speciální operátory.
U&nbsp;většiny programovacích jazyků můžeme nalézt některé operace, které
jiné jazyky nepodporují. Často jsou to právě tyto <em>unikátní</em>
operátory, které dávají novým programovacím jazykům vzniknout a které jsou
určitě důležitým faktorem určujícím jak populárním se jazyk stane.</p>

<p>Python například podporuje takové netradiční operace, jako jsou získání
výřezu vnitřní části seznamu (nebo řetězce nebo n-tice <span class="trnote"
title="Poznámka&nbsp;překladatele"> &mdash; anglicky <em>slicing</em>
[slajsing]</span>, zapisujeme <code>spam[X:Y]</code>) a operaci přiřazení
n-tice (<code>X, Y = 12, 34</code>), které nám umožňuje zapsat přiřazení
více hodnot více proměnným najednou. <span class="trnote" title="Poznámka
překladatele">(Posledně uvedenému příkazu se říká také násobný nebo
paralelní přiřazovací příkaz.)</span></p>

<p>Python poskytuje i prostředek k provedení požadované operace nad každým
členem kolekce &mdash; slouží k tomu funkce <code>map()</code>. Takových
věcí je mnohem více. Často se říká, že "Python dostáváte i s přiloženými
bateriemi". Pokud se budete chtít dozvědět, jak tyto specifické operace
jazyka Python fungují, budete muset nahlédnout do jeho dokumentace.</p>

<p>Nakonec bych chtěl upozornit na to, že ačkoliv říkám, že tyto operace
jsou specifické pro jazyk Python, neříkám, že je nemůžete nalézt v žádném
jiném jazyce. Spíše chci říci, že je v každém jazyce nenaleznete
<em>všechny</em>. Operace, kterými se zabýváme v hlavním textu, jsou v
nějaké podobě obecně dostupné ve všech moderních programovacích
jazycích.</p>

<p>Tím uzavíráme náš pohled na programátorské suroviny. Nyní se posuňme k
více vzrušujícímu tématu postupů <span class="trnote"
title="Poznámka překladatele">(programovacích technik)</span> a uvidíme,
jak můžeme zmíněné suroviny využít.</p>


<div class="details">
<h4>Podrobněji vysvětlený příklad Adresa</h4>

<p>Jak už jsem řekl dříve, detaily tohoto příkladu budou vysvětleny později.
Někteří čtenáři však měli se zprovozněním pythonovského příkladu problémy.
Tato poznámka vysvětluje jeho kód řádek po řádku. Úplný zápis příkladu
vypadá následovně:</p>

<pre>
>>> class Adresa:
...     def __init__(self, Dum, Ul, Mesto, PSC):
...         self.CisloDomu = Dum
...         self.Ulice = Ul
...         self.Mesto = Mesto
...         self.PSC = PSC
...
>>> Adr = Adresa(7, "Havlickova", "Stare Mesto", "790 58")
>>> print Adr.CisloDomu, Adr.Ulice
</pre>

<p>Zde je vysvětlení:</p>

<pre>
>>> class Adresa:
</pre>

<p>Příkaz <code>class</code> (třída) říká, že hodláme definovat nový typ,
který se v tomto případě nazývá <code>Adresa</code>. Dvojtečka vyjadřuje
skutečnost, že všechny následující odsazené řádky budou součástí definice
třídy. Definice končí prvním neprázdným řádkem, který není vůči prvnímu
řádku definice třídy Adresa odsazen. Pokud používáte prostředí IDLE, pak si
můžete všimnout, že editor <span class="trnote" title="Poznámka překladatele"
>po stisku klávesy Enter</span> další řádek automaticky odsadil. Pokud jste
Python spustili z příkazového řádku okna MS-DOS, pak na vyzývacím řádku
překladače jazyka Python musíte provést požadované odsazení ručně<span
class="trnote" title="Poznámka překladatele">, vložením mezer</span>.
Překladači jazyka Python nezáleží na tom, o kolik pozic odsadíte, pokud
budete odsazovat pořád o stejnou hodnotu.</p>

<pre>
...     def __init__(self, Dum, Ul, Mesto, PSC):
</pre>

<p>První položkou uvnitř definice naší třídy je to, čemu říkáme <em>definice
metody</em>. Důležitým detailem je to, že jméno <span class="trnote"
title="Poznámka&nbsp;překladatele">konkrétně této</span> metody začíná a
končí dvojicí znaků podtržení. Jde o konvenci pro zápis jmen, kterým Python
přisuzuje zvláštní význam. Tato konkrétní metoda se nazývá
<code>__init__</code> a jde o speciální operaci, kterou Python <span
class="trnote" title="Poznámka&nbsp;překladatele">automaticky</span> provede
hned po vytvoření instance naší nové třídy &mdash; jak uvidíme za chvíli.
Dvojtečka, tak jako v předchozím případě, jednoduše překladači jazyka Python
říká, že následující skupina odsazených řádků tvoří definici této
metody.</p>

<pre>
...         self.CisloDomu = Dum
</pre>

<p>Tento řádek a tři následující řádky přiřazují hodnoty vnitřním <span
class="trnote" title="Poznámka překladatele">(datovým)</span> položkám
našeho objektu. Jsou odsazeny vůči řádku s příkazem <code>def</code>,
abychom překladači jazyka Python naznačili, že představují skutečnou
definici těla operace <code>__init__</code>. Prázdný řádek říká interpretu
jazyka Python, že definice třídy byla ukončena, takže Python znovu zobrazí
vyzývací řádek ve tvaru '<code>>>>&nbsp;</code>'.</p>

<pre>
>>> Adr = Adresa(7, "Havlickova", "Stare Mesto", "790 58")
</pre>

<p>Tento řádek zajistí vytvoření nové instance <span class="trnote"
title="Poznámka překladatele">(tj. nového objektu)</span> typu
<code>Adresa</code> a Python <span class="trnote" title="Poznámka překladatele"
>automaticky</span> použije výše definovanou operaci <code>__init__</code> k
přiřazení zadaných hodnot do vnitřních položek <span class="trnote"
title="Poznámka překladatele">objektu</span>. Vytvořená instance je
přiřazena do proměnné <code>Adr</code> stejným způsobem, jako by byla
přiřazena hodnota jiného datového typu.</p>

<pre>
>>> print Adr.CisloDomu, Adr.Ulice
</pre>

<p>Nyní tiskneme hodnoty dvou vnitřních položek objektu, které jsme
zpřístupnili pomocí tečkového operátoru.</p>

<p>Jak jsem již řekl, dalšími detaily se budeme v této učebnici zabývat
později. Klíčový poznatek, který byste si z tohoto měli odnést je, že nám
Python umožňuje vytvořit náš vlastní datový typ a používat ho stejně snadno
jako vestavěné typy.</p>
</div>

<div class="remember">
<p class="title">Zapamatujte si</p>
<ul>

<li>Přes proměnné se odkazujeme na data. Někdy musí být proměnné deklarovány
před tím, než je definována jejich hodnota.</li>

<li>Hodnoty dat mohou být různých typů. Operace, které lze úspěšně
použít, souvisí s typem dat, se kterými pracujeme.</li>

<li>K jednoduchým datovým typům patří typy pro znakové řetězce<sup
class="trnote"><a href="cztuttrn.html#Pdata_string" id="Bdata_string"
title="Jiný&nbsp;názor..." >[7]</a></sup>, čísla a boolovské neboli
pravdivostní hodnoty.</li>

<li>Ke složeným datovým typům můžeme řadit kolekce, soubory, datum <span
class="trnote" title="Poznámka překladatele">(v podobě záznamu se složkami
pro den, měsíc, atd.)</span> a uživatelem definované datové typy.</li>

<li>Každý programovací jazyk definuje řadu operátorů. Součástí jeho studia
je vždy seznámení se s jeho datovými typy a s operacemi, které jsou pro tyto
typy k dispozici.</li>

<li>Stejný operátor (například sčítání) může být užíván pro různé datové
typy, ale výsledky se nemusí shodovat nebo dokonce spolu nemusí nijak
souviset. <span class="trnote" title="Poznámka překladatele">(Viz příklad
sčítání čísel a 'sčítání' řetězců.)</span></li>

</ul>
</div>

<div class="foot">
<p class="navig">[
<a href="cztutseq1.html" title="Jednoduché posloupnosti">předchozí</a> |
<a href="cztutcont.html">obsah</a> |
<a href="cztutseq2.html" title="Další posloupnosti">další</a>
]</p>

<p class="note">Pokud vás napadne, co by se dalo na překladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztutdata.html,v 1.14 2005/09/03 13:07:39 petr Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka'
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20')
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script>

Tím budou do dopisu automaticky vloženy informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztutdata.html,v 1.14 2005/09/03 13:07:39 petr Exp $</p>
</div>
</body>
</html>


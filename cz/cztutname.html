<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se nauèit programovat: Prostory jmen</title>
</head>
<body>

<p class="ir">Níe uvedenı text pochází z prvního vydání. Nad tímto textem 
se nachází aktuální stav po revizi smìøující k druhému vydání.</p>

<h2>Prostory jmen</h2>

<h3>Úvod</h3>

<p>U slyším, jak se ptáte&hellip; Co to je ten <em>prostor jmen</em>
(namespace)? No, dá se to tìko vysvìtlit. Ne proto, e by to bylo nìjak
zvláš komplikované, ale spíš proto, e se k tomu kadı jazyk staví trochu
jinak. Samotnı koncept je docela pøímoèarı. Prostor jmen je prostor nebo
oblast uvnitø programu, kde je jméno (promìnné, tøídy, atd.) platné.</p>

<p>Døívìjší programovací jazyky (jako tøeba BASIC) pracovaly pouze s
<em>globálními promìnnımi</em>, to znamená s takovımi promìnnımi, které byly
vidìt z celého programu &mdash; dokonce uvnitø funkcí. To èinilo
udrovatelnost programù velmi obtínou, protoe pro kadı kousek programu
bylo velmi snadné zmìnit nìjakou promìnnou, ani by se to ostatní èásti
programu nìjak dozvìdìly. Tomuto jevu se øíká <em>vedlejší efekt</em>.
Novìjší jazyky (vèetnì moderních verzí jazyka BASIC) tento problém obcházejí
zavedením prostorù jmen. (Jazyk C++ jde v tomto smìru do extrému tím, e
umoòuje programátorovi vytvoøit svùj vlastní prostor jmen kdekoliv uvnitø
programu. To ocení zvláštì tvùrci knihoven, kteøí chtìjí dosáhnout
jednoznaènosti jmen svıch funkcí i v pøípadì, kdy se souèasnì pouijí
knihovny jinıch tvùrcù.)</p>

<h3>Jak to øeší Python?</h3>

<p>V systému Python vytváøí kadı modul svùj vlastní prostor jmen. Pokud
chceme pouívat jména jeho èástí, musíme jim buï pøedøadit jméno modulu,
nebo musíme explicitnì importovat poadovaná jména dovniø prostoru jmen
našeho modulu. Není to pro nás nic nového. U jsme to dìlali pøi práci s
moduly <code>sys</code> a <code>string</code>. V urèitém smyslu vytváøí svùj
prostor jmen i definice tøídy. Take pokud chceme zpøístupnit metodu nebo
vlastnost tøídy, musíme nejdøíve pouít jméno instance nebo tøídy.</p>

<p>V Pythonu existují jen 3 prostory jmen (nebo <em>rozsahy platnosti</em>
&mdash; scopes):</p>

<ol>
<li>Lokální rozsah &mdash; jména definovaná uvnitø funkce nebo metody.</li>
<li>Rozsah v rámci modulu &mdash; jména definovaná uvnitø souboru <span
    class="trnote" title="Poznámka pøekladatele">modulu</span>.</li>
<li>Zabudovaná jména &mdash; jména definovaná uvnitø samotného systému
    Python, která jsou pøístupná vdy.</li>
</ol>

<p>No dobrá. Ale jak to vše dáme dohromady, kdy promìnné v rùznıch
prostorech jmen mají stejné jméno? A nebo, jak se odkazujeme na jméno, které
se nenachází v aktuálním prostoru jmen? Podívejme se nejdøíve na první
pøípad: Pokud se funkce odvolává na promìnnou nazvanou <code>X</code> a
uvnitø funkce existuje nìjaká promìnná <code>X</code> (tj. uvnitø prostoru s
lokálními promìnnımi), pak to bude právì tato lokální promìnná, kterou
Python uvidí a pouije. Je vìcí programátora, aby se vyhnul støetùm jmen,
kdy má nìjaká lokální promìnná stejné jméno jako promìnná modulu a kdy
bychom mohli chtít zpøístupnit obì najednou. Existence lokální promìnné v
takovém pøípadì maskuje existenci globální promìnné.</p>

<p>Obecnì bychom mìli globální promìnné pouívat co nejménì. Obvykle bıvá
lepší, kdy <span class="trnote" title="Poznámka pøekladatele">bìnou,
lokální</span> promìnnou pøedáváme jako parametr <span class="trnote"
title="Poznámka pøekladatele">volané funkce</span> a vrací se nám s
modifikovanım obsahem.</p>

<div class="trnote" id="globvar">

<p><b>Poznámka pøekladatele ke globálním promìnnım:</b> Z pohledu
zaèáteèníka se mùe zdát pouívání globálních promìnnıch velmi vıhodné.
Jednoduše pøece uvedeme jméno promìnné, které je známé ve všech místech
programu! V èem je problém? Postupnì zjistíte, e tìch problémù mùe bıt
hned nìkolik. Zdánlivá jednoduchost mùe pozdìji vìci zkomplikovat:</p>

<ul>
<li>Pøi zvìtšování programu pouíváme èím dál víc jmen a zaènou se nám 
  špatnì vymıšlet. Pokud chceme jméno promìnné pozdìji zmìnit, musíme je 
  mìnit na mnoha rùznıch místech. Pro vhodnı textovı editor to nemusí bıt
  velkı problém, ale...</li>
  
<li>Pokud jazyk umoòuje práci s lokálními promìnnımi, pak obvykle
  existence lokální promìnné zamaskuje existenci stejnojmenné globální
  promìnné &mdash; platí to i pro Python. Pøi ètení zdrojového textu si
  vùbec nemusíme všimnout toho, e je stejnojmenná lokální promìnná ji
  definována. A najednou se program zaène chovat jinak, ne bychom
  èekali.</li>

<li>Pouitím jména globální promìnné nìkde v kódu vytváøíme obtínì
  kontrolovatelnou vazbu na zbytek systému. Nejde jen o to, e existuje
  vazba na globálnì pojmenovanou promìnnou, ale jejím prostøednictvím se
  najednou ovlivòuje èinnost všech ostatních èástí kódu, které s globální
  promìnnou pracují. Jinımi slovy, nìkdy je velmi obtíné zajistit, aby v
  globální promìnné byla uloena právì ta hodnota, která tam má bıt uloena.
  Zdánlivì nevinná zmìna obsahu, provedená v jednom místì, mùe neoèekávanım
  zpùsobem ovlivnit èinnost jinıch èástí aplikace.</li>
 
</ul>

</div>

<p>Druhı pøípad, kdy se odkazujeme na jméno, které se nenachází mezi
lokálními, se øeší následujícím zpùsobem: Funkce prohlédne svùj lokální
prostor. Pokud zde poadované jméno nenalezne, hledá v prostoru modulu. A
pokud není nalezeno ani zde, hledá se v prostoru zabudovanıch jmen (builtin
scope). Jediná nepøíjemnost nastane v situaci, kdy chceme pøiøadit hodnotu
externí promìnné. Pøi normálním postupu by vznikla nová promìnná tohoto
jména, ale tomu se chceme vyhnout. Take aby se nevytvoøila lokální promìnná 
daného jména, musíme urèit, e se jedná o jméno globální.</p>

<p>Vše si ukáeme v akci na následujícím pøíkladu (jde o èistì ilustraèní
pøíklad):</p>

<pre>
<span class="comment"># Promìnné na úrovni modulu.</span>
W = 5
Y = 3
<span class="comment"> 
# Parametry se chovají jako promìnné náleející funkci. Take X patøí
# do lokálního prostoru.</span>
def spam(X):
   <span class="comment"> 
   # Funkci oznámíme, e má W hledat na úrovni modulu a nevytváøet svou 
   # promìnnou W.</span>
   global W
   
   Z = X*2 <span class="comment"># Nová promìnná Z je vytvoøena jako lokální.</span>
   W = X+5 <span class="comment"># Práce s W na úrovni modulu -- viz vıše.</span>

   if Z > W:
      <span class="comment"># pow je jméno 'zabudované' funkce.</span>
      print pow(Z, W)
      return Z
   else:
      return Y <span class="comment"># Lokální Y neexistuje, take se pouije globální.</span>
</pre>

<p>Pokud importujeme modul, jako je napøíklad <code>sys</code>, stane se
jméno <code>sys</code> lokálnì dostupnım jménem. Poté mùeme jména uvnitø
prostoru jmen modulu <code>sys</code> zpøístupnit pouitím takzvaného
<em>kvalifikovaného jména</em>, jak jsme si ukázali døíve. <span
class="trnote" title="Poznámka pøekladatele">(Kvalifikované jméno se od
holého liší tím, e holému jménu pøedøadíme takzvanı kvalifikátor, kterı má
podobu dalšího jména, vhodnì spojeného s&nbsp;pùvodním holım jménem. V
jazyce Python se obì èásti oddìlují teèkou. Napøíklad v jazyce C++ se
oddìlují dvìma dvojteèkami.)</span></p>

<p>Pokud napíšeme</p>

<pre>
from sys import exit
</pre>

<p>pak v lokálním prostoru jmen zpøístupníme pouze funkci <code>exit</code>.
Nemùeme pouít ádné jiné jméno z modulu <code>sys</code> a dokonce ani
samotné jméno modulu <code>sys</code>.</p>

<h3>Ještì v jazyce BASIC...</h3>

<p>BASIC volí ve srovnání z jazykem Python opaènı pøístup. Všechny vytvoøené
promìnné se automaticky stávají globálními (aby byla zachována
kompatibilita<span class="trnote" title="Poznámka pøekladatele">, tedy
sluèitelnost,</span> s programy psanımi pro starší verze jazyka BASIC), ale
programátor mùe vytváøet i promìnné, které jsou lokální uvnitø funkcí<span
class="trnote" title="Poznámka pøekladatele">, jejich oznaèením klíèovım
slovem</span> &mdash; <code>LOCAL</code>.</p>


<h3>Tcl</h3>

<p>Asi si mohu dovolit tvrdit, e v Tcl neexistuje ádnı mechanismus pro
pøístup k rùznım úrovním viditelnosti jmen. Dùvodem je asi zvláštní zpùsob,
jakım Tcl program provádí. Všechny promìnné se v kadém pøípadì jeví jako
lokální vzhledem k jejich nejblišímu okolí &mdash; promìnné na úrovni
souboru jsou viditelné pouze pro pøíkazy uvnitø stejného souboru a promìnné
procedur jsou viditelné pouze uvnitø procedur. Komunikaci mezi tìmito
prostory jmen mùeme zajistit pouze pøedáváním hodnot v podobì
parametrù<span class="trnote" title="Poznámka pøekladatele">, pøi volání
zmínìnıch procedur</span>.</p>

<hr>
<div class="foot">
<p class="navig">[ 
<a href="cztuterrors.html" title="Práce s chybami">pøedchozí</a> |
<a href="cztutcont.html">obsah</a> | 
<a href="cztutregex.html" title="Regulární vırazy">další</a> 
]</p>
<p class="note">Pokud vás napadne, co by se dalo na pøekladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztutname.html,v 1.6 2005/09/15 18:24:08 petr Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka' 
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20') 
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script> 

Tím budou do dopisu automaticky vloeny informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztutname.html,v 1.6 2005/09/15 18:24:08 petr Exp $</p>
</div>
</body>
</html>


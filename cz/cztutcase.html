<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se nauèit programovat: Pøípadová studie</title>
</head>
<body>

<p class="ir">Níe uvedenı text pochází z prvního vydání. Nad tímto textem 
se nachází aktuální stav po revizi smìøující k druhému vydání.</p>

<h2>Pøípadová studie</h2>

<div class="whatcovered">

<p>V této pøípadové studii rozšíøíme funkènost programu pro poèítání slov,
kterı jsme vyvinuli ji døíve. Vytvoøíme program, kterı napodobí funkci
unixovského programu <code>wc</code> v tom smyslu, e bude vypisovat poèet
øádkù, slov a znakù v souboru. Ale pùjdeme ještì dál a budeme vypisovat také
poèet vìt, klauzulí <span class="trnote" title="Poznámka pøekladatele">(viz
poznámka dále)</span>, slov, písmen a interpunkèních znamének v textovém
souboru. Vıvoj programu budeme provádìt po etapách. Postupnì budeme zvyšovat
jeho schopnosti. Pøevedeme jej do podoby modulu, abychom zvıšili jeho
znovupouitelnost. A upravíme jeho implementaci do objektovì orientované
podoby, èím zvıšíme monosti dalšího rozšiøování funkènosti.</p>

<p>Implementovat jej budeme v jazyce Python, ale pøinejmenším poèáteèní fáze
mohou bıt napsány i v jazycích BASIC nebo Tcl. S tím, jak budeme øešit
sloitìjší èásti problému, budeme stále více pouívat zabudované datové
struktury jazyka Python. Proto se bude obtínost pøípadného zápisu v jazyce
BASIC zvyšovat, aèkoliv pouití Tcl bude stále moné. Objektovì orientované
stránky koneèného øešení budou vhodné pouze pro jazyk Python.</p>

<p>Jako cvièení pro ètenáøe bude ponechána monost implementace dalších
rysù, jako jsou:</p>

<ul>

<li>Vıpoèet <em>FOG indexu</em> pro danı text, kde FOG index mùeme
  pøiblinì definovat jako <code>((prùmìrnı poèet slov na vìtu) + (procento 
  slov s více ne 5 písmeny) * 0.4)</code>. Toto èíslo vyjadøuje sloitost 
  textu.</li>

<li>Zjištìní poètu pouívanıch slov a frekvence jejich pouití.</li>

<li>Vytvoøení nové verze, která analyzuje RTF soubory.</li>

</ul>
</div>

<h3>Poèítání øádkù, slov a znakù</h3>

<p>Podívejme se znovu na døíve vytvoøenı program pro poèítání slov <span
class="trnote" title="Poznámka pøekladatele">(viz <a
href="cztutfiles.html#word_count">Práce se soubory &mdash; Poèítání
slov</a>)</span>:</p>

<pre>
import string
def pocetSlov(s):
    seznam = string.split(s)  
    <span class="comment"># Poznámka pøekladatele: Od verze jazyka Python 2
    # je pro standardní øetìzec definována metoda split(), take místo vıše
    # uvedeného zápisu mùeme psát s.split() a není nutné provádìt import
    # modulu string.</span>
    return len(seznam)  <span class="comment"># vrátíme poèet prvkù seznamu</span>

vstup = open("menu.txt", "r")
celkem = 0 <span class="comment"> # vytvoøíme promìnnou a nastavíme jí poèáteèní hodnotu nula</span>

for radek in vstup.readlines():
    celkem = celkem + pocetSlov(radek) <span class="comment"># seèti poèty za kadı øádek</span>
print "Soubor má %d slov." % celkem

vstup.close()
</pre>

<p>Potøebujeme pøidat poèítadla øádkù a znakù. Poèítání øádkù je snadné,
protoe cyklus zpracovává vstup po øádcích. Jednoduše pøidáme nìjakou
promìnnou a budeme ji zvyšovat pøi kadé obrátce cyklu. Poèítadlo znakù je
pouze mírnì sloitìjší, protoe mùeme procházet seznam slov a jejich délky
pøièítat do další promìnné.</p>

<p>Rádi bychom také zvıšili obecnost pouití programu tím, e jméno
zkoumaného souboru zjistíme z parametru pøíkazového øádku nebo, pokud není
zadáno, vyádáme si zadání jména dotazem na uivatele. (Alternativní øešení
by spoèívalo ve ètení textu ze standardního vstupu, co právì dìlá opravdovı
program <code>wc</code>.)</p>

<p>Take koneèné øešení ve stylu <code>wc</code> vypadá takto <span
class="trnote">(poznámka pøekladatele: abychom se vyhnuli komplikacím s
èeskımi øetìzci ve zdrojovém textu programu, zjednodušíme si øešení tím, e
pouijeme <em>cestinu bez hacku a carek</em>)</span>:</p>

<pre>
import sys, string
<span class="comment">
# Získáme jméno souboru buï z pøíkazového øádku 
# nebo si je vyádáme od uivatele.</span>
if len(sys.argv) != 2:
    jmenoSouboru = raw_input("Zadejte jmeno souboru: ")
else:
    jmenoSouboru = sys.argv[1]
 
vstup = open(jmenoSouboru, "r")
<span class="comment"># Poznámka pøekladatele: Od verze Python 2 by se mìla dávat
# pøednost zápisu vstup = file(jmenoSouboru, "r")</span>
<span class="comment">
# Poèáteèní hodnoty poèítadel nastavíme na nuly. 
# Tím se také vytvoøí pøíslušné promìnné.</span>
slov = 0
radku = 0
znaku = 0

for radek in vstup.readlines():
    radku = radku + 1
    
    <span class="comment"># Øádek rozloíme na slova a spoèítáme je.</span>
    seznamSlov = string.split(radek)
    <span class="comment"># Poznámka pøekladatele: U Python 2 lze psát
    # seznamSlov = radek.split()</span>
    slov = slov + len(seznamSlov)
    <span class="comment"># Poèet znakù urèíme z délky pùvodního øádku, 
    # èím zapoèítáme mezery atd.</span>
    znaku = znaku + len(radek)

print "%s ma %d radku, %d slov a %d znaku" % (jmenoSouboru, radku, slov, znaku)
vstup.close()
</pre>

<p>Pokud znáte unixovskı pøíkaz <code>wc</code>, pak víte, e mu mùete
jméno souboru zadat v podobì masky. Tím získáte hledané údaje pro všechny
soubory, které masce vyhovují, a získáte také celkovı souèet tìchto údajù.
Vıše uvedenı program pracuje pouze s pøímo zadanımi jmény souborù. Pokud
chcete, aby zpracovával i soubory zadané maskou, podívejte se na modul
<code>glob</code>. Ten vám umoní vytvoøit seznam jmen vyhovujících souborù,
kterı pak mùete zpracovat. Budete k tomu potøebovat doèasná poèítadla pro
kadı soubor a navíc kumulativní poèítadla pro celkové souèty (souèty souètù
za jednotlivé soubory). Nebo místo toho mùete pouít slovník&hellip;</p>

<h3>Poèítání vìt místo øádkù</h3>

<p>Kdy jsem zaèal pøemıšlet o tom, jak bychom mohli rozšíøit funkènost,
abychom poèítali vìty a slova místo "skupin znakù" (co èiníme ve vıše
uvedeném øešení), napadlo mì nejprve, e bychom mìli ze souboru nejdøíve v
cyklu naèíst jednotlivé øádky a pak bychom mìli v cyklu zpracovat kadı
øádek a získat z nìj slova do dalšího seznamu. Nakonec bychom mìli zpracovat
kadé "slovo" za úèelem odstranìní nadbyteènıch znakù.</p>

<p>Kdy jsem o tom uvaoval o nìco déle, zaèalo bıt zøejmé, e pokud bychom
jednoduše shromaïovali slova a interpunkèní znaménka, mohli bychom právì
interpunkèní znaménka pouít pro poèítání vìt, klauzulí atd. (tím, e
øekneme, co povaujeme za vìtu nebo klauzuli s ohledem na pouitá
interpunkèní znaménka). <span class="trnote">(Poznámka pøekladatele: V
anglické gramatice se pojem <em>clause</em> (klauzule) pouívá ve vıznamu
vìtného èlenu, typicky hlavní a vedlejší vìty. Pravidla pro vıstavbu vìty a
pro psaní interpunkèních znamének jsou v anglickém jazyce mnohem
propracovanìjší, take se z nich dá strojovì lépe urèit stavba vìty. V
èeském jazyce je to mnohem obtínìjší. Proto od dále uvedeného programu
neoèekávejte zázraky.)</span> To znamená, e staèí, kdy souborem projdeme
pouze jednou a poté budeme procházet pøes mnohem kratší seznam
interpunkèních znamének. Zkusme si to naèrtnout v pseudokódu:</p>

<pre>
pro kadı øádek v souboru:
    zvıšit poèítadlo øádkù
    if je øádek prázdnı:
        zvıšit poèítadlo odstavcù
    rozloit øádek na skupiny znakù
    
pro kadou skupinu znakù:
    zvıšit poèítadlo skupin
    odstranit interpunkèní znaky a pøidat do slovníku - {znak: poèet}
    if ve skupinì nezbyl ádnı znak:
        zrušit skupinu
    else: zvıšit poèítadlo slov

poèet vìt = poèet znakù ('.', '?', '!')
poèet klauzulí = souèet všech interpunkèních znakù (ponìkud ubohá definice...)

vypsat poèty odstavcù, øádkù, vìt, klauzulí, skupin znakù, slov.
pro kadı interpunkèní znak:
    vypsat poèet (ze slovníku)    
</pre>

<p>Vypadá to, e bychom mohli vytvoøit asi 4 funkce, odpovídající vıše
uvedenım skupinám. To by nám pomohlo vybudovat modul, kterı by mohl bıt
opakovanì pouitelnı buï jako celek nebo po èástech.</p>

<h3>Udìlejme z toho modul</h3>

<p>Klíèové funkce budou tyto: <code>ziskejSkupinyZnaku(vstSoubor)</code> a 
<code>ziskejInerpunkci(seznamSkupin)</code>. Podívejme se, co vytvoøíme na
základì uvedeného pseudokódu&hellip;</p>

<pre>
<span class="comment">
#############################
# Modul:    gramatika
# Vytvoøil: A.J. Gauld, 2000,8,12
#
# Funkce:
# Poèítá odstavce, øádky, vìty, 'klauzule', skupiny znakù, slova
# a interpunkèní znaménka pro textové soubory s textem pøedpokládajícím
# prózu. Pøedpokládá se, e vìty konèí znaky [.!?] a odstavce jsou oddìleny
# prázdnım øádkem. Za 'klauzuli' se jednoduše povauje èást vìty, která je
# oddìlena interpunkèním znakem (co je ponìkud hloupá definice, ale jednoho
# dne mùeme doplnit nìco lepšího).
#
# Pouití: Pøi základním pouití se ète jméno souboru z parametru a vypisují
#          se všechny získané údaje. Pøedpokládá se vytvoøení druhého modulu,
#          kterı by pouíval zde definované funkce a poskytoval uiteènìjší
#          pøíkazy.
#############################</span>
import string, sys
<span class="comment">
############################
# Poèáteèní nastavení globálních promìnnıch.</span>
poc_odstavcu = 1 <span class="comment"># Pøedpokládáme existenci nejménì jednoho odstavce.</span>
poc_radku, poc_vet, poc_klauzuli, poc_slov = 0, 0, 0, 0
skupiny = []
poc_interpunkcnich_znaku = {}
alfanumericke_znaky = string.letters + string.digits

<span class="comment"># Poznámka pøekladatele: Pro èeské texty bychom mezi 
# alfanumerické znaky mìli pøidat i znaky s diakritickımi znaménky. Vìc se 
# ale komplikuje tím, e bychom navíc mìli uvaovat i zpùsob kódování
# vstupního souboru. Obecné øešení by nebylo úplnì jednoduché, take zatím
# nebudeme pøeklad originálního zdrojového textu z angliètiny upravovat.</span>

koncove_znaky = ['.', '?', '!']
interpunkcni_znaky = ['&amp;', '(', ')', '-', ';', ':', ','] + koncove_znaky
for c in interpunkcni_znaky:
    poc_interpunkcnich_znaku[c] = 0
format = """%s obsahuje:
%d odstavcu, %d radku a %d vet.
Ty obsahuji %d klauzuli a celkem %d slov."""

<span class="comment">
############################
# Nyni nadefinujeme funkce, které tvoøí jádro èinnosti.</span>

def ziskejSkupinyZnaku(vstSoubor):
    pass

def ziskejInerpunkci(seznamSkupin):
    pass

def vypsatStatistiky():
    print format % (sys.argv[1], poc_odstavcu, 
                    poc_radku, poc_vet,
                    poc_klauzuli, poc_slov)

def Analyzuj(vstSoubor):
    ziskejSkupinyZnaku(vstSoubor)
    ziskejInerpunkci(skupiny)
    vypsatStatistiky()

<span class="comment">
# Pokud je modul volán z pøíkazového øádku, zajisti spuštìní následujícího
# kódu. (V tomto pøípadì je magická promìnná __name__ nastavena na hodnotu
# "__main__".)</span>

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print "Pouziti: python gramatika.py &lt;soubor&gt;"
        sys.exit()
    else:
        Dokument = open(sys.argv[1], "r")
        <span class="comment"># Poznámka pøekladatele: Od verze Python 2 by se mìla dávat
        # pøednost zápisu Dokument = file(sys.argv[1], "r")</span>  
        Analyzuj(Dokument)
        Dokument.close()
</pre>

<p>V tomto místì jsem nechtìl ukázat celé øešení v podobì jednoho dlouhého
vıpisu. Proberu radìji uvedenou kostru a potom se podíváme na kadou z
uvedenıch tøí vıznamnıch funkcí. Nicménì k tomu, abyste program uvedli do
chodu, budete muset na konci vše slepit dohromady.</p>

<p>První vìcí, která stojí za povšimnutí, je komentáø na zaèátku. Jeho
uvedení patøí k bìnım praktikám. Má ètenáøi naznaèit, co soubor obsahuje a
jak má bıt pouíván. Uiteèná je rovnì informace o verzi (autor a datum) a
to zejména pro nìkoho, kdo ji moná pouívá novìjší nebo starší verzi.</p>

<p>Poslední úsek souvisí s rysem systému Python, kterı kadému modulu
spuštìnému z pøíkazového øádku vnitønì øíká <code>"__main__"</code> (èti
mein; hlavní). Mùeme si otestovat obsah speciální zabudované promìnné
<code>__name__</code> (èti nejm; jméno). Pokud je v ní uveden zmínìnı
øetìzec, pak víme, e modul nebyl importován, ale e byl spuštìn. Take v
takovém pøípadì mùeme provést spouštìcí kód, kterı je uveden v tìle pøíkazu
<code>if</code>.</p>

<p>Náš spouštìcí kód obsahuje uivatelsky pøívìtivou nápovìdu o zpùsobu
spuštìní programu pro pøípad, kdybychom jej spustili bez zadání jména
souboru, nebo kdybychom naopak uvedli pøíliš mnoho jmen souborù.</p>

<p>Na závìr poznamenejme, e funkce <code>Analyzuj()</code> jednoduše zavolá
ostatní funkce ve správném poøadí. K bìnım praktikám patøí opìt to, e si
uivatel mùe vybrat, zda bude chtít pouívat celkovou funkènost pøímoèarım
zpùsobem (voláním funkce <code>Analyzuj()</code>) nebo zda bude pøímo volat
nízkoúrovòové, <em>primitivní</em> funkce.</p>

<h4>ziskejSkupinyZnaku()</h4>

<p>Pseudokód pro tento úsek vypadal následovnì:</p>

<pre>
pro kadı øádek v souboru:
    zvıšit poèítadlo øádkù
    if je øádek prázdnı:
        zvıšit poèítadlo odstavcù
    rozloit øádek na skupiny znakù
</pre>

<p>V jazyce Python to mùeme implementovat velmi snadno:</p>

<pre>
<span class="comment">
# Pouijeme globální promìnné poèítadel a globální seznam skupin znakù.</span>
def ziskejSkupinyZnaku(vstSoubor):
    global poc_odstavcu, poc_radku, skupiny
    try:
        for radek in vstSoubor.readlines():
            poc_radku = poc_radku + 1
            if len(radek) == 1: <span class="comment"># prázdnı øádek => oddìlení odstavce</span>
                poc_odstavcu = poc_odstavcu + 1
            else:
                skupiny = skupiny + string.split(radek)
                <span class="comment"># Poznámka pøekladatele: Od verze Python 2 lze psát
                # skupiny = skupiny + radek.split()</span>
    except:
        print "Nepodarilo se cist ze souboru ", sys.argv[1]
        sys.exit()
</pre>

<p><b>Poznámka 1:</b> Abychom oznámili, e budeme pouívat promìnné, které
byly vytvoøeny vnì tìla funkce, musíme pouít klíèové slovo
<code>global</code>. Pokud bychom tak neuèinili, pak by pøi pøiøazování do
nich Python vytvoøil nové promìnné se stejnımi jmény, které by ovšem byly
<em>lokální</em> uvnitø tìla funkce. Zmìny obsahu takovıch lokálních
promìnnıch by se u <em>globálních</em> promìnnıch (na úrovni modulu)
neprojevily.</p>

<p><b>Poznámka 2:</b> K pøípadnému oznámení chyb <span class="trnote"
title="Poznámka pøekladatele">pøi ètení souboru</span> a ukonèení bìhu
programu jsme pouili konstrukci <code>try</code>/<code>except</code>.</p>

<h4>ziskejInerpunkci()</h4>

<p>Zde budeme muset vyvinout o nìco vìtší úsilí. Pouijeme také pár novıch
rysù jazyka Python. Pøíslušnı pseudokód vypadal následovnì:</p>

<pre>
pro kadou skupinu znakù:
    zvıšit poèítadlo skupin
    odstranit interpunkèní znaky a pøidat do slovníku - {znak: poèet}
    if ve skupinì nezbyl ádnı znak:
        zrušit skupinu
    else: zvıšit poèítadlo slov
</pre>

<p>Mùj první pokus vypadal nìjak takto:</p>

<pre>
def ziskejInerpunkci(seznamSkupin):
    global poc_interpunkcnich_znaku
    for skupina in seznamSkupin:
        while skupina and (skupina[-1] not in alfanumericke_znaky):
            p = skupina[-1]
            skupina = skupina[:-1]
            if p in poc_interpunkcnich_znaku.keys():
                 poc_interpunkcnich_znaku[p] = poc_interpunkcnich_znaku[p] + 1
            else: poc_interpunkcnich_znaku[p] = 1
</pre>

<p>Povšimnìte si, e tato verze nezahrnuje závìreènou konstrukci
<code>if</code>/<code>else</code>, kterou obsahoval pseudokód. Vynechal jsem
ji kvùli zjednodušení. Mìl jsem také pocit, e se v praktickıch pøípadech
objeví velmi málo skupin, které obsahují pouze interpunkèní znaky. Ale do
koneèné verze kódu tuto konstrukci doplníme.</p>

<p><b>Poznámka 1:</b> Seznam skupin jsme se rozhodli pøedávat parametrem,
take uivatelé tohoto modulu mohou pøedat svùj vlastní seznam místo toho,
aby byli nuceni pracovat se souborem.</p>

<p><b>Poznámka 2:</b> Za zmínku stojí obrat, kdy jsme promìnné
<code>skupina</code> pøiøadili hodnotu <code>skupina[:-1]</code>. V jazyce
Python je tento obrat znám jako <em>slicing</em> (èti slajsing; odøezávání,
odkrajování). Dvojteèka øíká, aby byl index chápán jako rozsah. Pokud bychom
napøíklad chtìli získat seznam poloek <code>skupina[3]</code>,
<code>skupina[4]</code> a <code>skupina[5]</code>, vyjádøili bychom jej jako
<code>skupina[3:6]</code>. <span class="trnote">(Poznámka pøekladatele:
tento obrat lze pouívat pro posloupnosti rùznıch druhù, konkrétnì pro
øetìzce a pro seznamy.)</span></p>

<p>Pokud neuvedeme èíslo, pak se to chápe jako zaèátek nebo konec seznamu
podle toho, na které stranì dvojteèky necháme prázdné místo. Take zápis
<code>skupina[3:]</code> by mìl vıznam všech èlenù <code>skupina</code> od
<code>skupina[3:]</code> a do konce. Jde o jeden z velmi uiteènıch rysù
jazyka Python. V našem pøíkladu je originální posloupnost
<code>skupina</code> ztracena (a tím pádem náleitì uklizena, uvolnìna).
Novì vytvoøená posloupnost <span class="trnote" title="Poznámka pøekladatele"
>(v našem pøípadì øetìzec)</span> je pøiøazena do <code>skupina</code>.</p>

<p><b>Poznámka 3:</b> Pro získání posledního znaku z promìnné
<code>skupina</code> pouíváme zápornı index. Jde opìt o velmi uiteènı rys
jazyka Python. Pro pøípad, e by se na konci skupiny objevilo více
interpunkèních znakù, provádíme zpracování v cyklu.</p>

<p>Bìhem testù se ukázalo, e toté musíme provádìt i pro zaèátek skupiny,
protoe, aèkoliv uzavírací závorky detekovány jsou, otvírací závorky
nikoliv. Pro vyøešení tohoto problému vytvoøíme novou funkci
<code>trim()</code>, která odstraní interpunkèní znaky ze zaèátku a z konce
jedné skupiny znakù:</p>

<pre id="buggyTrim">
<span class="comment">
#########################################################
# Poznámka: trim pouívá rekurzi, kde podmínkou ukonèení je buï hodnota
# 0 nebo -1. Pokud se objeví nìco jiného, ne hodnoty -1, 0 nebo 2,
# je vyvolána chyba "InvalidEnd". 
# Poznámka pøekladatele: Od verze Python 2.0 se doporuèuje pro vıjimky
# pouívat instance tøíd odvozenıch od tøídy Exception. Pouívání
# øetìzcù pro vıjimky se ji nedoporuèuje.
##########################################################</span>
def trim(polozka, end = 2):
  """ Odstraní nealfanumerické znaky zleva (end = 0), zprava (-1) nebo 
      z obou stran promìnné polozka."""

  if end not in [0, -1, 2]:
     raise "InvalidEnd"

  if end == 2:
     trim(polozka, 0)
     trim(polozka, -1)
  else:
     while (len(polozka) > 0) and (polozka[end] not in alfanumericke_znaky):
        ch = polozka[end]
        if ch in poc_interpunkcnich_znaku.keys():
           poc_interpunkcnich_znaku[ch] = poc_interpunkcnich_znaku[ch] + 1
        if end == 0: polozka = polozka[1:]
        if end == -1: polozka = polozka[:-1]
</pre>

<p>Povšimnìte si, jak nám kombinace pouití rekurze a implicitní
(pøednastavené) hodnoty parametru umonila definovat jedinou funkci
<code>trim</code>, která standardnì ošetøí oba konce. Pokud ale zadáme
hodnotu parametru <code>end</code>, mùeme ji pouít k ošetøení pouze
jednoho konce. Hodnoty parametru <code>end</code> jsou zvoleny tak, aby
odpovídaly zpùsobu indexování v jazyce Python: nula pro levou stranu a -1
pro pravou. Pùvodnì jsem vytvoøil dvì funkce <code>trim</code>, jednu pro
kadı konec. Ale díky mnoství pozorovanıch podobností jsem zjistil, e je
pøi pouití parametru mohu zkombinovat dohromady.</p>

<p>Funkce <code>ziskejInerpunkci</code> se tím velmi zjednoduší:</p>

<pre>
def ziskejInerpunkci(seznamSkupin):
    for skupina in seznamSkupin:
        trim(skupina)
    <span class="comment"># Nyní vypustíme prázdná 'slova'.</span>
    for i in range(len(seznamSkupin)):
        if len(seznamSkupin[i]) == 0:
            del(seznamSkupin[i])
</pre>

<p><b>Poznámka 1:</b> Nová implementace navíc provádí vypouštìní prázdnıch
slov.</p>

<p><b>Poznámka 2:</b> V zájmu znovupouitelnosti by moná bıvalo bylo lepší,
kdybychom funkci trim rozbili na ještì menší kousky. To by nám umonilo
vytvoøit funkci pro odstranìní jediného interpunkèního znaménka &mdash; buï
ze zaèátku, nebo z konce slova &mdash; a odstranìnı znak bychom mohli vracet
jako vısledek. Takovou funkci by pak mohla opakovanì volat jiná funkce, èím
bychom získali poadovanı vısledek. Ale náš modul se má zabıvat zjišováním
konkrétních statistickıch údajù ze zadaného textu a ne nìjakım obecnım
zpracováním textu. Pro uvedené funkce bychom tedy správnì mìli vytvoøit
samostatnı modul, kterı bychom pak importovali. Jene ten by obsahoval jen
jednu funkci, která se navíc nezdá bıt pøíliš uiteènou. Take to radìji
nechejme, jak to je.</p>

<h4>Koneèná podoba modulu <code>gramatika</code></h4>

<p>Teï u nám zbıvá jenom vylepšit vıpis vısledkù tím, e do nìj zahrneme
další poèítadla a vliv interpunkèních znakù. Existující funkci
<code>vypsatStatistiky()</code> nahraïte následujícím kódem:</p>

<pre>
def vypsatStatistiky():
    global poc_vet, poc_klauzuli
    for c in koncove_znaky:
        poc_vet = poc_vet + poc_interpunkcnich_znaku[c]
    for c in poc_interpunkcnich_znaku.keys():
        poc_klauzuli = poc_klauzuli + poc_interpunkcnich_znaku[c]
    print format % (sys.argv[1], poc_odstavcu, 
                    poc_radku, poc_vet,
                    poc_klauzuli, poc_slov)
    print "Byly pouzity nasledujici interpunkcni znaky:"
    for c in poc_interpunkcnich_znaku.keys():
        print "\t%s\t:\t%3d" % (c, poc_interpunkcnich_znaku[c])
</pre>

<p>Pokud jste peèlivì vloili všechny vıše uvedené funkce na správná místa,
mìli byste nyní po napsání</p> 
<pre>
C:> python gramatika.py mujsoubor.txt
</pre>

<p>obdret vıpis statistickıch údajù pro váš soubor
<code>mujsoubor.txt</code> (a u jej nazvete jak chcete). Uiteènost tohoto
programu je diskutabilní, ale snad vám sledování vıvoje jeho kódu pomohlo
získat pøedstavu o tom, jak mùete tvoøit své vlastní programy. Za hlavní
povauji to, abyste si vše zkoušeli. A ovšem, mìli byste si je také peèlivì
otestovat. V pøípadì tohoto programu napøíklad rychle zjistíte zpùsoby, jak
z nìj vylákat falešné odpovìdi. Pokud napøíklad vìtu zakonèíte tøemi
teèkami, bude poèítadlo vìt nabıvat pøíliš vysoké hodnoty. Pro rozpoznání
takovıch situací mùete doplnit k tomu urèenı kód. Mùete se také
rozhodnout, e s ohledem na obèasné pouití programu vám podobné vìci
nevadí. Je to na vás.</p> 

<p>Nepovauji za ádnou ostudu, kdy si vyzkoušíte nìkolik rùznıch pøístupù.
Èasto bìhem toho získáte cenné zkušenosti.</p>

<p>Náš kurs ukonèíme pøepracováním modulu <code>gramatika</code> na pouití 
technik objektovì orientovaného programování. Bìhem tohoto procesu uvidíte,
e objektovì orienovanı pøístup vede k modulùm, které jsou pro koncového
uivatele ještì prunìjší a také rozšíøitelnìjší.</p>

<h3>Tøídy a objekty</h3>

<p>Jeden z nejvìtších problémù, se kterım se uivatel našeho modulu setká,
spoèívá ve spoléhání se na globální promìnné. Vede to k tomu, e mùeme
analyzovat vdy jen jeden dokument najednou. Jakıkoliv pokus o zpracování
více dokumentù by vedl k pøepisování hodnot globálních promìnnıch.</p>

<p>Pokud pøeneseme tyto globální údaje dovnitø tøídy, mùeme vytvoøit
nìkolik instancí dané tøídy (pro kadı soubor jednu). Kadá instance tím
získá svou vlastní sadu promìnnıch. Kdy navíc metody tøídy dostateènì
rozèleníme, mùeme vytvoøit architekturu, u které bude moci tvùrce objektu
pro novı typ dokumentu snadno upravit kritéria tak, aby vyhovovala novım
pravidlùm (ze seznamu slov mùeme napøíklad vylouèit všechny HTML znaèky).</p>

<p>Náš první pokus vypadá takto:</p>

<pre>
<span class="comment">#! /usr/local/bin/python
################################
# Modul: dokument.py
# Autor: A.J. Gauld
# Datum: 2000/08/12
# Verze: 2.0
################################
# Tento modul poskytuje tøídu Dokument, ze které
# lze odvozovat další tøídy pro rùzné kategorie
# dokumentù (text, HTML, LaTeX, atd.). Jako vzor
# jsou uvedeny tøídy pro text a HTML.
#
# K nejdùleitìjším slubám patøí
# - ziskejSkupinyZnaku(),
# - ziskejSlova(),
# - vypsatStatistiky().
################################</span>
import sys, string

class Dokument:
    def __init__(self, jmenoSouboru):
        self.jmenoSouboru = jmenoSouboru
        self.poc_odstavcu = 1
        self.poc_radku, self.poc_vet = 0, 0
        self.poc_klauzuli, self.poc_slov = 0, 0
        self.alfanum = string.letters + string.digits
        self.koncove_znaky = ['.','?','!']
        self.interpunkcni_znaky = ['&amp;', '(', ')', '-', ';', 
                                   ':', ','] + self.koncove_znaky
        self.radky = []
        self.skupiny = []
        self.poc_interp_znaku = {}
        for c in self.interpunkcni_znaky + self.koncove_znaky:
           self.poc_interp_znaku[c] = 0
        self.format = """%s obsahuje:
%d odstavcu, %d radku a %d vet.
Ty zase obsahuji %d klauzuli a celkem %d slov."""

    def nactiRadky(self):
        try:
            self.vstSoubor = open(self.jmenoSouboru, "r")
            <span class="comment"># Poznámka pøekladatele: Od verze Python 2 by se 
            # mìla dávat pøednost zápisu 
            # self.vstSoubor = file(self.jmenoSouboru, "r")</span>
            self.radky = self.vstSoubor.readlines()
            self.vstSoubor.close()
        except:
            print "Chyba pri cteni ze souboru ", self.jmenoSouboru
            sys.exit()
  
    def ziskejSkupinyZnaku(self, radky):
        for radek in radky:
            radek = radek[:-1]  <span class="comment"># odstraníme koncovı '\n'</span>
            self.poc_radku = self.poc_radku + 1
            if len(radek) == 0: <span class="comment"># prázdnı => další odstavec</span>
                self.poc_odstavcu = self.poc_odstavcu + 1
            else:
                self.skupiny = self.skupiny + string.split(radek)
                <span class="comment"># Poznámka pøekladatele: Od verze Python 2 lze psát
                # self.skupiny = self.skupiny + radek.split()</span>
  
  
    def ziskejSlova(self):
        pass
  
    def vypsatStatistiky(self, odstavcu=1, radku=1, vet=1, slov=1, interpun=1):
        pass
  
    def Analyzuj(self):
        self.nactiRadky()
        self.ziskejSkupinyZnaku(self.radky)
        self.ziskejSlova()
        self.vypsatStatistiky()

class TextovyDokument(Dokument):
    pass

class HTMLDokument(Dokument):
    pass

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print "Pouziti: python dokument.py &lt;jmeno souboru&gt;"
        sys.exit()
    else:
        D = Dokument(sys.argv[1])
        D.Analyzuj()
</pre>

<p>Následujícím krokem pøi implementaci této tøídy je definice metody
<code>ziskejSlova</code>. Mohli bychom jednoduše okopírovat to, co jsme
vytvoøili v pøedchozí verzi a vytvoøit nìjakou metodu trim. Jene my chceme,
aby byla objektovì orientovaná verze snadno rozšiøitelná. Take místo toho
rozdìlíme metodu <code>ziskejSlova</code> na posloupnost nìkolika krokù. V
odvozenıch tøídách pak staèí pøepsat jen nové verze tìchto podkrokù a
nikoliv celou metodu <code>ziskejSlova</code>. To by mìlo usnadnit
zpracování mnohem širšího rozsahu typù dokumentù.</p>

<p>Konkrétnì pøidáme metodu pro odmítnutí skupin, které budou rozpoznány
jako chybné, metodu pro odstranìní nechtìnıch znakù ze zaèátku a z konce. To
znamená, e do tøídy <code>Dokument</code> pøidáme tøi metody a metodu
<code>ziskejSlova</code> implementujeme pomocí nich.</p>

<pre>
class Dokument:
    # ... viz vıše
    def ziskejSlova(self):
        for w in self.skupiny:
            self.orezatLeve(w)
            self.orezatPrave(w)
        self.odstranitVyjimky()
  
    def odstranitVyjimky(self):
        pass
  
    def orezatLeve(self, slovo):
        pass
  
    def orezatPrave(self, slovo):
        pass
</pre>

<p>Povšimnìte si, e tìla uvedenıch funkcí definují pouití jediného pøíkazu
<code>pass</code> (èti pás; projít), kterı nedìlá vùbec nic. Místo nìj
budeme pozdìji definovat zpùsob zpracování pro kadı <em>konkrétní</em> typ
dokumentu.</p>

<h3>Textovı dokument</h3>

<p>Tøída pro textovı dokument vypadá takto:</p>

<pre id="inefficientTrim">
class TextovyDokument(Dokument):
    def orezatLeve(self, slovo):
        while (len(slovo) > 0) and (slovo[0] not in self.alfanum):
            ch = slovo[0]
            if ch in self.poc_interp_znaku.keys():
                self.poc_interp_znaku[ch] = self.poc_interp_znaku[ch] + 1
            slovo = slovo[1:]
        return slovo

    def orezatPrave(self, slovo):
        while (len(slovo) > 0) and (slovo[-1] not in self.alfanum):
            ch = slovo[-1]
            if ch in self.poc_interp_znaku.keys():
                self.poc_interp_znaku[ch] = self.poc_interp_znaku[ch] + 1
            slovo = slovo[:-1]
        return slovo
      
    def odstranitVyjimky(self):
        self.skupiny = filter(lambda g: len(g) &gt; 0, self.skupiny)
</pre>

<p>Oøezávací funkce <span class="trnote" title="Poznámka pøekladatele"
>(anglicky se tato funkènost oznaèuje slovem <em>trim</em>)</span> jsou v
podstatì shodné s funkcí <code>trim</code> v našem modulu
<code>gramatika.py</code>, která byla ovšem rozdìlena na dvì. Funkce
<code>odstranitVyjimky</code> byla definována tak, aby odstraòovala prázdná
slova. Povšimnìte si pouití funkce <code>filter()</code>, o které jsme se
zmínili v èásti vìnované <a href="cztutfctnl.html#filter">funkcionálnímu
programování</a>.</p>

<h3>HTML dokument</h3>

<p>Pøi zpracování HTML dokumentù pouijeme funkènost jazyka Python, se
kterou jsme se ještì nesetkali &mdash; <em>regulární vırazy</em>. Jde o
speciální øetìzcové vzorky, které se dají pouít pro nalezení sloitìjších
øetìzcù. Pouijeme je zde k odstranìní èehokoliv mezi znaky &lt; a &gt;. To
znamená, e budeme muset pøedefinovat metodu <code>ziskejSlova</code>.
Odstraòování interpunkèních znamének by mìlo bıt shodné jako v pøípadì
zpracování holého textu. Take místo abychom dìdili pøímo z tøídy
<code>Dokument</code>, odvodíme novou tøídu z <code>TextovyDokument</code> a
pouijeme jí definované metody pro oøezávání.</p>

<p>Take tøída <code>HTMLDokument</code> bude vypadat takto:</p>

<pre>
class HTMLDokument(TextovyDokument):
    def odstranitVyjimky(self):
        """ Pouijeme regulární vırazy pro odstranìní všech &lt;.+?&gt;"""
        import re
        tag = re.compile("&lt;.+?&gt;")<span class="comment"># pouijeme non greedy re</span>
        L = 0
        while L &lt; len(self.radky):
            if len(self.radky[L]) > 1:<span class="comment"> # pokud øádek není prázdnı</span>
                 self.radky[L] = tag.sub('', self.radky[L])
                 if len(self.radky[L]) == 1:
                     del(self.radky[L])
                 else: L = L + 1
            else: L = L + 1


    def ziskejSlova(self):
        self.odstranitVyjimky()
        for i in range(len(self.skupiny)):
             slovo = self.skupiny[i]
             slovo = self.orezatLeve(slovo)
             self.skupiny[i] = self.orezatPrave(slovo)
        TextovyDokument.odstranitVyjimky(self)<span class="comment"># odstraní prázdná slova</span>
</pre>

<p><b>Poznámka:</b> V tomto místì stojí za zmínku pouze volání
<code>self.odstranitVyjimky</code> pøed oøezáváním a poté volání
<code>TextovyDokument.odstranitVyjimky</code>. Pokud bychom se spoléhali na
zdìdìnou metodu <code>ziskejSlova</code>, byla by po provedení oøezání
volána naše metoda <code>odstranitVyjimky</code>, co nechceme.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> Pojem <em>greedy</em> (èti
grídy), kterı se objevil v poznámce u regulárního vırazu, odpovídá vıznamu
anglického slovíèka &mdash; chamtivı, lakomı, ravı. Vzorek
<code>&lt;.+&gt;</code>, kterı bychom pouili pro regulární vıraz lze èíst jako 
<em>øetìzec, kterı zaèíná levou úhlovou závorkou (znak 'menší'), pokraèuje jedním a více
(znak plus) libovolnıch znakù (znak teèka) a konèí pravou úhlovou závorkou
(znak 'vìtší')</em>. Pokud neurèíme jinak, snaí se Python najít
odpovídající øetìzec, kterı je co nejvìtší (tj. <em>greedy</em>, neboli
ravé chování). To ovšem znamená, e by se k prvnímu znaku 'menší' na daném
øádku nalezl a poslední znak 'vìtší'. Pøi pøeskakování libovolnıch znakù by
mohly bıt pøeskoèeny i znaky menší/vìtší, které se nacházejí mezi nimi. My
ovšem potøebujeme, aby se pøeskakování zastavilo na nejbliším znaku
'vìtší', kterı ukonèuje HTML znaèku. To znamená, e chceme pøedepsat opaèné
chování (tj. <em>non greedy</em>), kdy se nalezne co nejkratší vyhovující
øetìzec. V jazyce Python tento poadavek vyjádøíme tím, e za popis skupiny
doplníme otazník. Pouijeme tedy vzorek <code>&lt;.+?&gt;</code>.</p>

<h3>Pøidáme grafické uivatelské rozhraní</h3>

<p>Pro vytvoøení grafického uivatelského rozhraní pouijeme Tkinter, kterı
jsme struènì pøedstavili v kapitole <a href="cztutevent.html">Událostmi
øízené programování</a> a kterému jsme se vìnovali podrobnìji v rámci tématu
vìnovanému <a href="cztutgui.html">grafickému uivatelskému rozhraní</a>.
Tentokrát vytvoøíme o nìco propracovanìjší grafické uivatelské rozhraní a
pouijeme více ovládacích prvkù, zvanıch také <em>widget</em>, které nám
Tkinter poskytuje.</p>

<h4>Refaktorizace<sup class="trnote"><a href="cztuttrn.html#Pcase_refactoring" 
id="Bcase_refactoring" title="Pojem refaktorizace (refactoring)"
>[1]</a></sup> tøídy Dokument</h4>

<p>Døíve ne se do tohoto stadia dostaneme, musíme upravit naši tøídu
<code>Dokument</code>. Dosavadní verze provádí zobrazení vısledkù tiskem na
standardní vıstup (<code>stdout</code>) v rámci metody
<code>Analyzuj</code>. Pøi vytváøení grafického uivatelského rozhraní to
ale není to pravé. Místo toho bychom radìji pøivítali, kdyby metoda Analyzuj
jednoduše uloila vısledky v atributech s charakterem poèítadel, ke kterım
bychom pak pøistupovali podle potøeby. Dosáhneme toho jednoduše rozdìlením
nebo <em>refaktorizací</em> metody <code>vypsatStatistiky()</code> na dvì
èásti: metodu <code>vypocetStatistik()</code>, která vyhodnotí vısledky a
uloí je v poèítadlech, a na metodu <code>tiskStatistik()</code>, která
vytiskne vısledky na standardní vıstup.</p>

<p>Nakonec musíme upravit metodu <code>Analyzuj()</code> tak, aby volala
metodu <code>vypocetStatistik()</code>, a hlavní sekvenci pøíkazù tak, aby
po volání metody <code>Analyzuj()</code> volala
<code>tiskStatistik()</code>. Po provedení tìchto úprav bude stávající kód
pracovat stejnım zpùsobem, jako pøedtím &mdash; pøinejmenším z pohledu
uivatele, kterı takovı program spouští z pøíkazového øádku. Ostatní
uivatelé <span class="trnote" title="Poznámka pøekladatele">(tj. ti, kteøí
zdrojovı soubor pouívají jako modul, vytváøejí si sami instance tøídy
Dokument a volají sami jeho metody)</span> budou muset provést ve svém kódu
drobné zmìny, kdy po pouití metody <code>Analyzuj()</code> zavolají metodu
<code>tiskStatistik()</code> &mdash; a to není pøíliš obtíné.</p>

<p>Revidované úseky kódu vypadají takto:</p>

<pre>
    def vypocetStatistik(self):
        self.poc_slov = len(self.skupiny)
        for c in self.koncove_znaky:
            self.poc_vet = self.poc_vet + self.poc_interp_znaku[c]
        for c in self.poc_interp_znaku.keys():
            self.poc_klauzuli = self.poc_klauzuli + self.poc_interp_znaku[c]

    def tiskStatistik(self):
        print self.format % (self.jmenoSouboru, self.poc_odstavcu, 
                             self.poc_radku, self.poc_vet,
                             self.poc_klauzuli, self.poc_slov)
        print "Byly pouzity nasledujici interpunkcni znaky:"
        for c in self.poc_interp_znaku.keys():
            print "\t%s\t:\t%4d" % (c, self.poc_interp_znaku[c])
</pre>

<p>a tìlo provádìné pøi spuštìní z pøíkazového øádku:</p>

<pre>
if __name__ == "__main__":
    if len(sys.argv) != 2:
        print "Pouziti: python dokument.py &lt;jmeno souboru&gt;"
        sys.exit()
    else:
        try:
            D = HTMLDokument(sys.argv[1])
            D.Analyzuj()
            D.tiskStatistik()
        except:
            print "Chyba pri analyze souboru: %s" % sys.argv[1]
</pre>

<p>Nyní jsme pøipraveni k tomu, abychom naše tøídy dokumentù obalili
grafickım uivatelskım rozhraním.</p>

<h4>Návrh grafického uivatelského rozhraní</h4>

<p>V prvním kroku si pokusíme pøedstavit, jak to vše bude vypadat. Musíme
zadat jméno souboru, take budeme potøebovat ovládací prvky <em>Edit</em>
nebo <em>Entry</em>. Musíme urèit, zda chceme provádìt analızu holého textu
nebo obsahu v podobì HTML. Takovı zpùsob vıbìru <em>jedné z nìkolika
moností</em> je obvykle reprezentován sadou prvkù typu
<em>Radiobutton</em>. Tyto ovládací prvky by mìly bıt sdrueny dohromady,
aby bylo vidìt, e spolu souvisejí.</p>

<p>Dále poadujeme nìjakı zpùsob zobrazení vısledkù. Mohli bychom pouít
nìkolik prvkù typu <em>Label</em> &mdash; jeden pro kadé poèítadlo. Místo
toho pouiji jednoduchı prvek typu <em>Text</em>, do kterého mùeme vkládat
øetìzce. Tento pøístup se pøibliuje duchu døívìjšího øádkového vıstupu, ale
konkrétní zpùsob vıstupu je vìcí volby návrháøe.</p>

<p>Na závìr, potøebujeme nìjaké prostøedky pro zahájení analızy a pro
ukonèení aplikace. Protoe pro zobrazení vısledkù pouijeme ovládací prvek
typu text, mohlo by bıt uiteèné, kdybychom mohli do poèáteèního stavu uvést
i zobrazování. Všechny uvedené pøíkazy mohou bıt vyjádøeny prvky typu
<em>Button</em> (tlaèítko).</p>

<p>Pokud si naèrtneme podobu odpovídajícího grafického uivatelského 
rozhraní, dostaneme nìco takového:</p>

<div class="center">
<pre>
+-------------------------+-----------+
|    Jméno souboru        | (*) text  |
|                         | ( ) HTML  |
+-------------------------+-----------+
|                                     |
|                                     |
|                                     |
|                                     |
|                                     |
+-------------------------------------+
|                                     |
|   Analyzuj      Vymazat     Konec   |
|                                     |
+-------------------------------------+
</pre>
</div>

<p>Teï mùeme pøistoupit k psaní kódu &mdash; krok po kroku:</p>

<pre>
from Tkinter import *
import dokument
<span class="comment">
################### Definice tøíd ######################</span>
class AplikaceGramatika(Frame):
    def __init__(self, rodic=0):
        Frame.__init__(self, rodic)
        self.typ = 2 <span class="comment"># vytvoø promìnnou s poèáteèní hodnotou</span>
        self.master.title('Pocitadlo gramatickych prvku')
        self.vybudovatUI()
</pre>

<p>Nejdøíve jsme provedli import modulù Tkinter a dokument. V prvním pøípadì
jsme si v rámci vytváøeného modulu zajistili viditelnost všech jmen z
Tkinter, zatímco v druhém pøípadì budeme muset pøed jména pøidávat pøedponu
'<code>dokument</code>'.</p>

<p>Definovali jsme i metodu <code>__init__</code>, která volá metodu
<code>Frame.__init__</code> své bázové tøídy. Tím se zajistí správná vnitøní
nastavení v rámci Tkinter. Poté vytváøíme atribut, ve kterém bude uloena
hodnota typu dokumentu. A nakonec voláme metodu <code>vybudovatUI</code>,
která nám vytvoøí všechny potøebné ovládací prvky.</p>

<pre>
    def vybudovatUI(self):
        <span class="comment"># Informace o souboru: Jméno a typ</span>
        fSoubor = Frame(self)
        Label(fSoubor, text="Jmeno souboru: ").pack(side=LEFT)
        self.eJmeno = Entry(fSoubor)
        self.eJmeno.insert(INSERT, "test.htm")
        self.eJmeno.pack(side=LEFT, padx=5)
        
        <span class="comment">
        # Pro zajištìní zarovnání pøepínacích tlaèítek (radio buttons)
        # se jménem potøebujeme další rámec.</span>
        fTyp = Frame(fSoubor, borderwidth=1, relief=SUNKEN)
        self.rText = Radiobutton(fTyp, text="text",
                                 variable = self.typ, value=2, 
                                 command=self.udalostText)
        self.rText.pack(side=TOP, anchor=W)
        self.rHTML = Radiobutton(fTyp, text="HTML",
                                 variable=self.typ, value=1,
                                 command=self.udalostHTML)
        self.rHTML.pack(side=TOP, anchor=W)
        <span class="comment"># Na poèátku vybereme 'text'</span>
        self.rText.select()
        fTyp.pack(side=RIGHT, padx=3)
        fSoubor.pack(side=TOP, fill=X)
        
        <span class="comment">
        # V textovém oknì se zobrazuje vıstup. Pouijeme vycpávku, abychom
        # získali rámeèek. Rodièovskım rámcem bude rámec celé aplikace
        # (tj. self)</span>
        self.txtBox = Text(self, width=60, height=10)
        self.txtBox.pack(side=TOP, padx=3, pady=3)
        
        <span class="comment">
        # Nakonec umístíme pøíkazová tlaèítka, která budou spouštìt èinnosti.</span>
        fTlacitka = Frame(self)
        self.bAnalyzuj = Button(fTlacitka, text="Analyzuj",
                                command=self.udalostAnalyzuj)
        self.bAnalyzuj.pack(side=LEFT, anchor=W, padx=50, pady=2)
        self.bReset = Button(fTlacitka, text="Reset",
                             command=self.udalostReset)
        self.bReset.pack(side=LEFT, padx=10)
        self.bKonec = Button(fTlacitka, text="Konec",
                             command=self.udalostUkonceni)
        self.bKonec.pack(side=RIGHT, anchor=E, padx=50, pady=2)
        
        fTlacitka.pack(side=BOTTOM, fill=X)
        self.pack()
</pre>

<p>Nebudu zde vysvìtlovat všechny detaily. Místo toho vám doporuèuji k
nahlédnutí uèebnici Tkinter, kterou naleznete na webovıch stránkách jazyka
Python. Jde o vynikající úvod i referenèní pøíruèku k Tkinter. Obecnı
princip <span class="trnote" title="Poznámka pøekladatele">uvedeného
kódu</span> spoèívá ve vytváøení ovládacích prvkù odpovídajících tøíd, pøi
kterém zadáváme nastavení formou <em>pojmenovanıch parametrù</em>. Poté je
pøíslušnı prvek umístìn do svého obklopujícího rámce voláním metody
<code>pack</code>.</p>

<p>Poznamenejme, e k dalším klíèovım bodùm patøí pouití pomocnıch prvkù
typu <code>Frame</code>, které sdruují pøepínací a pøíkazová tlaèítka.
U pøepínacích tlaèítek (radio buttons) se mimo jiné uvádí dvojice parametrù
s názvy <code>variable</code> (promìnná) a <code>value</code> (hodnota).
První z uvedenıch svazuje pøepínací tlaèítka dohromady tím, e udává stejnou
vnìjší promìnnou (<code>self.typ</code>). Druhı parametr pøidìluje kadému
pøepínacímu tlaèítku jednoznaènou hodnotu. Všimnìte si také parametru
<code>command=xxx</code>, kterı se pøedává prvkùm tlaèítek. Jde o metody,
které bude Tkinter volat v okamiku stisku tlaèítka. Jejich kód je uveden
níe:</p>

<pre>
    <span class="comment">
    ################# Metody pro ošetøení událostí ####################
    # je naèase vše skoncovat...</span>
    def udalostUkonceni(self):
        import sys
        sys.exit()
    
    <span class="comment">
    # nastavíme vše do poèáteèního stavu</span>
    def udalostReset(self):
        self.txtBox.delete(1.0, END)
        self.rText.select()
    
    <span class="comment">
    # nastavíme hodnotu pøepínacího tlaèítka</span>
    def udalostText(self):
        self.typ = 2
    
    def udalostHTML(self):
        self.typ = 1
</pre>

<p>Uvedené metody jsou velmi jednoduché a doufám, e není nutné je
vysvìtlovat. Poslední metoda pro ošetøení události zajišuje provedení
analızy:</p>

<pre>
    <span class="comment">
    # Vytvoøíme odpovídající typ dokumentu a provedeme analızu.
    # Poté zobrazíme vısledky v podobì øetìzcù.</span>
    def udalostAnalyzuj(self):
        jmenoSouboru = self.eJmeno.get()
        if jmenoSouboru == "":
            self.txtBox.insert(END,"\nNo filename provided!\n")
            return
        if self.typ == 2:
            doc = dokument.TextovyDokument(jmenoSouboru)
        else:
            doc = dokument.HTMLDokument(jmenoSouboru)
        self.txtBox.insert(END, "\nAnalyzuji...\n")
        doc.Analyzuj()
        str = doc.format % (doc.jmenoSouboru,
                            doc.poc_odstavcu, doc.poc_radku,
                            doc.poc_vet, doc.poc_klauzuli, doc.poc_slov)
        self.txtBox.insert(END, str)
</pre>

<p>I vıše uvedenı text byste ji mìli bıt schopni pøeèíst a pochopit, co
dìlá. Jeho klíèové body jsou následující:</p>

<ul>
<li>Pøed vytvoøením objektu tøídy Dokument zkontroluje platnost zadaného 
  jména souboru.</li>
<li>Konkrétní typ dokumentu je vytvoøen podle hodnoty promìnné
  <code>self.typ</code>, která je nastavena podle pøepínacích tlaèítek.</li>  
<li>Vısledek je pøipojen na konec obsahu okna s textem (viz argument
  <code>END</code> metody <code>insert</code>. To znamená, e mùeme provést
  nìkolik analız a porovnávat vısledky. Ve srovnání s døíve zmínìnım
  pøístupem, kdy by byly vısledky zobrazovány formou ovládacích prvkù s
  popisnım textem (label), jde o jednu z vıhod pouití vıstupu do okna s
  textem.</li>
</ul>

<p>Teï u nám zbıvá jen vytvoøit hlavní objekt aplikace a spustit smyèku
pro zpracování událostí:</p>

<pre>
mojeAplikace = AplikaceGramatika()
mojeAplikace.mainloop()
</pre>

<p>Podívejme se, jak vypadá koneènı vısledek pøi spuštìní v systému
MS&nbsp;Windows. Zobrazeny jsou vısledky analızy testovacího HTML souboru;
nejdøíve v reimu <em>text</em> a poté v reimu <em>HTML</em>:</p>

<p class="center"><img src="czgui.png" alt="Koneènı vzhled aplikace." 
title="Koneènı vzhled aplikace."></p>

<p>A je to. Pokud chcete, mùete pokraèovat ve zdokonalování zpracování
HTML. Mùete vytvoøit nové moduly pro nové typy dokumentù. Mùete zkusit
zamìnit okno s textem za nìkolik prvkù s popisnım textem vloenıch do rámce.
Ale z pohledu našeho pùvodního zámìru jsme hotovi. Následující kapitola
nabízí námìty k dalšímu studiu v závislosti na vašich programátorskıch
tubách. Hlavní je, aby vás to bavilo. A vdycky si pamatujte: <em>Poèítaè
je hloupı!</em></p>

<hr>
<div class="foot">
<p class="navig">[ 
<a href="cztutfctnl.html" title="Funkcionální programování">pøedchozí</a> |
<a href="cztutcont.html">obsah</a> | 
<a href="cztutrefs.html" title="Odkazy na další zdroje">další</a> 
]</p>
<p class="note">Pokud vás napadne, co by se dalo na pøekladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztutcase.html,v 1.7 2005/10/07 19:07:04 petr Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka' 
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20') 
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script> 

Tím budou do dopisu automaticky vloeny informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztutcase.html,v 1.7 2005/10/07 19:07:04 petr Exp $</p>
</div>
</body>
</html>


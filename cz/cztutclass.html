<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se nauèit programovat: OOP</title>
</head>
<body>

<p class="ir">Níe uvedenı text pochází z prvního vydání. Nad tímto textem 
se nachází aktuální stav po revizi smìøující k druhému vydání.</p>

<h2>Objektovì orientované programování</h2>

<h3>Co to vùbec je?</h3>

<p>Nyní se pustíme do nìèeho, co se do doby asi pøed pìti lety povaovalo za
nároèné téma. V souèasnosti se ji <em>objektovì orientované
programování</em> stalo normou. Jazyky, jako jsou Java a Python ztìlesòují
tento koncept do té míry, e se setkání s objekty nevyhnete ji pøi
programování jednoduchıch vìcí. Take o èem vlastnì objektové programování
pojednává?</p>

<p>Podle mého názoru k nejlepším úvodùm do problematiky patøí:</p>

<ul>
<li><em>Object Oriented Analysis</em> autorù Peter Coad &amp; Ed Yourdon.</li>
<li><em>Object Oriented Analysis and Design with Applications</em>
autora jménem Grady Booch (první vydání &mdash; pokud se vám je podaøí
sehnat).</li>
<li><em>Object Oriented Software Construction</em> autora jménem Bertrand
Meyer (urèitì chtìjte druhé vydání).</li>
</ul>

<p class="trnote"><b>Poznámka pøekladatele:</b> Není mi známo, e by uvedená
literatura byla pøeloena do èeského jazyka. Pokud je skuteènost jiná, dejte
mi, prosím, vìdìt.</p>

<p>Knihy jsou uvedeny v poøadí rostoucí hloubky, velikosti a akademické
exaktnosti. Vìtšinì neprofesionálních programátorù bude vyhovovat první
kniha. Úvod, kterı je více zamìøen na programování, naleznete v <em>Object
Oriented Programming</em> autora jménem Timothy Budd (druhé vydání). Osobnì
jsem tuto knihu neèetl, ale opìvují ji recenze lidí, jejich názorù si
váím.</p>

<p>A koneènì celou hromadu informací o všech monıch tématech kolem
objektovì orientovaného programování (OOP) naleznete na webovıch stránkách
<a href="http://www.cetus-links.org" target="_blank">http://www.cetus-links.org</a>.</p>

<p>Protoe pøedpokládám, e teï nemáte èas ani sklony k tomu, abyste zkoumali
obsah všech uvedenıch knih a odkazù, pøedloím vám struènı pøehled tohoto
konceptu. (<b>Poznámka:</b> Nìkterım lidem se koncept objektové orientace zdá
tìce pochopitelnı, jinım <em>sedne</em> hned. Pokud patøíte k té první
kategorii, netrapte se tím. Objekty mùete docela dobøe pouívat i v
pøípadì, e vám jejich vıhody nejsou zcela zøejmé.)</p>

<p>A ještì jedna poznámka na závìr. V této èásti budeme pouívat pouze
Python, protoe ani BASIC, ani Tcl objekty nepodporují. Pøi dodrování
urèitıch konvencí zápisu kódu lze koncept objektovì orientovaného návrhu
vyuít i v jazycích, které nejsou objektovì orientované, ale v takovém
pøípadì jde spíše jen o moné vıchodisko z nouze ne o doporuèovanou
strategii. Pokud je váš problém vıhodnì øešitelnı technikami objektovì
orientovaného návrhu a programování, pak je vdy nejlepší, kdy pouijete
objektovì orientovanı jazyk.</p>

<h3>Dejme data a funkce dohromady</h3>

<p>Objekty v sobì zahrnují nejen data ale i funkce, které nad uvedenımi daty
pracují. Data i funkce jsou svázány dohromady takovım zpùsobem, e objekt
mùete pøedat z jedné èásti programu do druhé a obì èásti mohou pøistupovat
nejen k datovım <em>atributùm</em>, ale pøístupné jsou i
<em>operace</em>.</p>

<p>Take napøíklad objekt typu øetìzec (string) poskytuje nejen prostor pro
uloení znakù øetìzce, ale poskytuje i <em>metody</em> pro provádìní operací
nad uloenım øetìzcem &mdash; vyhledávání, zmìnu malıch písmen na velká,
urèení délky øetìzce a podobnì.</p>

<p>V souvislosti s objekty se hovoøí o komunikaci <em>zasíláním zpráv</em>.
Jeden objekt zašle jinému objektu zprávu a pøijímající objekt na ni
zareaguje provedením jedné ze svıch operací, takzvané <em>metody</em>. Take
øíkáme, e metoda je vlastním objektem <em>vyvolána</em> pøi pøíjmu
odpovídající zprávy. Zpùsob zápisu tohoto obratu bıvá rùznı, ale nejbìnìjší
z nich se snaí napodobit pøístup ke slokám záznamu &mdash; pouívá teèkové
notace. Take pro tøídu fiktivního prvku (widget<sup class="trnote"><a 
href="cztuttrn.html#Pclass_widget" id="Bclass_widget"
title="Vysvìtlení pojmu widget...">[1]</a></sup>) mùeme psát:</p>

<pre>
w = Widget() <span class="comment"># vytvoø novou instanci w tøídy Widget()</span>
w.paint()    <span class="comment"># zašli mu zprávu 'paint' (tj. 'vykresli')</span>
</pre>

<p>Tento zápis zpùsobí, e bude vyvolána metoda <code>paint()</code>.</p> 

<p class="trnote"><b>Poznámka pøekladatele:</b> Pøipomeòme si znovu, e je to
vnitøní funkce objektu. Zatímco v neobjektovıch jazycích (napøíklad Pascal,
C) se tento zápis pouíval pouze pro zpøístupnìní datovıch sloek záznamu, u
objektovì orientovanıch jazykù se pouívá jak pro zpøístupnìní datovıch
sloek objektu (v tomto smyslu je objekt toté, co v neobjektovıch jazycích
záznam), tak pro zpøístupnìní jeho vnitøních funkcí (øíká se jim také
èlenské funkce, protoe jsou èleny objektu nebo tøídy). Ale nejpouívanìjším
a obecnì srozumitelnım pojmem pro takové funkce je <em>metoda</em>. To, e
se nejedná o datovou sloku záznamu (nebo objektu) se v rùznıch jazycích
obvykle vyjadøuje tím, e zápis pøipomíná volání funkce. Typicky se za
identifikátor metody zapisují kulaté závorky. V nich se mohou uvádìt i
poadované argumenty &mdash; jako u funkcí.</p>


<h3 id="class_def">Definice tøíd</h3>

<p>Objekty mohou bıt rùzného typu ve stejném smyslu, jako mohou bıt i data
rùzného typu. Mnoina objektù se shodnımi charakteristikami je známa pod pojmem
<em>tøída</em>. Tøídu mùeme nadefinovat a potom mùeme vytváøet <em>instance</em>
této tøídy, co jsou vlastnì skuteèné objekty. Odkazy (reference) na tyto
objekty mùeme v našem programu ukládat do promìnnıch.</p>

<p>Podívejme se na konkrétní pøíklad a uvidíme, jestli se to podaøí
vysvìtlit lépe. Vytvoøíme tøídu <code>Zprava</code>, která bude popisovat
existenci datové sloky typu øetìzec &mdash; tj. textu zprávy &mdash; a
metodu k vytištìní (zobrazení) zprávy (<code>vytisknout</code>).</p>

<pre>
class Zprava:
    def __init__(self, retezec):
        self.text = retezec
        
    def vytisknout(self):
        print self.text
</pre>

<p><b>Poznámka 1:</b> Jedna z metod této tøídy se nazıvá
<code>__init__</code>. Jde o speciální metodu, které se øíká
<em>konstruktor</em>. Øíká se jí tak, protoe se volá v okamiku vytváøení
(konstruování) nové instance objektu. Pokud uvnitø této metody nìjaké
promìnné nìco pøiøadíme (co v jazyce Python zajistí její vytvoøení), pak
bude tato promìnná patøit vıhradnì nové instanci. V jazyce Python existuje
øada podobnıch metod. Témìø všechny podobné jsou od zbytku odlišeny tím, e
pouívají speciální tvar jména <code>__xxx__</code> <span class="trnote"
title="Poznámka pøekladatele">(tedy dva znaky podtrení, slovo a opìt dva
znaky podtrení)</span>.</p>

<p><b>Poznámka 2:</b> Obì uvedené metody pouívají první parametr
<code>self</code>. <span class="trnote" title="Poznámka pøekladatele">(Pøi
personifikaci objektu by se to dalo pøeloit jako <em>já</em> nebo <em>já
sám</em>.)</span> Toto pojmenování je dáno pouze konvencí, ale vhodnì
vyjadøuje vıskyt (existenci) objektu. Jak uvidíme pozdìji, tento parametr
bude naplnìn a za bìhu, a to interpretem &mdash; nikoliv tedy
programátorem. To jinımi slovy znamená, e metoda <code>vytiskni</code> bude
volána bez zadávání argumentù takto: <code>m.vytiskni()</code>.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> Teoreticky bychom tomuto
parametru mohli pøidìlit jakékoliv jméno, ale øada pomocnıch nástrojù
pøedpokládá dodrování této konvence. Navíc tomu všichni uivatelé jazyka
Python rozumí na první pohled. Pokud nejde o pouhé pokusy, nepouívejte jiné
jméno prvního parametru. Dodrujte uvedenou konvenci i vy.</p>

<p><b>Poznámka 3:</b> Uvedenou tøídu jsme pojmenovali <code>Zprava</code> s
velkım 'Z'. Jde opìt pouze o konvenci, která se ovšem pouívá velmi èasto, a
to nejen v jazyce Python, ale i v jinıch objektovì orientovanıch jazycích.
Daná konvence øíká, e jména metod by mìla zaèínat malım písmenem a další
slova, ze kterıch se jméno metody skládá, by mìla zaèínat velkım písmenem.
Take napøíklad metody "vypoèítej stav úètu" bychom zapsali:
<code>vypocitejStavUctu</code>.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> pojmy <em>tøída</em> a
<em>instance tøídy</em> (tedy objekt) jsou velmi dùleité. Bez jejich
dokonalého pochopení budete v problematice objektovì orientovaného
programování jen tápat. Pokud se povaujete za laiky, mohl by vám vìc
osvìtlit vıklad tìchto pojmù napasovanı na Pohádku o Popelce<sup
class="trnote" id="Bclass_class" title="Pohádku o Popelce"><a
href="cztuttrn.html#Pclass_class" >[2]</a></sup>.</p>

<p>V tomto okamiku se moná budete chtít znovu podívat na kapitolu <a
href="cztutdata.html">Data, datové typy a promìnné</a> a zopakovat si
<em>uivatelsky definované typy</em>. <a href="cztutdata.html#address"
>Pøíklad s adresou</a> by mìl bıt nyní o nìco jasnìjší.</p>

<p><em>Tøída</em> je v jazyce Python v podstatì jedinım uivatelsky
definovanım typem. Tøída, která má pouze atributy <span class="trnote"
title="Poznámka pøekladatele">(datové sloky)</span>, ale ádné metody (s
vıjimkou <code>__init__</code>), odpovídá záznamùm v jazyce BASIC <span
class="trnote" title="Poznámka pøekladatele">a v jinıch neobjektovıch
jazycích</span>.</p>


<h3>Pouívání tøíd</h3>

<p>Teï, kdy u máme definovánu tøídu <code>Zprava</code>, mùeme vytváøet
její instance a mùeme s nimi manipulovat:</p>

<pre>
z1 = Zprava("Ahoj lidi!")
z2 = Zprava("Sbohem. Bylo to krátké, ale sladké.")

poznamky = [z1, z2]  <span class="comment"># vlo objekty do seznamu</span>
for zpr in poznamky:
    zpr.vytisknout() <span class="comment"># kadou zprávu vytiskni</span>
</pre>

<p>Take vidíme, e s tøídou zacházíme, jako kdyby to byl standardní datovı
typ jazyka Python. A to byl vlastnì cíl tohoto cvièení.</p>


<h3>Kdy dva dìlají toté, není to toté...</h3>

<p>Zatím tedy umíme definovat své vlastní typy (tøídy), umíme vytváøet
jejich instance a umíme je pøiøazovat do promìnnıch. Tìmto objektùm
(instancím) pak mùeme zasílat zprávy, co zpùsobí provedení metod, které
jsme definovali. Ale co se tıká objektovì orientovaného pøísupu, je zde
ještì jedna vìc. Z mnoha pohledù jde o nejdùleitìjší vlastnost vùbec.</p>

<p id="polymorfismus">Mìjme dva objekty rùznıch tøíd, které podporují
stejnou mnoinu zpráv, ale definují své vlastní odpovídající metody. V
takovém pøípadì mùeme tyto objekty udrovat ve spoleèné kolekci a v našem
programu s nimi mùeme zacházet stejnım zpùsobem. Objekty se však budou
chovat kadı jinak (po svém). Této schopnosti &mdash; chovat se jinak pøi
zpracování stejné zprávy &mdash; se øíká <em>polymorfismus</em> <span
class="trnote" title="Poznámka pøekladatele">(doslova
<em>mnohotvárnost</em>, ale nepøekládá se)</span>.</p>

<p>Typicky se toho vyuívá napøíklad pøi existenci nìkolika rùznıch
grfickıch objektù, které se umí vykreslit, kdy obdrí zprávu 'paint'.
Objekt kruhu vykreslí ve srovnání s objektem trojúhelníku velmi odlišnı
obrazec, ale pokud oba definují metodu <code>paint</code>, mùeme tento
rozdíl jako programátoøi ignorovat a mùeme o nich uvaovat jako o
<em>tvarech</em>.</p>

<p>Podívejme se na pøíklad, kde místo vykreslování tvarù budeme vypoèítávat
jejich plochy. Nejdøíve vytvoøíme tøídy <code>Ctverec</code> a
<code>Kruh</code>:</p>

<pre>
class Ctverec:
    def __init__(self, strana):
        self.strana = strana
    def vypocitejPlochu(self):
        return self.strana**2

class Kruh:
    def __init__(self, polomer):
        self.polomer = polomer
    def vypocitejPlochu(self):
        import math
        return math.pi*(self.polomer**2)
</pre>

<p>Nyní vytvoøíme seznam tvarù (buï kruhù nebo ètvercù) a poté vytiskneme
jejich plochy:</p>

<pre>
seznam = [Kruh(5), Kruh(7), Ctverec(9), Kruh(3), Ctverec(12)]

for tvar in seznam:
    print "Plocha je: ", tvar.vypocitejPlochu()
</pre>

<p>Pokud nyní zkombinujeme uvedené myšlenky s moduly, dostaneme velmi mocnı
mechanismus pro opakované pouití kódu. Ulome definice tøíd do modulu
&mdash; øeknìme <code>tvary.py</code> &mdash; a kdy potom budeme chtít
manipulovat s tvary, jednoduše nejdøíve provedeme import tohoto modulu.
Pøesnì takto je do systému Python zaøazena øada standardních modulù. To je
dùvod, proè se pøístup k metodám objektu tolik podobá pouívání funkcí z
modulu.</p>


<h3>Dìdiènost</h3>

<p>Dìdiènost se èasto pouívá jako mechanismus pro implementování
polymorfismu. V mnoha objektovì orientovanıch jazycích je to ve skuteènosti
jedinı zpùsob pro implementování polymorfismu. Funguje to následovnì.</p>

<p>Tøída mùe z <em>rodièovské tøídy</em> nebo také <em>nadtøídy</em>
(super class) <em>dìdit</em> jak atributy (datové prvky) tak operace. To
znamená, e nová tøída, která se ve vìtšinì vìcí podobá jiné tøídì, nemusí
znovu implementovat všechy metody existující tøídy. Místo toho mùe její
schopnosti zdìdit a <em>pøedefinovat</em> (override) jen to, co se má dìlat
jinak (napøíklad metodu pro vykreslování, o které jsme se zmínili ve vıše
uvedeném pøípadì).</p>

<p>Nejlepší bude ukázat vše na pøíkladu. Vytvoøíme <em>hierarchii tøíd</em>
pro bankovní úèty, u kterıch mùeme ukládat hotovost, zjišovat stav úètu a
realizovat vıbìr. Nìkteré z úètù poskytují úroky (pro naše úèely budeme
pøedpokládat, e úrok je vypoèítán pøi kadém vkladu &mdash; zajímavá
inovace pro bankovní svìt) a u jinıch se pøi vıbìru úètuje poplatek.</p>

<h4>Tøída BankovniUcet</h4>

<p>Podívejme se, jak by to mohlo vypadat. Nejdøíve uvame atributy a operace
bankovního úètu na nejobecnìjší (nebo <em>abstraktní</em>) úrovni.</p>

<p>Obvykle je nejlepší uvaovat nejdøíve o operacích a teprve podle potøeby
doplnit atributy tak, abychom mohli oprerace realizovat. Take u bankovního 
úètu mùeme:</p>

<ul>
<li>Vkládat hotovost,</li>
<li>vybírat hotovost,</li>
<li>zjišovat souèasnı stav úètu a </li>
<li>pøevádìt peníze na jinı úèet.</li>
</ul>

<p>Pro tyto operace potøebujeme znát èíslo bankovního úètu (pro operaci
pøevodu) a souèasnı stav úètu. Vytvoøme odpovídající tøídu:</p>

<pre>
class ChybaZustatku(Exception): pass

class BankovniUcet:
    def __init__(self, pocatecniVklad):
        self.stav = pocatecniVklad
        print "Byl zaloen úèet s poèáteèním stavem %5.2f korun." % self.stav

    def vlozit(self, castka):
        self.stav = self.stav + castka

    def vybrat(self, castka):
        if self.stav >= castka:
            self.stav = self.stav - castka
        else:
            raise ChybaZustatku("Litujeme. Na vašem úètu je jen %6.2f korun." 
                                 % self.stav)

    def zustatek(self):
        return self.stav
                                                                                            
    def prevod(self, castka, ucet):
        try: 
            self.vybrat(castka)
            ucet.vlozit(castka)
        except ChybaZustatku, e:
            print str(e)
</pre>

<p><b>Poznámka 1:</b> Pøed vıbìrem z úètu kontrolujeme stav úètu a pro
ošetøení chyb pouíváme vıjimky. Chyba <code>ChybaZustatku</code> samozøejmì
neexistuje, take si ji musíme vytvoøit. <span class="ir">Definujeme ji
jako tøídu, která je odvozena od zabudované tøídy <code>Exception</code>. Ta
je bázovou tøídou všech zabudovanıch vıjimek systému Python a mìla by se
pouívat pro všechny uivatelsky definované vıjimky. Pøi vytváøení instance
této tøídy (pøíkazem <code>raise</code>) lze pøedat øetìzec, kterı lze z
objektu vıjimky extrahovat zabudovanou funkcí <code>str()</code>.</span>.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> V novìjších verzích jazyka
Python se pro vıjimky vdy doporuèuje pouívat tøídy, které odvodíme od
bázové tøídy <code>Except</code>. V roli instancí vıjimek se ji
nedoporuèuje pouívat øetìzce.</p>

<p><b>Poznámka 2:</b> Metoda <code>prevod</code> pouívá pro realizaci
pøevodu <em>èlenské funkce</em> neboli metody <code>vybrat</code> a
<code>vlozit</code> tøídy <code>BankovniUcet</code>. Tento pøístup je pøi
objektovì orientovaném programování velmi bìnı a je znám jako <em>zasílání
zpráv sobì samému</em> (self messaging). Znamená to, e <em>odvozené
tøídy</em> mohou implementovat své vlastní verze metod <code>vlozit</code> a
<code>vybrat</code>, pøièem metoda <code>prevod</code> mùe u všech typù
úètù zùstat stejná.</p>

<h4>Tøída UrocenyUcet</h4>

<p>Teï za pouití dìdiènosti vytvoøíme úèet, na kterı budou pøipisována
procenta (budeme pøedpokládat 3&nbsp;%) pøi kadém vkladu. Tøída se bude
shodovat s døíve uvedenou tøídou <code>BankovniUcet</code> s vıjimkou metody
<code>vlozit</code>. Jednoduše ji pøedefinujeme (override):</p>

<pre>
class UrocenyUcet(BankovniUcet):
    def vlozit(self, castka):
        BankovniUcet.vlozit(self, castka)
        self.stav = self.stav * 1.03
</pre>

<p>A je to! Zaèíná se ukazovat síla objektovì orientovaného programování.
Všechny ostatní metody byly zdìdìny z tøídy <code>BankovniUcet</code> (tím,
e jsme <code>BankovniUcet</code> uvedli do závorek za jméno nové tøídy).
Povšimnìte si, e metoda <code>vlozit</code> místo kopírování kódu radìji
volá metodu <code>vlozit</code> své <em>nadtøídy</em> (superclass). Take
pokud nyní upravíme metodu <code>vlozit</code> tøídy
<code>BankovniUcet</code> napøíklad pøidáním nìjakıch kontrol chyb, projeví
se tyto zmìny automaticky i v <em>podtøídì</em>.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> Místo pojmu
<em>nadtøída</em> (super class) se èasto pouívá pojem <em>bázová tøída</em>
(base class) a místo pojmu <em>podtøída</em> (sub-class) se èasto pouívá
pojem <em>odvozená tøída</em> (derrived class).</p>


<h4>Tøída UcetSPoplatkem</h4>

<p>Tento typ úètu se opìt shoduje s tøídou <code>BankovniUcet</code> pro
standardní bankovní úèet s tím rozdílem, e se tentokrát pøi kadém vıbìru
úètují tøi koruny. Stejnì jako v pøípadì tøídy <code>UrocenyUcet</code>
mùeme novou tøídu vytvoøit dìdìním z tøídy <code>BankovniUcet</code> a
úpravou metody <code>vybrat</code>.</p>

<pre>
class UcetSPoplatkem(BankovniUcet):
    def __init__(self, pocatecniVklad):
        BankovniUcet.__init__(self, pocatecniVklad)
        self.poplatek = 3
        
    def vybrat(self, castka):
        BankovniUcet.vybrat(self, castka + self.poplatek)
</pre>

<p><b>Poznámka 1:</b> Velikost poplatku je uloena v <em>èlenské
promìnné</em>, take ji podle potøeby mùeme pozdìji mìnit. Povšimnìte si,
e zdìdìnou metodu <code>__init__</code> mùeme volat stejnì jako kadou
jinou metodu.</p>

<p><b>Poznámka 2:</b> Poplatek jednoduše pøièítáme k poadované hodnotì
vıbìru a provedení celé operace zajistíme voláním metody <code>vybrat</code>
tøídy <code>BankovniUcet</code>.</p>

<p><b>Poznámka 3:</b> Vedlejším efektem tohoto postupu je to, e se poplatek
uplatní i pøi pøevodu na jinı úèet. Pravdìpodobnì to takto chceme, take je
to v poøádku.</p>


<h4>Testujeme náš systém</h4>

<p>Abychom si vyzkoušeli, e to všechno funguje, zkuste spustit následující
kus kódu (buï z pøíkazového øádku systému Python nebo vytvoøením souboru s
tìmito testy). <span class="trnote" title="Poznámka pøekladatele"
>Následující kód pøedpokládá, e jste vıše uvedené definice tøíd uloili do
souboru <code>bankovniucet.py</code>. Pokud byste je uloili do jiného
souboru, musíte zmìnit jméno modulu v prvním øádku souboru.</span></p>

<pre>
from bankovniucet import *

<span class="comment"># Nejdøíve vyzkoušíme standardní BankovniUcet.</span>
a = BankovniUcet(500)
b = BankovniUcet(200)
a.vybrat(100)
<span class="comment"># a.vybrat(1000)</span>
a.prevod(100, b)
print "A = ", a.zustatek()
print "B = ", b.zustatek()

<span class="comment"># Teï vyzkoušíme UrocenyUcet.</span>
c = UrocenyUcet(1000)
c.vlozit(100)
print "C = ", c.zustatek()

<span class="comment"># A ještì UcetSPoplatkem.</span>
d = UcetSPoplatkem(300)
d.vlozit(200)
print "D = ", d.zustatek()
d.vybrat(50)
print "D = ", d.zustatek()
d.prevod(100, a)
print "A = ", a.zustatek()
print "D = ", d.zustatek()

<span class="comment">
# A nakonec provedeme pøevod z úètu s poplatky na úroèenı úèet.
# Z úètu s poplatky by se mìl odeèíst i poplatek a na úroèeném 
# úètu by mìl pøibıt i úrok.</span>
print "C = ", c.zustatek()
print "D = ", d.zustatek()
d.prevod(20, c)
print "C = ", c.zustatek()
print "D = ", d.zustatek()
</pre>

<p>Nyní odkomentujte øádek <code>a.vybrat(1000)</code> a uvidíte, jak 
zafunguje vıjimka.</p>

<p>A je to. Jde o pomìrnì zjednodušenı pøíklad, ale ukazuje, jak mùeme
vyuít dìdiènosti k rychlému rozšíøení existující funkènosti o nové
rysy.</p>

<p>Ukázali jsme si, jak lze pøíklad vytvoøit po etapách a jak lze vytvoøit
testovací program, kterım funkènost øešení ovìøíme. Naše testy nebyly úplné
v tom smyslu, e jsme nepokryli všechny moné pøípady. Mohli bychom pøidat
také další kontroly. Co kdyby byl napøíklad vytvoøen úèet se zápornım
zùstatkem&hellip;</p>

<h3>Kolekce objektù</h3>

<p>Jedna z otázek, která vás mohla napadnout, zní: <em>Jak bychom mìli
zacházet s vìtším mnostvím objektù?</em> Nebo také: <em>Jak bychom
mìli zacházet s objekty, které vytvoøíme za bìhu programu?</em> Statické
vytvoøení objektù bankovních úètù &mdash; jak jsme to uènili vıše &mdash; je
velmi snadné:</p>

<pre>
ucet1 = BankovniUcet(...)
ucet2 = BankovniUcet(...)
ucet3 = BankovniUcet(...)
atd.
</pre>

<p>Ale u reálnıch øešení dopøedu nevíme kolik úètù budeme chtít vytvoøit.
Jak si s tím poradíme? Uvaujeme nyní o problému trochu podrobnìji.</p>

<p>Potøebujeme nìjakı druh <em>databáze</em>, která by nám dovolila nalézt
poadovanı bankovní úèet podle jména vlastníka (nebo spíše podle èísla úètu,
protoe jedna osoba mùe mít více úètù a také více lidí mùe mít stejné
jméno).</p>

<p>V kolekci potøebujeme nìco vyhledat podle jednoznaèného klíèe&hellip;
hmmm &mdash; to vypadá na pouití slovníku! <span class="trnote"
title="Poznámka pøekladatele">(Pøipomeòme si, e pro takto pojmenovanou
strukturu jazyka Python lze pouít i pojem <em>vyhledávací
tabulka</em>.)</span> Podívejme se, jak bychom pouili strukturu typu
slovník (dictionary) pro uloení dynamicky vytvoøenıch objektù.</p>

<pre>
from bankovniucet import *
import time

<span class="comment"># Funkce pro generování unikátních identifikaèních èísel.</span>
def ziskejDalsiID():
    ok = raw_input("Vytvoøit úèet [a/n]? ")
    if ok[0] in 'aA':        <span class="comment"># v pøípadì souhlasu...</span>
        id = time.time()     <span class="comment"># pouij aktuální èas jako základ ID,</span>
        id = int(id) % 10000 <span class="comment"># pøeveï na max. 4místné celé èíslo
        # Poznámka pøekladatele: time.time() vrací reálné èíslo
        # odpovídající èasu v sekundách (s pøesností obvykle 
        # lepší ne 1 sekunda).</span>
    else: id = -1            <span class="comment"># tato hodnota zastaví cyklus</span>
    return id
    
    
tabulkaUctu = {}  <span class="comment"># novı slovník</span>
while 1:          <span class="comment"># nekoneènı cyklus</span>
    id = ziskejDalsiID()
    if id == -1: 
        break     <span class="comment"># break násilnì ukonèí cyklus while</span>
    vklad = float(raw_input("Poèáteèní vklad? "))
    
    <span class="comment"># Identifikaci id pouijeme pro vytvoøení nové poloky tabulky.</span>
    tabulkaUctu[id] = BankovniUcet(vklad) 
    print "Byl vytvoøen novı úèet èíslo %04d s vkladem %0.2f" % (id, vklad)

<span class="comment"># Zobrazíme si zùstatky na všech úètech.</span>
for id in tabulkaUctu:  
    <span class="comment"># Poznámka pøekladatele: od Python 2.0 není nutné 
    # v zápisu cyklu uvádìt tabulkaUctu.keys(), jak tomu bylo 
    # u starších verzí.</span>
    print "%04d\t%0.2f" % (id, tabulkaUctu[id].zustatek())

<span class="comment"># Nyní vyhledáme konkrétní úèet. Pokud chcete ukonèit</span>
<span class="comment"># program, vlote neèíselnou hodnotu.</span>
while 1:
   id = int(raw_input("Zadejte èíslo úètu: "))
   if id in tabulkaUctu:
       print "Zùstatek = %0.2f" % tabulkaUctu[id].zustatek()
   else: print "Chybné èíslo úètu."
</pre>

<p>V roli klíèe, kterı se pouívá pro vyhledávání ve slovníku, mùe bıt
samozøejmì pouito cokoliv, co jednoznaènì identifikuje objekt. Mùe to bıt
nìjakı z jeho atributù, napøíklad jméno. Cokoliv, co je jednoznaèné. Moná
teï pro vás bude uiteèné, kdy si znovu projdete kapitolu <a
href="cztutdata.html">Data, datové typy a promìnné</a>, a pøeètete si
konkrétnì èást, která se tıká <a href="cztutdata.html#dictionary"
>slovníkù</a> <span class="trnote" title="Poznámka pøekladatele"
>(vyhledávacích tabulek)</span>. Jsou to opravdu velmi uiteèné
kontejnery.</p>

<h3>Ukládání vašich objektù</h3>

<p>Vıše uvedené øešení má jednu nevıhodu. Jakmile ukonèíte program, všechny
údaje budou ztraceny. Potøebujeme tedy nìjakı zpùsob pro ukládání objektù. S
vaším postupujícím programátorskım rùstem se pozdìji nauèíte, jak pro tento
úèel pouívat databáze. Ale v tomto okamiku nám bude pro ukládání a
opìtovné naèítání objektù staèit textovı soubor. Python definuje moduly
(zvané <code>Pickle</code> a <code>Shelve</code>), které umí s objekty v
tomto smyslu zacházet efektivnìji. Ale ukame si radìji generickı <span
class="trnote" title="Poznámka pøekladatele">(tedy <em>obecnì
pouitelnı</em>)</span> zpùsob, kterı by fungoval v libovolném programovacím
jazyce. Technickı termín pro schopnost uloení a opìtovné obnovení stavu
objektù se shodou okolností nazıvá <em>persistence</em>. <span
class="trnote" title="Poznámka pøekladatele">(Tento pojem se chápe jako
termín a obvykle se nepøekládá. Z hlediska vıznamu bychom jej ale mohli
pøeloit jako <em>schopnost pøetrvat</em> &mdash; rozumí se uchovat svùj
stav po dobu, kdy aplikace nebìí.)</span></p>

<p>Generickı <span class="trnote" title="Poznámka pøekladatele">(tedy
<em>obecnì pouitelnı</em>)</span> zpùsob spoèívá ve vytvoøení metod
<code>save</code> a <code>restore</code> v objektu nejvyšší úrovnì <span
class="trnote" title="Poznámka pøekladatele">(poznámka pøekladatele: autor
má na mysli <em>bázovou tøídu</em>)</span> a pøedefinujeme je v kadé <span
class="trnote" title="Poznámka pøekladatele">odvozené</span> tøídì tak, e
nejdøíve zavolají zdìdìnou verzi a poté pøidají své lokálnì definované
atributy. <span class="trnote">Poznámka pøekladatele: Tyto metody nebudeme
pøekládat (save [sejv] = uloit; restore [ristór] = obnovit), protoe se jim
typicky dávají právì tato anglická jména.</span></p>

<pre>
class A:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def save(self, fn):
        f = open(fn, "w")    
        <span class="comment"># Poznámka pøekladatele: Od verze Python 2 by se 
        # mìla dávat pøednost zápisu f = file(fn, "w")</span>
        f.write(str(self.x) + '\n') <span class="comment"># pøeveï na øetìzec</span>
        f.write(str(self.y) + '\n')
        return f  <span class="comment"># do stejného souboru budou své hodnoty</span>
                  <span class="comment"># pøipisovat objekty odvozenıch tøíd</span>

    def restore(self, fn):
        f = open(fn)
        self.x = int(f.readline()) <span class="comment"># pøeveï zpìt na pùvodní typ</span>
        self.y = int(f.readline())
        return f             
     
class B(A):
    def __init__(self, x, y, z):
        A.__init__(self, x, y)
        self.z = z
   
    def save(self, fn):
        f = A.save(self, fn)         <span class="comment"># zavolej rodièovskou metodu</span>
        f.write(str(self.z) + '\n')  <span class="comment"># pøidej vlastní hodnoty</span>
        return f                     <span class="comment"># pro pøípadné další potomky</span>
   
    def restore(self, fn):
        f = A.restore(self, fn)
        self.z = int(f.readline())
        return f

<span class="comment"># Vytvoøíme instance.</span>
a = A(1, 2)
b = B(3, 4, 5)

<span class="comment"># Uloíme instance.</span>
a.save('a.txt').close() <span class="comment"># nezapomeò uzavøít soubor</span>
b.save('b.txt').close()

<span class="comment"># Obnovíme instance.</span>
newA = A(5, 6)
newA.restore('a.txt').close() <span class="comment"># nezapomeò uzavøít soubor</span>
newB = B(7, 8, 9)
newB.restore('b.txt').close()
print "A: ", newA.x, newA.y
print "B: ", newB.x, newB.y, newB.z
</pre>

<p class="note"><b>Poznámka:</b> Vytisknou se hodnoty, které jsou obnoveny
naètením ze souborù, nikoliv hodnoty, které jsme pouili pøi vytváøení
instancí.</p>

<p>Klíèovım poadavkem je pøedefinování metod <code>save</code> a
<code>restore</code> v kadé tøídì a také to, aby byla nejdøíve volána
rodièovská metoda <span class="trnote" title="Poznámka pøekladatele">(tj.
metoda bázové tøídy)</span>. V odvozené tøídì se pak musíme postarat pouze o
pøidané atributy. Zpùsob, jakım atribut pøevedeme na øetìzec a uloíme,
závisí samozøejmì na nás, ale musí bıt umístìn na zvláštním øádku. Pøi
obnovování jednoduše obrátíme postup, kterı jsme pouili pøi ukládání.</p>

<div class="trnote">

<p><b>Poznámka pøekladatele:</b> V uvedeném pøíkladu se skrıvá
problém. Otevøenı soubor by se mìl vdy
explicitnì uzavøít. V tomto smyslu je uvedené øešení pomìrnì nedokonalé. Pokud
se povaujete za zaèáteèníky, soustøeïte se pøedevším na hlavní myšlenku, kterou
autor prezentuje. Nespoléhejte na správnost pøíkladu v detailech.</p>

<p>Pøi práci se soubory by se mìlo pouívat nepsané pravidlo, které øíká, e
soubor by se mìl uzavírat na stejné úrovni, kde se otevøel. Tím se obvykle
vyhneme komplikacím s pøedáváním odpovìdnosti za uzavøení souboru do
volaného kódu nebo naopak do volajícího kódu. Z tohoto pravidla vyplıvá, e
by se místo textového jména souboru mìl metodám <code>save()</code> a
<code>restore()</code> pøedávat ji objekt otevøeného souboru.</p>

<p>Další problém spoèívá v tom, e explicitnì urèujeme jméno souboru, do
kterého se objekt ukládá. Pokud byste nìkdy takto vybudovanou tøídu chtìli
pouít napøíklad v jiné aplikaci, mohli byste se setkat s komplikacemi.</p>

<p>V tomto místì pokládám za vhodné zmínit se o tom, e u odvozené tøídy
<em>musíme sami zajistit</em> uvnitø metody <code>__init__()</code> volání
stejnojmenné metody bázové tøídy, které jako první parametr pøedáváme
<code>self</code>.</p>
</div>

<p>Doufám, e vám tato kapitola dala pøièichnout k objektovì orientovanému
programování. Další informace a pøíklady mùete nalézt v nìjaké dalším
on-line uèebnici nebo si mùete pøeèíst nìkterou z knih, o kterıch jsme se
zmiòovali na zaèátku.</p>

<hr>
<div class="foot">
<p class="navig">[ 
<a href="cztutrecur.html" title="Rekurze...">pøedchozí</a> |
<a href="cztutcont.html">obsah</a> | 
<a href="cztutname.html" title="Prostory jmen">další</a> 
]</p>
<p class="note">Pokud vás napadne, co by se dalo na pøekladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztutclass.html,v 1.6 2004/08/31 11:55:12 prikryl Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka' 
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20') 
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script> 

Tím budou do dopisu automaticky vloeny informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztutclass.html,v 1.6 2004/08/31 11:55:12 prikryl Exp $</p>
</div>
</body>
</html>


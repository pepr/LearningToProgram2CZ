<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se naučit programovat: OOP</title>
</head>
<body>

<p class="ir">Níže uvedený text pochází z prvního vydání. Nad tímto textem
se nachází aktuální stav po revizi směřující k druhému vydání.</p>

<h2>Objektově orientované programování</h2>

<h3>Co to vůbec je?</h3>

<p>Nyní se pustíme do něčeho, co se do doby asi před pěti lety považovalo za
náročné téma. V současnosti se již <em>objektově orientované
programování</em> stalo normou. Jazyky, jako jsou Java a Python ztělesňují
tento koncept do té míry, že se setkání s objekty nevyhnete již při
programování jednoduchých věcí. Takže o čem vlastně objektové programování
pojednává?</p>

<p>Podle mého názoru k nejlepším úvodům do problematiky patří:</p>

<ul>
<li><em>Object Oriented Analysis</em> autorů Peter Coad &amp; Ed Yourdon.</li>
<li><em>Object Oriented Analysis and Design with Applications</em>
autora jménem Grady Booch (první vydání &mdash; pokud se vám je podaří
sehnat).</li>
<li><em>Object Oriented Software Construction</em> autora jménem Bertrand
Meyer (určitě chtějte druhé vydání).</li>
</ul>

<p class="trnote"><b>Poznámka překladatele:</b> Není mi známo, že by uvedená
literatura byla přeložena do českého jazyka. Pokud je skutečnost jiná, dejte
mi, prosím, vědět.</p>

<p>Knihy jsou uvedeny v pořadí rostoucí hloubky, velikosti a akademické
exaktnosti. Většině neprofesionálních programátorů bude vyhovovat první
kniha. Úvod, který je více zaměřen na programování, naleznete v <em>Object
Oriented Programming</em> autora jménem Timothy Budd (druhé vydání). Osobně
jsem tuto knihu nečetl, ale opěvují ji recenze lidí, jejichž názorů si
vážím.</p>

<p>A konečně celou hromadu informací o všech možných tématech kolem
objektově orientovaného programování (OOP) naleznete na webových stránkách
<a href="http://www.cetus-links.org" target="_blank">http://www.cetus-links.org</a>.</p>

<p>Protože předpokládám, že teď nemáte čas ani sklony k tomu, abyste zkoumali
obsah všech uvedených knih a odkazů, předložím vám stručný přehled tohoto
konceptu. (<b>Poznámka:</b> Některým lidem se koncept objektové orientace zdá
těžce pochopitelný, jiným <em>sedne</em> hned. Pokud patříte k té první
kategorii, netrapte se tím. Objekty můžete docela dobře používat i v
případě, že vám jejich výhody nejsou zcela zřejmé.)</p>

<p>A ještě jedna poznámka na závěr. V této části budeme používat pouze
Python, protože ani BASIC, ani Tcl objekty nepodporují. Při dodržování
určitých konvencí zápisu kódu lze koncept objektově orientovaného návrhu
využít i v jazycích, které nejsou objektově orientované, ale v takovém
případě jde spíše jen o možné východisko z nouze než o doporučovanou
strategii. Pokud je váš problém výhodně řešitelný technikami objektově
orientovaného návrhu a programování, pak je vždy nejlepší, když použijete
objektově orientovaný jazyk.</p>

<h3>Dejme data a funkce dohromady</h3>

<p>Objekty v sobě zahrnují nejen data ale i funkce, které nad uvedenými daty
pracují. Data i funkce jsou svázány dohromady takovým způsobem, že objekt
můžete předat z jedné části programu do druhé a obě části mohou přistupovat
nejen k datovým <em>atributům</em>, ale přístupné jsou i
<em>operace</em>.</p>

<p>Takže například objekt typu řetězec (string) poskytuje nejen prostor pro
uložení znaků řetězce, ale poskytuje i <em>metody</em> pro provádění operací
nad uloženým řetězcem &mdash; vyhledávání, změnu malých písmen na velká,
určení délky řetězce a podobně.</p>

<p>V souvislosti s objekty se hovoří o komunikaci <em>zasíláním zpráv</em>.
Jeden objekt zašle jinému objektu zprávu a přijímající objekt na ni
zareaguje provedením jedné ze svých operací, takzvané <em>metody</em>. Takže
říkáme, že metoda je vlastním objektem <em>vyvolána</em> při příjmu
odpovídající zprávy. Způsob zápisu tohoto obratu bývá různý, ale nejběžnější
z nich se snaží napodobit přístup ke složkám záznamu &mdash; používá tečkové
notace. Takže pro třídu fiktivního prvku (widget<sup class="trnote"><a
href="cztuttrn.html#Pclass_widget" id="Bclass_widget"
title="Vysvětlení pojmu widget...">[1]</a></sup>) můžeme psát:</p>

<pre>
w = Widget() <span class="comment"># vytvoř novou instanci w třídy Widget()</span>
w.paint()    <span class="comment"># zašli mu zprávu 'paint' (tj. 'vykresli')</span>
</pre>

<p>Tento zápis způsobí, že bude vyvolána metoda <code>paint()</code>.</p>

<p class="trnote"><b>Poznámka překladatele:</b> Připomeňme si znovu, že je to
vnitřní funkce objektu. Zatímco v neobjektových jazycích (například Pascal,
C) se tento zápis používal pouze pro zpřístupnění datových složek záznamu, u
objektově orientovaných jazyků se používá jak pro zpřístupnění datových
složek objektu (v tomto smyslu je objekt totéž, co v neobjektových jazycích
záznam), tak pro zpřístupnění jeho vnitřních funkcí (říká se jim také
členské funkce, protože jsou členy objektu nebo třídy). Ale nejpoužívanějším
a obecně srozumitelným pojmem pro takové funkce je <em>metoda</em>. To, že
se nejedná o datovou složku záznamu (nebo objektu) se v různých jazycích
obvykle vyjadřuje tím, že zápis připomíná volání funkce. Typicky se za
identifikátor metody zapisují kulaté závorky. V nich se mohou uvádět i
požadované argumenty &mdash; jako u funkcí.</p>


<h3 id="class_def">Definice tříd</h3>

<p>Objekty mohou být různého typu ve stejném smyslu, jako mohou být i data
různého typu. Množina objektů se shodnými charakteristikami je známa pod pojmem
<em>třída</em>. Třídu můžeme nadefinovat a potom můžeme vytvářet <em>instance</em>
této třídy, což jsou vlastně skutečné objekty. Odkazy (reference) na tyto
objekty můžeme v našem programu ukládat do proměnných.</p>

<p>Podívejme se na konkrétní příklad a uvidíme, jestli se to podaří
vysvětlit lépe. Vytvoříme třídu <code>Zprava</code>, která bude popisovat
existenci datové složky typu řetězec &mdash; tj. textu zprávy &mdash; a
metodu k vytištění (zobrazení) zprávy (<code>vytisknout</code>).</p>

<pre>
class Zprava:
    def __init__(self, retezec):
        self.text = retezec

    def vytisknout(self):
        print self.text
</pre>

<p><b>Poznámka 1:</b> Jedna z metod této třídy se nazývá
<code>__init__</code>. Jde o speciální metodu, které se říká
<em>konstruktor</em>. Říká se jí tak, protože se volá v okamžiku vytváření
(konstruování) nové instance objektu. Pokud uvnitř této metody nějaké
proměnné něco přiřadíme (což v jazyce Python zajistí její vytvoření), pak
bude tato proměnná patřit výhradně nové instanci. V jazyce Python existuje
řada podobných metod. Téměř všechny podobné jsou od zbytku odlišeny tím, že
používají speciální tvar jména <code>__xxx__</code> <span class="trnote"
title="Poznámka překladatele">(tedy dva znaky podtržení, slovo a opět dva
znaky podtržení)</span>.</p>

<p><b>Poznámka 2:</b> Obě uvedené metody používají první parametr
<code>self</code>. <span class="trnote" title="Poznámka překladatele">(Při
personifikaci objektu by se to dalo přeložit jako <em>já</em> nebo <em>já
sám</em>.)</span> Toto pojmenování je dáno pouze konvencí, ale vhodně
vyjadřuje výskyt (existenci) objektu. Jak uvidíme později, tento parametr
bude naplněn až za běhu, a to interpretem &mdash; nikoliv tedy
programátorem. To jinými slovy znamená, že metoda <code>vytiskni</code> bude
volána bez zadávání argumentů takto: <code>m.vytiskni()</code>.</p>

<p class="trnote"><b>Poznámka překladatele:</b> Teoreticky bychom tomuto
parametru mohli přidělit jakékoliv jméno, ale řada pomocných nástrojů
předpokládá dodržování této konvence. Navíc tomu všichni uživatelé jazyka
Python rozumí na první pohled. Pokud nejde o pouhé pokusy, nepoužívejte jiné
jméno prvního parametru. Dodržujte uvedenou konvenci i vy.</p>

<p><b>Poznámka 3:</b> Uvedenou třídu jsme pojmenovali <code>Zprava</code> s
velkým 'Z'. Jde opět pouze o konvenci, která se ovšem používá velmi často, a
to nejen v jazyce Python, ale i v jiných objektově orientovaných jazycích.
Daná konvence říká, že jména metod by měla začínat malým písmenem a další
slova, ze kterých se jméno metody skládá, by měla začínat velkým písmenem.
Takže například metody "vypočítej stav účtu" bychom zapsali:
<code>vypocitejStavUctu</code>.</p>

<p class="trnote"><b>Poznámka překladatele:</b> pojmy <em>třída</em> a
<em>instance třídy</em> (tedy objekt) jsou velmi důležité. Bez jejich
dokonalého pochopení budete v problematice objektově orientovaného
programování jen tápat. Pokud se považujete za laiky, mohl by vám věc
osvětlit výklad těchto pojmů napasovaný na Pohádku o Popelce<sup
class="trnote" id="Bclass_class" title="Pohádku o Popelce"><a
href="cztuttrn.html#Pclass_class" >[2]</a></sup>.</p>

<p>V tomto okamžiku se možná budete chtít znovu podívat na kapitolu <a
href="cztutdata.html">Data, datové typy a proměnné</a> a zopakovat si
<em>uživatelsky definované typy</em>. <a href="cztutdata.html#address"
>Příklad s adresou</a> by měl být nyní o něco jasnější.</p>

<p><em>Třída</em> je v jazyce Python v podstatě jediným uživatelsky
definovaným typem. Třída, která má pouze atributy <span class="trnote"
title="Poznámka překladatele">(datové složky)</span>, ale žádné metody (s
výjimkou <code>__init__</code>), odpovídá záznamům v jazyce BASIC <span
class="trnote" title="Poznámka překladatele">a v jiných neobjektových
jazycích</span>.</p>


<h3>Používání tříd</h3>

<p>Teď, když už máme definovánu třídu <code>Zprava</code>, můžeme vytvářet
její instance a můžeme s nimi manipulovat:</p>

<pre>
z1 = Zprava("Ahoj lidi!")
z2 = Zprava("Sbohem. Bylo to krátké, ale sladké.")

poznamky = [z1, z2]  <span class="comment"># vlož objekty do seznamu</span>
for zpr in poznamky:
    zpr.vytisknout() <span class="comment"># každou zprávu vytiskni</span>
</pre>

<p>Takže vidíme, že s třídou zacházíme, jako kdyby to byl standardní datový
typ jazyka Python. A to byl vlastně cíl tohoto cvičení.</p>


<h3>Když dva dělají totéž, není to totéž...</h3>

<p>Zatím tedy umíme definovat své vlastní typy (třídy), umíme vytvářet
jejich instance a umíme je přiřazovat do proměnných. Těmto objektům
(instancím) pak můžeme zasílat zprávy, což způsobí provedení metod, které
jsme definovali. Ale co se týká objektově orientovaného přísupu, je zde
ještě jedna věc. Z mnoha pohledů jde o nejdůležitější vlastnost vůbec.</p>

<p id="polymorfismus">Mějme dva objekty různých tříd, které podporují
stejnou množinu zpráv, ale definují své vlastní odpovídající metody. V
takovém případě můžeme tyto objekty udržovat ve společné kolekci a v našem
programu s nimi můžeme zacházet stejným způsobem. Objekty se však budou
chovat každý jinak (po svém). Této schopnosti &mdash; chovat se jinak při
zpracování stejné zprávy &mdash; se říká <em>polymorfismus</em> <span
class="trnote" title="Poznámka překladatele">(doslova
<em>mnohotvárnost</em>, ale nepřekládá se)</span>.</p>

<p>Typicky se toho využívá například při existenci několika různých
grfických objektů, které se umí vykreslit, když obdrží zprávu 'paint'.
Objekt kruhu vykreslí ve srovnání s objektem trojúhelníku velmi odlišný
obrazec, ale pokud oba definují metodu <code>paint</code>, můžeme tento
rozdíl jako programátoři ignorovat a můžeme o nich uvažovat jako o
<em>tvarech</em>.</p>

<p>Podívejme se na příklad, kde místo vykreslování tvarů budeme vypočítávat
jejich plochy. Nejdříve vytvoříme třídy <code>Ctverec</code> a
<code>Kruh</code>:</p>

<pre>
class Ctverec:
    def __init__(self, strana):
        self.strana = strana
    def vypocitejPlochu(self):
        return self.strana**2

class Kruh:
    def __init__(self, polomer):
        self.polomer = polomer
    def vypocitejPlochu(self):
        import math
        return math.pi*(self.polomer**2)
</pre>

<p>Nyní vytvoříme seznam tvarů (buď kruhů nebo čtverců) a poté vytiskneme
jejich plochy:</p>

<pre>
seznam = [Kruh(5), Kruh(7), Ctverec(9), Kruh(3), Ctverec(12)]

for tvar in seznam:
    print "Plocha je: ", tvar.vypocitejPlochu()
</pre>

<p>Pokud nyní zkombinujeme uvedené myšlenky s moduly, dostaneme velmi mocný
mechanismus pro opakované použití kódu. Uložme definice tříd do modulu
&mdash; řekněme <code>tvary.py</code> &mdash; a když potom budeme chtít
manipulovat s tvary, jednoduše nejdříve provedeme import tohoto modulu.
Přesně takto je do systému Python zařazena řada standardních modulů. To je
důvod, proč se přístup k metodám objektu tolik podobá používání funkcí z
modulu.</p>


<h3>Dědičnost</h3>

<p>Dědičnost se často používá jako mechanismus pro implementování
polymorfismu. V mnoha objektově orientovaných jazycích je to ve skutečnosti
jediný způsob pro implementování polymorfismu. Funguje to následovně.</p>

<p>Třída může z <em>rodičovské třídy</em> nebo také <em>nadtřídy</em>
(super class) <em>dědit</em> jak atributy (datové prvky) tak operace. To
znamená, že nová třída, která se ve většině věcí podobá jiné třídě, nemusí
znovu implementovat všechy metody existující třídy. Místo toho může její
schopnosti zdědit a <em>předefinovat</em> (override) jen to, co se má dělat
jinak (například metodu pro vykreslování, o které jsme se zmínili ve výše
uvedeném případě).</p>

<p>Nejlepší bude ukázat vše na příkladu. Vytvoříme <em>hierarchii tříd</em>
pro bankovní účty, u kterých můžeme ukládat hotovost, zjišťovat stav účtu a
realizovat výběr. Některé z účtů poskytují úroky (pro naše účely budeme
předpokládat, že úrok je vypočítán při každém vkladu &mdash; zajímavá
inovace pro bankovní svět) a u jiných se při výběru účtuje poplatek.</p>

<h4>Třída BankovniUcet</h4>

<p>Podívejme se, jak by to mohlo vypadat. Nejdříve uvažme atributy a operace
bankovního účtu na nejobecnější (nebo <em>abstraktní</em>) úrovni.</p>

<p>Obvykle je nejlepší uvažovat nejdříve o operacích a teprve podle potřeby
doplnit atributy tak, abychom mohli oprerace realizovat. Takže u bankovního
účtu můžeme:</p>

<ul>
<li>Vkládat hotovost,</li>
<li>vybírat hotovost,</li>
<li>zjišťovat současný stav účtu a </li>
<li>převádět peníze na jiný účet.</li>
</ul>

<p>Pro tyto operace potřebujeme znát číslo bankovního účtu (pro operaci
převodu) a současný stav účtu. Vytvořme odpovídající třídu:</p>

<pre>
class ChybaZustatku(Exception): pass

class BankovniUcet:
    def __init__(self, pocatecniVklad):
        self.stav = pocatecniVklad
        print "Byl založen účet s počátečním stavem %5.2f korun." % self.stav

    def vlozit(self, castka):
        self.stav = self.stav + castka

    def vybrat(self, castka):
        if self.stav >= castka:
            self.stav = self.stav - castka
        else:
            raise ChybaZustatku("Litujeme. Na vašem účtu je jen %6.2f korun."
                                 % self.stav)

    def zustatek(self):
        return self.stav

    def prevod(self, castka, ucet):
        try:
            self.vybrat(castka)
            ucet.vlozit(castka)
        except ChybaZustatku, e:
            print str(e)
</pre>

<p><b>Poznámka 1:</b> Před výběrem z účtu kontrolujeme stav účtu a pro
ošetření chyb používáme výjimky. Chyba <code>ChybaZustatku</code> samozřejmě
neexistuje, takže si ji musíme vytvořit. <span class="ir">Definujeme ji
jako třídu, která je odvozena od zabudované třídy <code>Exception</code>. Ta
je bázovou třídou všech zabudovaných výjimek systému Python a měla by se
používat pro všechny uživatelsky definované výjimky. Při vytváření instance
této třídy (příkazem <code>raise</code>) lze předat řetězec, který lze z
objektu výjimky extrahovat zabudovanou funkcí <code>str()</code>.</span>.</p>

<p class="trnote"><b>Poznámka překladatele:</b> V novějších verzích jazyka
Python se pro výjimky vždy doporučuje používat třídy, které odvodíme od
bázové třídy <code>Except</code>. V roli instancí výjimek se již
nedoporučuje používat řetězce.</p>

<p><b>Poznámka 2:</b> Metoda <code>prevod</code> používá pro realizaci
převodu <em>členské funkce</em> neboli metody <code>vybrat</code> a
<code>vlozit</code> třídy <code>BankovniUcet</code>. Tento přístup je při
objektově orientovaném programování velmi běžný a je znám jako <em>zasílání
zpráv sobě samému</em> (self messaging). Znamená to, že <em>odvozené
třídy</em> mohou implementovat své vlastní verze metod <code>vlozit</code> a
<code>vybrat</code>, přičemž metoda <code>prevod</code> může u všech typů
účtů zůstat stejná.</p>

<h4>Třída UrocenyUcet</h4>

<p>Teď za použití dědičnosti vytvoříme účet, na který budou připisována
procenta (budeme předpokládat 3&nbsp;%) při každém vkladu. Třída se bude
shodovat s dříve uvedenou třídou <code>BankovniUcet</code> s výjimkou metody
<code>vlozit</code>. Jednoduše ji předefinujeme (override):</p>

<pre>
class UrocenyUcet(BankovniUcet):
    def vlozit(self, castka):
        BankovniUcet.vlozit(self, castka)
        self.stav = self.stav * 1.03
</pre>

<p>A je to! Začíná se ukazovat síla objektově orientovaného programování.
Všechny ostatní metody byly zděděny z třídy <code>BankovniUcet</code> (tím,
že jsme <code>BankovniUcet</code> uvedli do závorek za jméno nové třídy).
Povšimněte si, že metoda <code>vlozit</code> místo kopírování kódu raději
volá metodu <code>vlozit</code> své <em>nadtřídy</em> (superclass). Takže
pokud nyní upravíme metodu <code>vlozit</code> třídy
<code>BankovniUcet</code> například přidáním nějakých kontrol chyb, projeví
se tyto změny automaticky i v <em>podtřídě</em>.</p>

<p class="trnote"><b>Poznámka překladatele:</b> Místo pojmu
<em>nadtřída</em> (super class) se často používá pojem <em>bázová třída</em>
(base class) a místo pojmu <em>podtřída</em> (sub-class) se často používá
pojem <em>odvozená třída</em> (derrived class).</p>


<h4>Třída UcetSPoplatkem</h4>

<p>Tento typ účtu se opět shoduje s třídou <code>BankovniUcet</code> pro
standardní bankovní účet s tím rozdílem, že se tentokrát při každém výběru
účtují tři koruny. Stejně jako v případě třídy <code>UrocenyUcet</code>
můžeme novou třídu vytvořit děděním z třídy <code>BankovniUcet</code> a
úpravou metody <code>vybrat</code>.</p>

<pre>
class UcetSPoplatkem(BankovniUcet):
    def __init__(self, pocatecniVklad):
        BankovniUcet.__init__(self, pocatecniVklad)
        self.poplatek = 3

    def vybrat(self, castka):
        BankovniUcet.vybrat(self, castka + self.poplatek)
</pre>

<p><b>Poznámka 1:</b> Velikost poplatku je uložena v <em>členské
proměnné</em>, takže ji podle potřeby můžeme později měnit. Povšimněte si,
že zděděnou metodu <code>__init__</code> můžeme volat stejně jako každou
jinou metodu.</p>

<p><b>Poznámka 2:</b> Poplatek jednoduše přičítáme k požadované hodnotě
výběru a provedení celé operace zajistíme voláním metody <code>vybrat</code>
třídy <code>BankovniUcet</code>.</p>

<p><b>Poznámka 3:</b> Vedlejším efektem tohoto postupu je to, že se poplatek
uplatní i při převodu na jiný účet. Pravděpodobně to takto chceme, takže je
to v pořádku.</p>


<h4>Testujeme náš systém</h4>

<p>Abychom si vyzkoušeli, že to všechno funguje, zkuste spustit následující
kus kódu (buď z příkazového řádku systému Python nebo vytvořením souboru s
těmito testy). <span class="trnote" title="Poznámka překladatele"
>Následující kód předpokládá, že jste výše uvedené definice tříd uložili do
souboru <code>bankovniucet.py</code>. Pokud byste je uložili do jiného
souboru, musíte změnit jméno modulu v prvním řádku souboru.</span></p>

<pre>
from bankovniucet import *

<span class="comment"># Nejdříve vyzkoušíme standardní BankovniUcet.</span>
a = BankovniUcet(500)
b = BankovniUcet(200)
a.vybrat(100)
<span class="comment"># a.vybrat(1000)</span>
a.prevod(100, b)
print "A = ", a.zustatek()
print "B = ", b.zustatek()

<span class="comment"># Teď vyzkoušíme UrocenyUcet.</span>
c = UrocenyUcet(1000)
c.vlozit(100)
print "C = ", c.zustatek()

<span class="comment"># A ještě UcetSPoplatkem.</span>
d = UcetSPoplatkem(300)
d.vlozit(200)
print "D = ", d.zustatek()
d.vybrat(50)
print "D = ", d.zustatek()
d.prevod(100, a)
print "A = ", a.zustatek()
print "D = ", d.zustatek()

<span class="comment">
# A nakonec provedeme převod z účtu s poplatky na úročený účet.
# Z účtu s poplatky by se měl odečíst i poplatek a na úročeném
# účtu by měl přibýt i úrok.</span>
print "C = ", c.zustatek()
print "D = ", d.zustatek()
d.prevod(20, c)
print "C = ", c.zustatek()
print "D = ", d.zustatek()
</pre>

<p>Nyní odkomentujte řádek <code>a.vybrat(1000)</code> a uvidíte, jak
zafunguje výjimka.</p>

<p>A je to. Jde o poměrně zjednodušený příklad, ale ukazuje, jak můžeme
využít dědičnosti k rychlému rozšíření existující funkčnosti o nové
rysy.</p>

<p>Ukázali jsme si, jak lze příklad vytvořit po etapách a jak lze vytvořit
testovací program, kterým funkčnost řešení ověříme. Naše testy nebyly úplné
v tom smyslu, že jsme nepokryli všechny možné případy. Mohli bychom přidat
také další kontroly. Co kdyby byl například vytvořen účet se záporným
zůstatkem&hellip;</p>

<h3>Kolekce objektů</h3>

<p>Jedna z otázek, která vás mohla napadnout, zní: <em>Jak bychom měli
zacházet s větším množstvím objektů?</em> Nebo také: <em>Jak bychom
měli zacházet s objekty, které vytvoříme za běhu programu?</em> Statické
vytvoření objektů bankovních účtů &mdash; jak jsme to učnili výše &mdash; je
velmi snadné:</p>

<pre>
ucet1 = BankovniUcet(...)
ucet2 = BankovniUcet(...)
ucet3 = BankovniUcet(...)
atd.
</pre>

<p>Ale u reálných řešení dopředu nevíme kolik účtů budeme chtít vytvořit.
Jak si s tím poradíme? Uvažujeme nyní o problému trochu podrobněji.</p>

<p>Potřebujeme nějaký druh <em>databáze</em>, která by nám dovolila nalézt
požadovaný bankovní účet podle jména vlastníka (nebo spíše podle čísla účtu,
protože jedna osoba může mít více účtů a také více lidí může mít stejné
jméno).</p>

<p>V kolekci potřebujeme něco vyhledat podle jednoznačného klíče&hellip;
hmmm &mdash; to vypadá na použití slovníku! <span class="trnote"
title="Poznámka překladatele">(Připomeňme si, že pro takto pojmenovanou
strukturu jazyka Python lze použít i pojem <em>vyhledávací
tabulka</em>.)</span> Podívejme se, jak bychom použili strukturu typu
slovník (dictionary) pro uložení dynamicky vytvořených objektů.</p>

<pre>
from bankovniucet import *
import time

<span class="comment"># Funkce pro generování unikátních identifikačních čísel.</span>
def ziskejDalsiID():
    ok = raw_input("Vytvořit účet [a/n]? ")
    if ok[0] in 'aA':        <span class="comment"># v případě souhlasu...</span>
        id = time.time()     <span class="comment"># použij aktuální čas jako základ ID,</span>
        id = int(id) % 10000 <span class="comment"># převeď na max. 4místné celé číslo
        # Poznámka překladatele: time.time() vrací reálné číslo
        # odpovídající času v sekundách (s přesností obvykle
        # lepší než 1 sekunda).</span>
    else: id = -1            <span class="comment"># tato hodnota zastaví cyklus</span>
    return id


tabulkaUctu = {}  <span class="comment"># nový slovník</span>
while 1:          <span class="comment"># nekonečný cyklus</span>
    id = ziskejDalsiID()
    if id == -1:
        break     <span class="comment"># break násilně ukončí cyklus while</span>
    vklad = float(raw_input("Počáteční vklad? "))

    <span class="comment"># Identifikaci id použijeme pro vytvoření nové položky tabulky.</span>
    tabulkaUctu[id] = BankovniUcet(vklad)
    print "Byl vytvořen nový účet číslo %04d s vkladem %0.2f" % (id, vklad)

<span class="comment"># Zobrazíme si zůstatky na všech účtech.</span>
for id in tabulkaUctu:
    <span class="comment"># Poznámka překladatele: od Python 2.0 není nutné
    # v zápisu cyklu uvádět tabulkaUctu.keys(), jak tomu bylo
    # u starších verzí.</span>
    print "%04d\t%0.2f" % (id, tabulkaUctu[id].zustatek())

<span class="comment"># Nyní vyhledáme konkrétní účet. Pokud chcete ukončit</span>
<span class="comment"># program, vložte nečíselnou hodnotu.</span>
while 1:
   id = int(raw_input("Zadejte číslo účtu: "))
   if id in tabulkaUctu:
       print "Zůstatek = %0.2f" % tabulkaUctu[id].zustatek()
   else: print "Chybné číslo účtu."
</pre>

<p>V roli klíče, který se používá pro vyhledávání ve slovníku, může být
samozřejmě použito cokoliv, co jednoznačně identifikuje objekt. Může to být
nějaký z jeho atributů, například jméno. Cokoliv, co je jednoznačné. Možná
teď pro vás bude užitečné, když si znovu projdete kapitolu <a
href="cztutdata.html">Data, datové typy a proměnné</a>, a přečtete si
konkrétně část, která se týká <a href="cztutdata.html#dictionary"
>slovníků</a> <span class="trnote" title="Poznámka překladatele"
>(vyhledávacích tabulek)</span>. Jsou to opravdu velmi užitečné
kontejnery.</p>

<h3>Ukládání vašich objektů</h3>

<p>Výše uvedené řešení má jednu nevýhodu. Jakmile ukončíte program, všechny
údaje budou ztraceny. Potřebujeme tedy nějaký způsob pro ukládání objektů. S
vaším postupujícím programátorským růstem se později naučíte, jak pro tento
účel používat databáze. Ale v tomto okamžiku nám bude pro ukládání a
opětovné načítání objektů stačit textový soubor. Python definuje moduly
(zvané <code>Pickle</code> a <code>Shelve</code>), které umí s objekty v
tomto smyslu zacházet efektivněji. Ale ukažme si raději generický <span
class="trnote" title="Poznámka překladatele">(tedy <em>obecně
použitelný</em>)</span> způsob, který by fungoval v libovolném programovacím
jazyce. Technický termín pro schopnost uložení a opětovné obnovení stavu
objektů se shodou okolností nazývá <em>persistence</em>. <span
class="trnote" title="Poznámka překladatele">(Tento pojem se chápe jako
termín a obvykle se nepřekládá. Z hlediska významu bychom jej ale mohli
přeložit jako <em>schopnost přetrvat</em> &mdash; rozumí se uchovat svůj
stav po dobu, kdy aplikace neběží.)</span></p>

<p>Generický <span class="trnote" title="Poznámka překladatele">(tedy
<em>obecně použitelný</em>)</span> způsob spočívá ve vytvoření metod
<code>save</code> a <code>restore</code> v objektu nejvyšší úrovně <span
class="trnote" title="Poznámka překladatele">(poznámka překladatele: autor
má na mysli <em>bázovou třídu</em>)</span> a předefinujeme je v každé <span
class="trnote" title="Poznámka překladatele">odvozené</span> třídě tak, že
nejdříve zavolají zděděnou verzi a poté přidají své lokálně definované
atributy. <span class="trnote">Poznámka překladatele: Tyto metody nebudeme
překládat (save [sejv] = uložit; restore [ristór] = obnovit), protože se jim
typicky dávají právě tato anglická jména.</span></p>

<pre>
class A:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def save(self, fn):
        f = open(fn, "w")
        <span class="comment"># Poznámka překladatele: Od verze Python 2 by se
        # měla dávat přednost zápisu f = file(fn, "w")</span>
        f.write(str(self.x) + '\n') <span class="comment"># převeď na řetězec</span>
        f.write(str(self.y) + '\n')
        return f  <span class="comment"># do stejného souboru budou své hodnoty</span>
                  <span class="comment"># připisovat objekty odvozených tříd</span>

    def restore(self, fn):
        f = open(fn)
        self.x = int(f.readline()) <span class="comment"># převeď zpět na původní typ</span>
        self.y = int(f.readline())
        return f

class B(A):
    def __init__(self, x, y, z):
        A.__init__(self, x, y)
        self.z = z

    def save(self, fn):
        f = A.save(self, fn)         <span class="comment"># zavolej rodičovskou metodu</span>
        f.write(str(self.z) + '\n')  <span class="comment"># přidej vlastní hodnoty</span>
        return f                     <span class="comment"># pro případné další potomky</span>

    def restore(self, fn):
        f = A.restore(self, fn)
        self.z = int(f.readline())
        return f

<span class="comment"># Vytvoříme instance.</span>
a = A(1, 2)
b = B(3, 4, 5)

<span class="comment"># Uložíme instance.</span>
a.save('a.txt').close() <span class="comment"># nezapomeň uzavřít soubor</span>
b.save('b.txt').close()

<span class="comment"># Obnovíme instance.</span>
newA = A(5, 6)
newA.restore('a.txt').close() <span class="comment"># nezapomeň uzavřít soubor</span>
newB = B(7, 8, 9)
newB.restore('b.txt').close()
print "A: ", newA.x, newA.y
print "B: ", newB.x, newB.y, newB.z
</pre>

<p class="note"><b>Poznámka:</b> Vytisknou se hodnoty, které jsou obnoveny
načtením ze souborů, nikoliv hodnoty, které jsme použili při vytváření
instancí.</p>

<p>Klíčovým požadavkem je předefinování metod <code>save</code> a
<code>restore</code> v každé třídě a také to, aby byla nejdříve volána
rodičovská metoda <span class="trnote" title="Poznámka překladatele">(tj.
metoda bázové třídy)</span>. V odvozené třídě se pak musíme postarat pouze o
přidané atributy. Způsob, jakým atribut převedeme na řetězec a uložíme,
závisí samozřejmě na nás, ale musí být umístěn na zvláštním řádku. Při
obnovování jednoduše obrátíme postup, který jsme použili při ukládání.</p>

<div class="trnote">

<p><b>Poznámka překladatele:</b> V uvedeném příkladu se skrývá
problém. Otevřený soubor by se měl vždy
explicitně uzavřít. V tomto smyslu je uvedené řešení poměrně nedokonalé. Pokud
se považujete za začátečníky, soustřeďte se především na hlavní myšlenku, kterou
autor prezentuje. Nespoléhejte na správnost příkladu v detailech.</p>

<p>Při práci se soubory by se mělo používat nepsané pravidlo, které říká, že
soubor by se měl uzavírat na stejné úrovni, kde se otevřel. Tím se obvykle
vyhneme komplikacím s předáváním odpovědnosti za uzavření souboru do
volaného kódu nebo naopak do volajícího kódu. Z tohoto pravidla vyplývá, že
by se místo textového jména souboru měl metodám <code>save()</code> a
<code>restore()</code> předávat již objekt otevřeného souboru.</p>

<p>Další problém spočívá v tom, že explicitně určujeme jméno souboru, do
kterého se objekt ukládá. Pokud byste někdy takto vybudovanou třídu chtěli
použít například v jiné aplikaci, mohli byste se setkat s komplikacemi.</p>

<p>V tomto místě pokládám za vhodné zmínit se o tom, že u odvozené třídy
<em>musíme sami zajistit</em> uvnitř metody <code>__init__()</code> volání
stejnojmenné metody bázové třídy, které jako první parametr předáváme
<code>self</code>.</p>
</div>

<p>Doufám, že vám tato kapitola dala přičichnout k objektově orientovanému
programování. Další informace a příklady můžete nalézt v nějaké dalším
on-line učebnici nebo si můžete přečíst některou z knih, o kterých jsme se
zmiňovali na začátku.</p>

<hr>
<div class="foot">
<p class="navig">[
<a href="cztutrecur.html" title="Rekurze...">předchozí</a> |
<a href="cztutcont.html">obsah</a> |
<a href="cztutname.html" title="Prostory jmen">další</a>
]</p>
<p class="note">Pokud vás napadne, co by se dalo na překladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztutclass.html,v 1.6 2004/08/31 11:55:12 prikryl Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka'
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20')
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script>

Tím budou do dopisu automaticky vloženy informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztutclass.html,v 1.6 2004/08/31 11:55:12 prikryl Exp $</p>
</div>
</body>
</html>


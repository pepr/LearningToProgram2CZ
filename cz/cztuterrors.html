<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se nauèit programovat: Ošetøení chyb</title>
</head>
<body>

<h2>Ošetøení chyb</h2>

<div class="whatcovered">
<p class="title">O èem si budeme povídat?</p>
<ul>
<li>Krátce z historie práce s chybami.</li>
<li>Dvì techniky práce s chybami.</li>
<li>Jak v našem kódu definovat a signalizovat chybu, která má bıt ošetøena 
    jinde.</li>
</ul>
</div>

<h3>Krátce z historie práce s chybami</h3>

<p>Z hlediska zpùsobu zpracování chyb je z našich tøí jazykù VBScript ten
nejbizarnìjší. Je to dáno tím, e staví na základech jazyka BASIC, kterı
patøí k jednìm z prvních programovacích jazykù (kolem roku 1963). Zpùsob
zpracování chyb v jazyce VBScript patøí k tìm místùm, ze kterıch je zmínìné
dìdictví jasnì vidìt. Pro naše úèely to není špatné, protoe mi to dává
pøíleitost k vysvìtlení, proè VBScript pouívá právì takovı pøístup.
Vysvìtlíme si historii zpùsobu zpracování chyb od jazyka BASIC, pøes Visual
Basic, a k VBScript. Poté se podíváme na mnohem modernìjší pøístup, kterı
ukázkovım zpùsobem vyuívají JavaScript a Python.</p>

<p>V tradièní verzi jazyka BASIC byly se na všech øádcích programu psala
èísla øádkù. Pøesun øízení se provádìl skokem na urèitı øádek pouitím
pøíkazu <code>GOTO</code>. (Pøíklad jsme si ukázali v rámci tématu <a
href="cztutbranch.html">Vìtvení</a>.) Byl to v podstatì jedinı monı zpùsob
øízení. V prostøedí s takovımi vlastnostmi byl bìnı zpùsob ošetøování chyb
zaloen na deklaraci promìnné <code>ERRORCODE</code>, ve které se ukládala
èíselná hodnota. Kdy se v programu vyskytla chyba, nastavil se obsah
promìnné <code>ERRORCODE</code> na odpovídající hodnotu &mdash; nepodaøilo
se otevøít soubor, nesluèitelnost typù, pøeteèení operátoru, a podobnì.</p>

<p>Uvedenı pøístup vedl k psaní kódu, kterı vypadal podobnì, jako
následující úsek fiktivního programu:</p>

<pre>
1010 LET DATA = INPUT FILE
1020 CALL FUNKCE_PRO_ZPRACOVANI_DAT
1030 IF NOT ERRORCODE = 0 GOTO 5000
1040 CALL JINA_FUNKCE
1050 IF NOT ERRORCODE = 0 GOTO 5000
1060 REM POKRACUJ VE ZPRACOVANI TAKTO...
...
5000 IF ERRORCODE = 1 GOTO 5100
5010 IF ERRORCODE = 2 GOTO 5200
5020 REM DALSI PRIKAZY IF
...
5100 REM ZDE ZPRACUJ CHYBOVY KOD 1.
...
5200 REM ZDE ZPRACUJ CHYBOVY KOD 2.
</pre>

<p>Vidíme, e skoro polovina hlavního programu se zabıvá zjišováním, zda
nenastala chyba. Èasem byl zaveden o nìco elegantnìjší mechanismus, ve kterém
se detekce chyba a jejich ošetøení èásteènì pøesunulo do interpretu jazyka.
Vypadal nìjak takto:</p>


<pre>
1010 LET DATA = INPUTFILE
1020 ON ERROR GOTO 5000
1030 CALL FUNKCE_PRO_ZPRACOVANI_DAT
1040 CALL JINA_FUNKCE
...
5000 IF ERRORCODE = 1 GOTO 5100
5010 IF ERRORCODE = 2 GOTO 5200
</pre>

<p>K popisu umístìní kódu pro ošetøení chyby zde staèí jeden øádek. Pokud
funkce narazila na chybu, musela i nadále nastavovat hodnotu promìnné
<code>ERRORCODE</code>, ale velmi se zjednodušil zápis (a ètení!) kódu.</p>

<p>No a co to má spoleèného s námi? Je to docela prosté. Tento zpùsob
zpracování chyb i nadále pouívá 
Visual Basic, aèkoliv èísla øádkù byla nahrazena uivatelsky pøívìtívìjšími
návìštími. VBScript &mdash; jako potomek jazyka Visual Basic &mdash; pouívá
vıraznì oøezanou verzi tého mechanismu. To ve svém dùsledku znamená, e nám
VBScript dává na vybranou: buï budeme ošeøovat chyby lokálnì, nebo je budeme
zcela ignorovat.</p>

<p>Pokud se rozhodneme pro ignorování chyb, zapíšeme to takto:</p>

<pre>
On Error Goto 0  <span class="comment">' 0 øíká "nikam neskákej"</span>
NejakaFunkce()
NejakaJinaFunkce()
...
</pre>

<p>Pokud se rozhodneme pro lokální ošetøení chyb, pouijeme zápis:</p>

<pre>
On Error Resume Next
NejakaFunkce()
If Err.Number = 42 Then
   <span class="comment">' tady ošetøi chybu</span>
NejakaJinaFunkce()
...
</pre>

<p>Takovı zápis vypadá trochu zpáteènicky. Ve skuteènosti prostì odráí vıše
popsanı historickı proces.</p>

<p>V pøípadì vıskytu chyby se interpret standardnì zachová tak, e uivateli
zobrazí zprávu a zastaví provádìní programu. Právì toto se stane, pokud pøi
urèování zpùsobu zpracování chyby pouijeme zápis <code>Goto&nbsp;0</code>. To
znamená, e zápisem <code>Goto&nbsp;0</code> vypínáme lokální øízení a øíkáme
interpretu, aby se zachoval obvyklım zpùsobem.</p>

<p>Pøedpis pro zpracování chyby obsahující <code>Resume&nbsp;Next</code> nám
buï dovolí pøedstírat, e chyba vùbec nenastala, nebo si mùeme otestovat
objekt pro popis chyby (je pojmenován <code>Err</code>). Zajímá nás zejména
jeho èíselná sloka <span class="trnote"
title="Poznámka&nbsp;pøekladatele"><code>Number</code></span>. (Jde o naprosto
stejnou techniku, jako vıše ukázané testování <code>ERRORCODE</code>.) Objekt
<code>Err</code> nese ještì další informaèní poloky, které nám mohou pomoci
vyrovnat se s nastalou situací ménì katastrofickım zpùsobem, ne je zastavení
programu. Mùeme napøíklad zjistit, v jakém místì k chybì došlo (v jakém
objektu, v jaké funkci a podobnì). Mùeme také získat textovı popis chyby,
kterı mùeme uivateli vypsat jako souèást hlášení o chybì, nebo jej mùeme
zapsat do log souboru. Typ chyby mùeme v objektu <code>Err</code> zmìnit
pouitím jeho metody <code>Raise</code>. Tuto metodu mùeme pouít i pøi
generování našich vlastních chyb, které nastaly v našich vlastních
funkcích.</p>

<p>Jako pøíklad mechanismu ošetøování chyby v jazyce VBScript is uveïme
pøípad, kdy dochází k dìlení nulou:</p>

<pre>
&lt;script type="text/vbscript">
Dim x, y, vysledek
x = CInt(InputBox("Zadejte dìlence: "))
y = CInt(InputBox("Zadejte dìlitele: "))
On Error Resume Next
vysledek = x/y
If Err.Number = 11 Then <span class="comment">' Dìlení nulou</span>
   vysledek = Null
End If
On Error GoTo 0 <span class="comment">' ošetøování chyb opìt vypneme</span>
If VarType(vysledek) = vbNull Then
   MsgBox "CHYBA: Operace nemohla bıt provedena."
Else
   MsgBox CStr(x) &amp; " dìleno " &amp; CStr(y) &amp; " je rovno " &amp; CStr(vysledek)
End If
&lt;/script>
</pre>

<p>Upøímnì øeèeno, uvedenı pøístup moc pìknı není. A zatímco obdivování
dávné historie mùe bıt balzámem pro duši, moderní programovací jazyky, vèetnì
jazykù Python a JavaScript, nabízejí mnohem elegantnìjší zpùsoby ošetøování
chyb. Podívejme se, o jaké mechanismy jde.</p>


<h3>Ošetøování chyb v jazyce Python</h3>

<h4>Zpracování vıjimek</h4>

<p>V modernìjších programovacích prostøedích se vyvinul alternativní zpùsob
práce s chybami. Je znám pod pojmem <em>ošetøení vıjimek</em> a je zaloen na
tom, e funkce <em>vrhají</em> (<em>throw</em>) nebo<span class="trnote"
title="Poznámka pøekladatele">, jinımi slovy,</span> <em>vyvolávají</em>
(<em>raise</em>) vıjimky <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(exception [iksepšn])</span>. Systém si pak
zajistí vyskoèení z aktuálního bloku kódu na nejbliší blok pro ošetøení
vıjimky. V&nbsp;systému se nachází také blok kódu, kterı <em>zachytí</em>
(<em>catch</em>) všechny vıjimky, které dosud nebyly zpracovány nìkde jinde.
Poté obvykle zobrazí chybové hlášení a ukonèí bìh aplikace.</p>

<p>K velkım vıhodám tohoto stylu ošetøování chyb patøí mnohem lepší èitelnost
hlavní funkènosti programu. Je to dáno tím, e nedochází k mísení s kódem pro
ošetøování chyb. <span class="trnote"
title="Poznámka&nbsp;pøekladatele">Jinımi slovy,</span> v bloku kódu si mùeme
èíst ani bychom byli jakkoliv nuceni èíst kód pro ošetøování chyb.</p>

<p>Podívejme se, jak se uvedenı styl programování pouívá v praxi.</p>

<h4>Try/Catch</h4>

<p>Blok kódu pro ošetøení vıjimek se trochu podobá bloku
<code>if...then...else</code>:</p>

<pre>
try:
   <span class="comment"># Zde se umístí hlavní èást kódu programu.</span>
except TypVyjimky:
   <span class="comment"># Zde se bude zpracovávat jmenovaná vıjimka.</span>
except JinyTypVyjimky:
   <span class="comment"># Zde se ošetøuje jiná vıjimka.</span>
else:
   <span class="comment"># Zde umístíme úklidovı kód, kterı se provede
   # v pøípadì, e nenastane ádná vıjimka.</span>
</pre>

<p>Python se pokouší provádìt pøíkazy mezi pøíkazy <code>try</code> a prvním
<code>except</code>. Pokud dojde k chybì, provádìní pøíkazù v bloku za
<code>try</code> se zastaví a skoèí se dolù k pøíkazu <code>except</code>.
Postupnì se procházejí jednotlivé pøíkazy <code>except</code>, dokud se
nenajde ten, kterı odpovídá typu chyby (neboli <em>vıjimky</em>). Pokud se
nalezne, provede se blok bezprostøednì následujícího kódu. Pokud se nenalezne
ádnı odpovídající pøíkaz <code>except</code>, pøedává se nalezená chyba dál,
do dalších <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(vyšších)</span> úrovní programu. Pokud
není nalezen odpovídající <code>except</code>, dostane se chyba a na úroveò
interpretu jazyka Python, kterı chybu zachytí, zobrazí chybové hlášení a
zastaví provádìní programu. V našich programech jsme zatím pozorovali právì
takovı projev<span class="trnote" title="Poznámka&nbsp;pøekladatele">, protoe
jsme zatím neumìli chybu zachytit a zpracovat sami</span>.</p>

<p>Pokud v bloku <code>try</code> k ádnım chybám nedojde, pak se provede blok
za <code>else</code>. Ale v praxi se této monosti vyuívá velmi zøídka.
Poznamenejme, e pøíkaz <code>except</code>, u kterého není uveden ádnı typ
chyby, zachytí chyby <em>všech</em> typù, které dosud nebyly zpracovány.
Vyuívání této formy pøíkazu se ale obecnì nepovauje za dobrı nápad. Vıjimku
ovšem pøedstavuje jeho pouívání v nejvyšší úrovni programu, kdy chceme
zabránit tomu, aby Python uivateli zobrazil velmi technickou podobu chybového
hlášení. Obecná podoba pøíkazu <code>except</code> nám v tomto pøípadì umoní
odchytit všechny dosud neošetøené chyby a zobrazit pøívìtivìjší hlášení o
<em>ukonèování programu</em>.</p>

<p>Za zmínku stojí, e souèástí instalace Pythonu je i modul
<code>traceback</code>, kterı nám umoní extrahovat rùzné doplòkové informace
o zdroji chyby. To se nám mùe hodit pøi vytváøení log souboru a pro podobné
akce. Modulem <code>traceback</code> se zde zabıvat nebudeme. V pøípadì
potøeby naleznete popis jeho vlastností a pouití ve standardní dokumentaci
modulù.</p>

<p>A jak to vše skuteènì funguje si ukáeme na pøíkladu:</p>

<pre>
hodnota = raw_input("Zadej delitele: ")
try:
    hodnota = int(hodnota)
    print "42 / %d = %d" % (hodnota, 42 / hodnota)

except ValueError: 
    print "Hodnotu nelze prevest na cele cislo."

except ZeroDivisionError:
    print "Neni povolena nulova hodnota."

except: 
    print "Stalo se neco neocekavaneho."

else: 
    print "Program skoncil uspesne."
</pre>

<p>Pokud program spustíme a místo èísla zadáme nìjakı øetìzec, zobrazí se
zpráva vypisovaná ve vìtvi <code>ValueError</code> <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(chyba hodnoty)</span>. Pokud zadáme nulu,
zobrazí se zpráva pro <code>ZeroDivisionError</code> <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(chyba pøi dìlení nulou)</span>. Pokud
zadáme platné èíslo, zobrazí se vısledek a zpráva o úspìšném ukonèení
programu.</p>


<h4>Try/Finally</h4>

<p>Existuje ještì jeden typ bloku, kterı souvisí s vıjimkami. Umoòuje
zapsat kód pro úklid provádìnı i poté, co nastala chyba. Nazıvá se
<code>try...finally</code> <span class="trnote" title="Poznámka
pøekladatele" >(try [tray] = zkus, pokus se vykonat; finally [fajnly] =
nakonec)</span> a typicky se pouívá pro zavírání souborù, vyprazdòování
vyrovnávacích pamìtí (buffer) na disk a podobnì. Blok <code>finally</code>
je proveden vdy jako poslední nezávisle na tom, co se stane v sekci
<code>try</code>. <span class="trnote" title="Poznámka pøekladatele">Pokud
nenastane vıjimka, prostì se provede. Pokud nastane vıjimka, zapamatuje se
její objekt, kód bloku <code>finally</code> se provede a zapamatovaná
vıjimka se znovu vyvolá.</span></p>

<pre>
try:
   <span class="comment"># Kód, související s úèelem programu.</span>
finally:
   <span class="comment"># V této èásti provádíme úklidové akce nezávisle
   # na tom, zda v bloku try nastala chyba èi nikoliv.</span>
</pre>

<p>Síla této konstrukce se projeví pøi kombinaci s blokem
<code>try/except</code>. Konkrétní volba poøadí zanoøení tìchto blokù
nepøináší vıznamné vıhody. Poøadí zpracování <span class="trnote"
title="Poznámka&nbsp;pøekladatele">pøíkazù</span> zùstává v obou pøípadech
stejné. Osobnì pouívám blok <code>try/finally</code> obvykle jako vnìjší,
protoe si tím pøipomínám, e se <span class="trnote"
title="Poznámka&nbsp;pøekladatele">blok vìtve</span> <code>finally</code>
provede jako poslední. Ale z pohledu Pythonu je to jedno. Pøíklad:</p>

<pre>
print 'Start programu.'
try:
    try:
        data = file('data.dat')
        hodnota = int(data.readline().split()[2])
        print 'Hodnota je %d.' % (hodnota/(42-hodnota))
    except ZeroDivisionError: 
        print 'Hodnota byla 42.'
finally:
    data.close()
print 'Konec programu.'
</pre>

<p>V tomto pøípadì dojde k uzavøení souboru vdy, nezávisle na tom, zda v
bloku <code>try/except</code> vznikne vıjimka. Všimnìte si odlišnosti
chování ve vztahu k vìtvi <code>else</code> v konstrukci
<code>try/except/else</code>, protoe <span class="trnote"
title="Poznámka&nbsp;pøekladatele">blok v <code>else</code></span> se zavolá
jen v pøípadì, kdy nedojde k <em>ádné</em> vıjimce. To by znamenalo, e by
nedošlo k uzavøení souboru. Pokud bychom zase kód pro uzavøení souboru
umístili jednoduše mimo konstrukci <code>try/except</code>, pak by se soubor
neuzavøel v pøípadì, kdy by nastala jiná vıjimka, ne
<code>ZeroDivisionError</code>. Take pouze konstrukce
<code>try/finally</code> zajistí, e k uzavøení souboru dojde
<em>vdy</em>.</p>

<div class="trnote">

<p><b>Poznámka pøekladatele:</b> V souboru <code>data.dat</code> se oèekává
alespoò jeden øádek, kterı obsahuje alespoò tøi slova (øetìzce nerozdìlené
mezerami) a tøetí slovo má charakter èísla. Pøíklad obsahu:</p>

<pre>
xxx yyy 40
</pre>

<p>Zadáním hodnoty 42 (do souboru) vyvoláme vıjimku
<code>ZeroDivisionError</code>. Pokud místo èísla zadáme napøíklad øetìzec
<code>ccc</code>, vznikne jiná vıjimka (<code>ValueError</code>) související
s tím, e se øetìzec nedaøí pøevést na èíslo. Pokud místo èísla neuvedeme
vùbec nic, vznikne pøi následném volání metody <code>split()</code> k
vygenerování kratšího seznamu, take nebude existovat poloka s indexem 2. V
takovém pøípadì vznikne vıjimka <code>IndexError</code>.</p>

<p>Osobnì se mi nelíbí otvírání souboru na jiné úrovni (v zanoøeném
<code>try</code>), ne na jaké se provádí uzavírání &mdash; i kdy to
funguje. Podle mého názoru by se soubor mìl zavírat na stejné úrovni v kódu,
na které byl otevøen.</p>

<p>Platí to obecnì, ale nejvıraznìji je to vidìt v pøípadì, kdy jedna z akcí
(otevøení/zavøení souboru) je umístìna uvnitø funkce a druhá vnì. Napøíklad
funkce, které dostává jako argument otevøenı soubor, by jej nemìla zavírat.
Ono to sice mùe fungovat naprosto bez problémù, ale mùe dojít ke zmatkùm v
naší hlavì, kdy si èteme zdrojovı text. Dùvod spoèívá v tom, e pøi zápisu
pouívání funkce je tato akce skryta našemu zraku a nemusíme si uvìdomit, co
se vevnitø dìje. Vıjimku pøedstavují situace, kdy funkce svım jménem
napovídá, e se pøedanı soubor uvnitø otevøe, respektive uzavøe.</p>

<p>Pokud tedy toto pravidlo <em>selského rozumu</em> napasujeme na vıše
uvedenı pøíklad, pak osobnì dávám pøednost následujícímu zápisu pøíkladu
(navíc pøidán pøíkaz <code>print</code> za uzavøení souboru, abychom
zviditelnili provedení bloku kódu):</p>

<pre>
print 'Start programu.'
try:
    data = file('data.dat')
    try:
        hodnota = int(data.readline().split()[2])
        print 'Hodnota je %d.' % (hodnota/(42-hodnota))
    except ZeroDivisionError: 
        print 'Hodnota byla 42.'
finally:
    data.close()
    print 'Soubor uzavøen.'
print 'Konec programu.'
</pre>

<p>Je tady ale ještì jeden zádrhel. Pokud by navíc selhalo i otvírání
zouboru <code>data.dat</code>, dojde k vıjimce promìnná <code>data</code>
nebude naplnìna (pøípadnì se váe na pøedchozí hodnotu). To znamená, e v
sekci <code>finally</code>, ve kterém se budeme pokoušet o volání metody 
<code>close()</code> objektu, kterı neexistuje. Proto je lepší zapsat:</p>

<pre>
print 'Start programu.'
data = file('data.dat')
try:
    try:
        hodnota = int(data.readline().split()[2])
        print 'Hodnota je %d.' % (hodnota/(42-hodnota))
    except ZeroDivisionError: 
        print 'Hodnota byla 42.'
finally:
    data.close()
    print 'Soubor uzavøen.'
print 'Konec programu.'
</pre>

<p>V takovém pøípadì je ovšem sporné u samotné pouití
<code>try/finally</code>, protoe v pøípadì, kdy se soubor nepovede otevøít,
nedostaneme se vùbec do následující konstrukce. Zavírání souboru stejnì v
takovém pøípadì není moné (viz pøedchozí odstavec). Pokud se soubor povede
otevøít, nepotøebujeme uzavírání souboru vkládat do bloku
<code>finally</code>. Osobnì bych se proto pøiklonil k naprosto jednoduchému
øešení bez vnìjší konstrukce <code>try/finally</code>.</p>

<pre>
print 'Start programu.'
data = file('data.dat')

try:
    hodnota = int(data.readline().split()[2])
    print 'Hodnota je %d.' % (hodnota/(42-hodnota))
except ZeroDivisionError: 
    print 'Hodnota byla 42.'
except:
    print u'Nastala jiná vıjimka.'
data.close()
print 'Konec programu.'
</pre>

<p><b>Závìr:</b> Pùvodní pøíklad není tak jednoduchı, jak vypadá.</p>

</div>


<h4>Generování chyb</h4>

<p>Jakım zpùsobem mùeme generovat vıjimky &mdash; dejme tomu uvnitø modulu
&mdash;, které má zachytit nìkdo jinı? V jazyce Python je pro tento pøípad
vyhrazeno klíèové slovo <code>raise</code>:</p> 

<pre>
delenec = 42
delitel = input('Jakou hodnotou chcete dìlit èíslo 42? ')
if delitel == 0:
   raise ZeroDivisionError()
</pre>

<p>Tento kód vygeneruje vıjimku <code>ZeroDivisionError</code>, která mùe
bıt zachycena v bloku <code>try/except</code>. Zbytku programu se to jeví
naprosto stejnì, jako kdyby chybu vygeneroval pøímo Python. Klíèovım slovem
<code>raise</code> se pøedepisuje také pøedávání chyby zevnitø bloku
<code>except</code> do vyšších úrovní programu. <span class="trnote"
title="Poznámka&nbsp;pøekladatele">Pøi vıskytu chyby</span> mùeme napøíklad
chtít provést nìjakou lokální akci, dejme tomu zapsat záznam do log souboru,
ale poté chceme, aby se o dalších akcích rozhodlo na vyšších úrovních
programu. Pouití mùe vypadat takto:</p>

<pre>
logsoubor = file('errorlog.txt', 'w')

def f(hodnota):
    try:
        return 127 / (42-hodnota)
    except ZeroDivisionError:
        logsoubor.write('Hodnota byla 42.')
        raise

try:
    f(42)
except ZeroDivisionError:
    print 'Nastala chyba. Zkuste znovu.'
</pre>


<p>Povšimnìte si, jak funkce <code>f()</code> zachytává chybu, zapisuje
zprávu do souboru se záznamem o chybì a poté pøedává zachycenou vıjimku ke
zpracování v bloku kódu, kterı se nachází ve vnìjší, obalující konstrukci
<code>try/except</code>.</p>

<div class="trnote">

<p><b>Poznámka pøekladatele:</b> S <em>log soubory</em>, tedy se soubory
urèenımi pro záznam (protokolování) chyb a zvláštních stavù, se vìtšinou
zachází tak, e se záznamy neustále pøipisují na konec. Prakticky to
znamená, e by se log soubor mìl otvírat pro zápis za konec souboru, tedy v
reimu <em>append</em> (druhı parametr s hodnotou <code>'a'</code>).</p>

<p>Další zásada vyplıvá ze skuteènosti, e u otevøeného souboru není
zaruèeno, e je veškerı zapisovanı obsah skuteènì fyzicky uloen na disku.
Pokud toho chceme dosáhnout, pak mùeme ve vhodnıch okamicích provádìt
takzvané vyprázdnìní vyrovnávací pamìti (flush).</p>

<p>Pøi zápisu do log souboru s chybami, kdy se pøedpokládá nízkı poèet
zápisù, bıvá praktiètìjší log soubor otevøít pøed kadım zápisem a poté ho
hned zavøít. Pokud aplikace havaruje, máme jistotu, e se neztratilo nìkolik
posledních zápisù.</p>

<p>Ve vıše uvedeném pøíkladì je log soubor otevøen na zaèátku a dokonce jsme
jej zapomìli zavøít. Pøi vıskytu chyby se pùvodní obsah pøepisuje, take
budeme mít zapsán jen poslední záznam. V mnoha jednoduchıch pøípadech to
staèí, ale proè bychom to nemohli udìlat poøádnìji, kdy to není o moc
sloitìjší:</p>

<pre>
def f(hodnota):
    try:
        return 127 / (42-hodnota)
    except ZeroDivisionError:
        logsoubor = file('errorlog.txt', 'a') <span class="comment"># Otevøeme pro pøipsání na konec,</span>
        logsoubor.write('Hodnota byla 42.\n') <span class="comment"># zapíšeme hodnotu</span>      
        logsoubor.close()                     <span class="comment"># a soubor uzavøeme.</span>
        raise

try:
    f(42)
except ZeroDivisionError:
    print u'Nastalo dìlení nulou. Zkuste znovu.'
</pre>

<p>V praktickıch pøípadech èasto pouíváme jedinı log soubor a chceme do nìj
zapisovat na více místech v programu. Museli bychom tedy na více místech
opakovat vıše uvedené okomentované øádky. Problém by nastal v situaci, kdy
se rozhodneme napøíklad zmìnit jméno log souboru. V takovém pøípadì by nám
mìlo v hlavì varovnì zasvítit pravidlo <b>DRY</b> z anglického <em>Do not
Repeat Yourself</em>, èili volnì <em>Neopakujte se</em>. Vìc jednoduše
vyøešíme tím, e si pro zápis na konec log souboru vytvoøíme vlastní funkci <code>log()</code>.
S jejím vyuitím pak vısledek bude vypadat nìjak takto:</p>

<pre>
def log(zprava):
    logsoubor = file('errorlog.txt', 'a') <span class="comment"># Otevøeme pro pøipsání na konec,</span>
    logsoubor.write(zprava)               <span class="comment"># zapíšeme hodnotu</span>      
    logsoubor.close()                     <span class="comment"># a soubor uzavøeme.</span>

def f(hodnota):
    try:
        return 127 / (42-hodnota)
    except ZeroDivisionError:
        log('Hodnota byla 42.\n')  <span class="comment"># Zápis zprávy do log souboru.</span>
        raise

try:
    f(42)
except ZeroDivisionError:
    print u'Nastalo dìlení nulou. Zkuste znovu.'
</pre>

<p>V tomto okamiku byste si mohli øíci. <em>Proè bych za kadou zprávu
nepøidával automaticky pøechod na novı øádek pøímo ve funkci
<code>log()</code>?</em> Nedoporuèuji to. Uvìdomte si, e v takovém pøípadì
byste se zbavili monosti zapisovat postupnì nìkolika voláními funkce více
hodnot na jeden øádek log souboru. Místo toho je vhodnìjší vytvoøit další, 
specializovanìjší funkci, která vyuívá vıše definované, obecnìjší funkce
<code>log()</code>. Speciální funkce mùe napøíklad do log souboru zapisovat
i datum, èas a jmého pøihlášeného uivatele:</p>

<pre>
def log(zprava):
    logsoubor = file('errorlog.txt', 'a') <span class="comment"># Otevøeme pro pøipsání na konec,</span>
    logsoubor.write(zprava)               <span class="comment"># zapíšeme hodnotu</span>      
    logsoubor.close()                     <span class="comment"># a soubor uzavøeme.</span>

def logErr(text):
    import time                           <span class="comment"># Importujeme potøebné moduly.</span>
    import getpass
    tim = time.strftime('%c')             <span class="comment"># Získáme èasovou znaèku.</span>
    usr = getpass.getuser()               <span class="comment"># Získáme jméno uivatele.</span>
    log('%s %s: %s\n' % (tim, usr, text)) <span class="comment"># Zapíšeme zformátovanı øádek.</span>
    
def f(hodnota):
    try:
        return 127 / (42-hodnota)
    except ZeroDivisionError:
        logErr('Hodnota byla 42.')  <span class="comment"># Zápis zprávy do log souboru.</span>
        raise

try:
    f(42)
except ZeroDivisionError:
    print u'Nastalo dìlení nulou. Zkuste znovu.'
</pre>

</div>

<p>Za úèelem zjemnìní øízení našeho programu <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(nebo diagnostiky chyb)</span> mùeme
definovat své vlastní typy vıjimek. Èiníme tak prostøednictvím novıch tøíd
vıjimek. (S definicemi tøíd jsme se krátce seznámili rámci tématu <a
href="cztutdata.html#class">Data, datové typy a promìnné</a> a podrobnìji se
s nimi setkáme ještì pozdìji v kapitole vìnované <a
href="cztutclass.html">objektovì orientovanému programování</a>.) Pro tento
úèel obvykle definujeme tøídu velmi prostou, která nedefinuje ádnı další
obsah a která je pouze odvozena od <span class="trnote"
title="Poznámka&nbsp;pøekladatele">standardní bázové tøídy</span>
<code>Exception</code>. Pouívá se jako <em>chytré návìští</em>, které se dá
rozpoznávat v pøíkazech <code>except</code>. Spokojme se s následujícím
struènım pøíkladem:</p>

<pre>
class BrokenError(Exception): pass

try:
   raise BrokenError
except BrokenError:
   print u'Narazili jsme na chybu pøi zpracování.'
</pre>

<p class="trnote"><b>Poznámka pøekladatele:</b> Vzhledem k následující
autorovì poznámce jsem ponechal pùvodní anglickı identifikátor. Pøipojuji se
k vızvì dodrovat níe uvedenou konvenci.</p>

<p>Povšimnìte si, e jsme pøi tvorbì jména pouili konvenci, kdy se na konec
jména tøídy dává pøípona "Error" (èili chyba). Povšimnìte si, e
<em>dìdíme</em> chování obecné tøídy <code>Exception</code> <span
class="trnote" title="Poznámka&nbsp;pøekladatele">([iksepšn],
vıjimka)</span> tím, e její jméno uvedeme do závorek za jménem definované
tøídy. K dìdiènosti se podrobnìji dostaneme v kapitole vìnované <a
href="cztutclass.html">objektovì orientovanému programování</a>.</p>

<p>Ještì poslední poznámka k èásti tıkající se generování chyb. Prozatím
jsme pro <span class="trnote"
title="Poznámka&nbsp;pøekladatele">pøedèasné</span> ukonèování našich
programù provádìli importováním modulu <code>sys</code> a voláním jeho
funkce <code>exit()</code>. Jinı zpùsob, kterım dosáhneme naprosto stejného
vısledku, spoèívá ve vyvolání vıjimky <code>SystemExit</code>:</p>

<pre>
>>> raise SystemExit
</pre>

<p>Hlavní vıhoda tohoto pøístupu spoèívá v tom, e nemusíme nejdøíve provést
<code>import&nbsp;sys</code>.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> Osobnì se k tomuto postupu
moc nepøikláním. Volání funkce <code>exit()</code> je známé i z jinıch
jazykù a jinım ètenáøùm vašeho zdrojového textu mùe volání
<code>sys.exit()</code> pøipadat pøirozenìjší.</p>


<h3>JavaScript</h3>

<p>V jazyce JavaScript se zpracování chyb provádí velmi podobnì, jako v
jazyce Python. Jen místo pythonovskıch klíèovıch slov <code>try</code>,
<code>except</code> a <code>raise</code> se pouívají klíèová slova
<code>try</code>, <code>catch</code> <span class="trnote"
title="Poznámka&nbsp;pøekladatele">([keè], chytit)</span> a
<code>throw</code> <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(vrhnout, hodit)</span>.</p>

<p>Ukáeme si pár pøíkladù, ale principy zùstávají naprosto stejné jako v
jazyce Python. V jazyce JavaScript ale nemáme konstrukci
<code>try/finally</code>.</p>

<h4>Zachytávání chyb</h4>

<p>Zachytávání chyb v bloku kódu se pøedepisuje klíèovım slovem
<code>try</code> a sadou pøíkazù <code>catch</code> témìø stejnì, jako v
Pythonu:</p>

<pre>
&lt;script type="text/javascript">
try {
    var x = NeexistujiciFunkce();
    document.write(x);
}
catch(err) {
    document.write("Došlo k chybì.");
}
&lt;/script>
</pre>


<h4>Vyvolání chyby</h4>

<p>V jazyce Python jsme k vyvolání chyby pouívali klíèové slovo
<code>raise</code>. V jazyce JavaScript pouíváme podobnım zpùsobem
<code>throw()</code>. Také v jazyce JavaScript si mùeme vytvoøit vlastní
typy chyb, jako v Pythonu. Ale mnohem jednodušší zpùsob spoèívá v pouití
øetìzce.</p>

<pre>
&lt;script type="text/javascript">
try {
    throw("Nová chyba");
}
catch(e) {
    if (e == "Nová chyba")
        document.write("Zachytili jsme novou chybu.");
    else
        document.write("Nenastala nová chyba.");
}
&lt;/script>
</pre>

<p class="trnote"><b>Poznámka pøekladatele:</b> Øetìzce se pro vıjimky
pouívaly døíve i v jazyce Python. Z dùvodù zpìtné kompatibility jsou dosud
podporovány, ale u novıch programù se jejich pouívání nedoporuèuje. Do
budoucna se plánuje odstranìní této monosti.</p>

<p>To je vše, co si o zpracování chyb øekneme. V tématech pro pokroèilé
uvidíte pouití mechanismu pro zpracování chyb v praxi, spolu s pouitím
dalších základních konceptù, jako jsou posloupnosti, cykly a vìtvení. V
tomto okamiku ji máte k dispozici všechny podstatné nástroje, které
potøebujete pro vytváøení mocnıch programù. Moná byste si teï mìli zkusit
nìjaké vlastní programy vytvoøit. Staèí pár, jen abyste dostali popisované
mechanismy do hlavy pøed tím, ne se pustíme do dalších témat. Pár
námìtù:</p>

<ul>
<li>Jednoduchá hra, jako je OXO nebo šibenice.</li>
<li>Jednoduchá databáze &mdash; mohla by vycházet z našeho pøíkladu
    záznamníku s adresami &mdash; pro ukládání detailù vaší sbírky
    videozáznamù, DVD nebo CD.</li>
<li>Diáø, kterı vám umoní ukládat dùleité události a schùzky. A pokud se
    cítíte bıt <span class="trnote" 
    title="Viz Douglas Adams: Stopaøùv prùvodce po Galaxii."
    >dìsnı frúd</span>, nech se automaticky objevuje pøipomínka.</li>
</ul>

<p>Abyste se s vıše uvedenımi úkoly vyrovnali, budete muset pouít všechny
rysy jazyka, se kterımi jsme se dosud seznámili, a moná i pár dodávanıch
modulù. Nezapomeòte obèas nahlédnout do dokumentace. Pravdìpodobnì v ní
najdete pár vìcí, které vám ulehèí práci. Nezapomínejte taky na uiteènost
interaktivního reimu (<code>>>></code>). Zkoušejte si v nìm nové vìci,
dokud nepochopíte, jak fungují. Teprve poté pøeneste získané znalosti do
vašeho programu. Tímto zpùsobem pracují i profesionálové. A co je taky
dùleité, dobøe se bavte!</p>

<p>Nashledanou v èásti pro pokroèilé :-)</p>


<div class="remember">
<p class="title">Zapamatujte si</p>
<ul>
<li>V jazyce VBScript testujeme chybové kódy pøíkazem <code>if</code>.</li>
<li>Vıjimky se zachytávají v Pythonu zachytávají pomocí <code>except</code> 
    a v JavaScript pomocí <code>catch</code>.</li>
<li>Vygenerování vıjimky mùeme v Pythonu pøedepsat klíèovım slovem
    <code>raise</code>, v JavaScript pomocí <code>throw</code>.</li>
<li>Typy chyb jsou v jazyce Python vyjadøovány pomocí tøíd, v JavaScript
    pomocí øetìzcù.</li>
</ul>
</div>


<div class="foot">
<p class="navig">[ 
<a href="cztuttext.html" title="Práce s textem">pøedchozí</a> |
<a href="cztutcont.html">obsah</a> | 
<a href="cztutname.html" title="Prostory jmen">další</a> 
]</p>
<p class="note">Pokud vás napadne, co by se dalo na pøekladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztuterrors.html,v 1.8 2005/10/20 20:55:24 petr Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka' 
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20') 
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script> 

Tím budou do dopisu automaticky vloeny informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztuterrors.html,v 1.8 2005/10/20 20:55:24 petr Exp $</p>
</div>
</body>
</html>


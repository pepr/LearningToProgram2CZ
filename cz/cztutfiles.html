<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se nauèit programovat: Práce se soubory</title>
</head>
<body>

<h2>Práce se soubory</h2>

<div class="whatcovered">
<p class="title">O èem si budeme povídat?</p>
<ul>
<li>Jak se otvírá soubor.</li>
<li>Jak se ète z otevøeného souboru a jak se do nìj zapisuje.</li>
<li>Jak se soubor zavírá.</li>
<li>Adresy &mdash; program realizující záznamník na adresy.</li>
<li>Práce s binárními soubory.</li>
</ul>
</div>

<p>Zpracování souborù zaèáteèníky èasto pøivádí do úzkıch, aèkoliv dùvody
jsou pro mne tak trochu záhadou. Z pohledu programátora se soubory opravdu
nijak neliší od souborù, které pouíváme pøi práci s textovım editorem nebo
s jinou aplikací: musíme je <em>otevøít</em>, provedeme nìjaké operace s
obsahem a zase je <em>zavøeme</em>.</p>

<p>Nejvìtší rozdíl spoèívá v tom, e v programu se k souboru pøistupuje
<em>sekvenènì</em>. To znamená, e èteme od jeho zaèátku, postupnì po jednom
øádku. Textovı editor èasto dìlá toté, jene si obsah celého souboru
nejdøíve naète do pamìti, kde jej upravujete, a v okamiku ukonèení práce se
souborem obsah pamìti zapíše zpìt do souboru a uzavøe jej. <span
class="trnote" title="Poznámka pøekladatele">(Proto se vám mùe zdát, e
textovı editor nepouívá postupné ètení obsahu souboru.)</span> Další rozdíl
spoèívá v tom, e z programu obvykle soubor otvíráme jen pro ètení nebo jen
pro zápis. Pøi zápisu mùeme vytvoøit zcela novı soubor (nebo mùeme
pøepisovat obsah ji existujícího souboru) nebo obsah <em>pøipojujeme na
konec</em> (append) existujícího souboru.</p>

<p>Další operace, kterou mùeme pøi zpracování souboru pouít, je skok zpìt
na zaèátek.</p> 

<h3>Soubory &mdash; vstup a vıstup</h3>

<p>Podívejme se na to v praxi. Budeme pøedpokládat, e existuje soubor zvanı
<code>menu.txt</code> a e obsahuje seznam jídel:</p>

<pre>
spam &amp; vajíèka
spam &amp; opékané brambory
spam &amp; spam
</pre>

<p class="trnote"><b>Poznámka pøekladatele:</b> Pojem <em>spam</em> jsme si
ji vysvìtlovali. Pokud neètete texty uèebnice postupnì, naleznete vysvìtlení
<a href="cztuttrn.html#Pdata_spam">zde</a>. V jedné z epizod série <em>Monty
Python's Flying Circus</em> se slovo <em>spam</em> objevovalo velmi hojnì. 
S&nbsp;pøekvapivì podobnou frekvencí se v èeskıch titulcích objevovalo slovo
<em>prejt</em>. Není to toté. Je to jen podobnì struèné, co je pro titulky
(a pro dabing) asi dùleité.</p>

<p>Nyní napíšeme program, kterı obsah souboru pøeète a zobrazí jej na
vıstupu &mdash; podobnì jako to v Unixu dìlá pøíkaz <code>cat</code> nebo v
DOSu pøíkaz <code>type</code>.</p>

<pre>
<span class="comment"># Nejdøíve soubor otevøeme ke ètení (r jako read).</span>
vstup = file("menu.txt", "r")

<span class="comment"># Soubor naèteme do seznamu øádkù a pak
# kadou poloku seznamu (øádek) vytiskneme.</span>
for radek in vstup.readlines():
    print radek
<span class="comment"># A nyní soubor zase zavøeme.</span>
vstup.close()
</pre>

<p><b>Poznámka 1:</b> Operace <code>file()</code> vyaduje dva argumenty.
Prvním z nich je jméno souboru. Mùeme je pøedat prostøednictvím promìnné
nebo je mùeme zapsat pøímo jako øetìzec, jako jsme to uèinili zde.
(Takovému zápisu øetìzce se øíká literál. <span class="trnote"
title="Poznámka pøekladatele">Jde vlastnì o pøímo zapsanou øetìzcovou
konstantu</span>.) Druhı argument urèuje <em>reim</em>. Ten øíká, zda
soubor otvíráme pro ètení (r jako read) nebo pro zápis (w jako write).
Mùeme té urèit, zda se jedná o ASCII text nebo o binární data &mdash;
pøidáním 'b' za 'r' nebo za 'w' takto:
<code>open(jm_soub,&nbsp;"rb")</code>.</p>

<p class="note"><b>Poznámka 2:</b> K otevøení souboru jsme pouili funkci
<code>file()</code>. Starší verze jazyka Python místo ní pouívaly funkci
<code>open()</code>. Parametry obou funkcí jsou naprosto shodné. Pouívání
<code>open()</code> se stále dává pøednost, take v dalších ukázkách budeme
obvykle pouívat <code>open()</code>. Ale pokud se vám zdá pouívání
<code>file()</code> logiètìjší, pouívejte <code>file()</code>.</p>


<div class="trnote">

<p class="trnote"><b>Poznámka pøekladatele:</b> V dokumentaci se doèteme, e
<code>open()</code> je alias pro <code>file()</code> a doèteme se zde
také:</p>

  <blockquote>Zámìrem je, aby byla funkci <code>open()</code> i nadále
  dávána pøednost, pokud ji pouíváme jako <em>factory function</em><sup
  class="trnote" id="Bfiles_factoryFun" title="Vysvìtlení pojmu..." ><a
  href="cztuttrn.html#Pfiles_factoryFun">[1]</a></sup>, která vrací novı
  objekt typu soubor. Zápis <code>file</code> se lépe hodí pro testování
  typu (napøíklad pøi volání
  <code>isinstance(f,&nbsp;file)</code>).</blockquote>

<p>Z objektového pohledu (viz dále) ale mùeme v zápisu <code>file()</code>
vidìt také vytváøení objektu voláním jeho konstruktoru. Záleí tedy na tom,
jak se na vìc chcete dívat. Funkènì jsou obì volání naprosto shodná.</p>

</div>

<p><b>Poznámka 3:</b> Ze souboru jsme èetli a uzavírali jsme jej voláním
funkcí, pøed které jsme pøipsali souborovou promìnnou. Tomuto zápisu se øíká
<em>volání metody</em> a je to naše další setkání s <em>objektovou
orientací</em>. Teï si s tím nelamte hlavu. Jenom si všimnìte, e to má svım
zpùsobem vztah k modulùm. O pouité souborové promìnné mùete uvaovat, jako
kdyby to byla reference na modul, kterı obsahuje funkce pro práci se soubory
a kterı se jakoby automaticky importuje pokadé, kdy vytvoøíme souborovou
promìnnou.</p>

<p class="note"><b>Poznámka 4:</b> Na konci soubor uzavíráme voláním metody
<code>close()</code>. Python <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(a nejen Python)</span> sice všechny
<span class="trnote" title="Poznámka&nbsp;pøekladatele">otevøené</span>
soubory na konci programu uzavírá, ale mezi dobré zvyky patøí pøedepisování
uzavírání souborù pøímo. Proè? No, operaèní systém mùe odkládat zápis dat
do souboru a do doby, kdy je soubor uzavírán (kvùli zvıšení vıkonu
systému). Pokud náhodou váš program skonèí neoèekávanım zpùsobem, riskujete,
e vaše drahocenná data nebudou do souboru zapsána vùbec. Take pouèení zní:
Jakmile ukonèíte zápis do souboru, zavøete jej.</p>

<p>A teï uvame, jak bychom se mohli vypoøádat s dlouhımi soubory. V prvé
øadì bychom museli soubor èíst øádek po øádku. (V jazyce Python bychom místo
pouití <code>readlines()</code> a cyklu <code>for</code> museli pouít
<code>readline()</code> a cyklus <code>while</code>.) V takové situaci
bychom mohli bychom pouít promìnnou <code>poc_radku</code>, kterou bychom
zvyšovali pøi naètení kadého øádku a testovali bychom, zda dosáhla
hodnoty 25 (poèet øádku na obrazovce). Pokud by tato situace nastala,
poádáme uivatele, aby stiskl nìjaké tlaèítko (dejme tomu Enter). Potom
bychom <code>poc_radku</code> nastavili na nulu a pokraèovali bychom dál.
Mùete si to vyzkoušet jako cvièení&hellip;.</p>

<p>Od verze 2.2 se Python k souborovému objektu umí chovat, jako kdyby to
byl seznam <span class="trnote" title="Poznámka&nbsp;pøekladatele"
>øádkù</span>. To znamená, e v cyklu <code>for</code> nemusíme pouívat
<code>readlines()</code>, ale jednoduše procházíme všemi øádky souboru. S
vyuitím této vlastnosti mùeme pøedchozí pøíklad pøepsat takto:</p>

<pre>
<span class="comment"># Nejdøíve soubor otevøeme ke ètení (r jako read).</span>
vstup = file("menu.txt", "r")

<span class="comment"># Procházíme souborem a tiskneme kadou poloku (øádek).</span>
for radek in vstup:
    print radek
<span class="comment"># A nyní soubor zase zavøeme.</span>
vstup.close()
</pre>

<p>Vıhoda tohoto stylu spoèívá v tom, e nenarazíme na ádná omezení daná
velikostí pamìti, jako v pøípadì pouití <code>readlines()</code>. Take se
vlastnì kombinují vıhody cyklu <code>for</code> a vıše zmínìného øešení
vyuívajícího <code>while/readline()</code>.</p>

<p>Ukázali jsme si skuteènì všechno, co pro zpracování souboru potøebujeme.
Otevøeme soubor, èteme z nìj a manipulujeme <span class="trnote"
title="Poznámka pøekladatele">s naètenımi daty</span> jak potøebujeme.
Jakmile skonèíme, soubor uzavøeme. V pøedchozím pøíkladu jste si mohli
všimnout jednoho malého zádrhele. Naètené øádky ji na konci obsahují znak
konce øádku, take kdy je vytisknete pøíkazem <code>print</code>, kterı
pøidá navíc své konce øádkù, bude vıstup proloen prázdnımi øádky. Abychom
se tomu vyhnuli, mùeme pouít metodu zabudovaného øetìzcového typu
<code>rstrip()</code>, která z konce øetìzce odstraní všechny <em>bílé
znaky</em> &mdash; øíká se jim také <em>netisknutelné znaky</em>. (Existují
i pøíbuzné metody <code>lstrip()</code> a <code>strip()</code>, které
odstraòují bílé znaky zleva, respektive z obou koncù øetìzce.) Pokud tedy
èást vıše uvedeného pøíkladu upravíme do podoby...</p>

<pre>
for radek in vstup:
    print radek.rstrip()
</pre>

<p>... mìlo by to dopadnout podle oèekávání.</p>

<p>Kdy budeme v jazyce Python chtít zapsat program pro pøíkaz
<code>copy</code>, jednoduše otevøeme novı soubor pro zápis a místo tisku
naètenıch øádkù na displej je budeme zapisovat do tohoto souboru:</p>

<pre>
<span class="comment"># Vytvoøíme obdobu pøíkazu: COPY MENU.TXT MENU.BAK

# Nejdøíve otevøeme soubory pro ètení (r) a pro zápis (w).</span>
vstup = open("menu.txt", "r")
vystup = open("menu.bak", "w")

<span class="comment"># Øádky vstupního souboru kopírujeme do nového souboru.</span>
for radek in vstup:
    vystup.write(radek)

print "1 soubor okopírován..."

<span class="comment"># Nyní soubory zavøeme.</span>
vstup.close()
vystup.close()
</pre>

<p>Všimli jste si, e jsem na konci pouil pøíkaz <code>print</code> k tomu,
aby uivatel poznal, e se nìco stalo? Podobná <em>zpìtná vazba pro
uivatele</em> je obvykle vhodná.</p>

<p>Protoe jsme v tomto pøípadì zapisovali stejnı øádek, kterı jsme pøed tím
naèetli, nenastanou ádné problémy z konci øádkù. <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(Metoda <code>write()</code> nepøidává
další konec øádku.)</span> Pokud bychom ale chtìli zapisovat øetìzce, které
jsme si sami vygenerovali nebo které jsme pøed tím zbavili pravostrannıch
bílıch znakù metodou <code>rstrip()</code>, pak bychom museli na konec
vıstupního øetìzce znak nového øádku pøidat. Udìlali bychom to takto:</p>

<pre>
vystup.write(radek + '\n')  <span class="comment"># \n reprezentuje pøechod na novı øádek</span>
</pre>

<p>Podívejme se, jak <span class="trnote"
title="Poznámka&nbsp;pøekladatele">metodu write()</span> vyuijeme v našem
kopírovacím programu. Abychom soubor jen nekopírovali, pøidáme na zaèátek
souboru dnešní datum. Tím z jednoduše upravovatelného textového souboru s
nabídkou jídel vygenerujeme denní menu. Staèí, kdy pøed vlastním kopírováním
obsahu souboru <code>menu.txt</code> pøipíšeme na zaèátek nového souboru pár
øádkù:</p>


<pre>
<span class="comment"># -*- coding: cp1250 -*-</span>
<span class="comment"># Vytvoøíme denní menu podle obsahu souboru menu.txt.</span>

import time

<span class="comment"># Nejdøíve otevøeme soubory pro ètení (r) a pro zápis (w).</span>
vstup = open("menu.txt", "r")
vystup = open("menu.prn", "w")

<span class="comment"># Pøipravíme si øetìzec s dnešním datem.</span>
dnes = time.localtime(time.time())
datum = time.strftime(u"%A %d. %B", dnes)

<span class="comment"># Pøidáme øádek s nadpisem a prázdnı øádek.</span>
vystup.write(u"Denní nabídka pro %s\n\n" % datum) 

<span class="comment"># Øádky vstupního souboru kopírujeme do nového souboru.</span>
for radek in vstup:
    vystup.write(radek)

print u"Menu pro %s bylo vytvoøeno..." % datum

<span class="comment"># Nyní soubory zavøeme.</span>
vstup.close()
vystup.close()
</pre>

<p>Povšimnìte si, e jsme pouili modul <code>time</code> k získání aktuálního
data <span class="trnote" title="Poznámka&nbsp;pøekladatele">a èasu</span>
(<code>time.time()</code>) a k pøevodu na n-tici souvisejících hodnot
(<code>time.localtime()</code>), které jsou zase pouity funkcí
<code>time.strftime()</code> pro zformátování øetìzcové podoby data. Ten je
pøes další formátovací øetìzec vloen do nadpisu. <span class="trnote"
title="Poznámka&nbsp;pøekladatele">Vıslednı soubor pak</span> vypadá nìjak
takto:</p>

<pre>
Denní nabídka pro Sunday 07. August

spam &amp; vajíèka
spam &amp; opékané brambory
spam &amp; spam
</pre>

<p>Aèkoliv jsme na konec <span class="trnote"
title="Poznámka&nbsp;pøekladatele">formátovacího øetìzce nadpisu</span>
vloili dva znaky '<code>\n</code>', objevil se jen jeden prázdnı øádek. Je to
tím, e první znak zpùsobil ukonèení øádku s nadpisem <span class="trnote"
title="Poznámka&nbsp;pøekladatele">a teprve ten druhı zpùsobil vygenerování
prázdného øádku</span>. Správné vytváøení a odstraòování znakù pro novı øádek
patøí pøi zpracování textovıch souborù k jedné z tìch otravnìjších vìcí.</p>

<div class="trnote">

<p><b>Poznámka pøekladatele:</b> Pokud se vám v nadpisu a ve vypisovaném
upozornìní objevily anglické názvy dne a mìsíce &mdash; jak je naznaèeno v
pøíkladu vıstupu vıše &mdash;, je to tím, e jste Pythonu neoznámili, jaké
místní jazykové zvyklosti (locale) se mají pouívat. Zkuste za øádek
<code>import&nbsp;time</code> pøidat následující dva øádky:</p>

<pre>
import locale
locale.setlocale(locale.LC_ALL, 'cz')
</pre>

<p>Vıstupní soubor pak nabude o nìco lepší èeské podoby:</p>

<pre>
Denní nabídka pro nedìle 07. srpen

spam &amp; vajíèka
spam &amp; opékané brambory
spam &amp; spam
</pre>

<p>Musíme se však smíøit, e Python neumí skloòovat èesky. I kdyby to nìjakım
zázrakem umìl, pøi formátování data jsme stejnì nijak neuvedli, v jakém pádu
se má vısledek objevit, take jména dne a mìsíce budou uvedena v prvním pádu.
Povšimnìte si, e jsme na prvním øádku programu (formou speciálního komentáøe)
uvedli kódování, ve kterém je uloen zdrojovı text (zde pro Microsoft Windows,
podle potøeby je upravte). Povšimnìte si také, e øetìzce, které obsahují nebo
mohou obsahovat èeské znaky, uchováváme v kódování Unicode (pøed úvodní
uvozovkou píšeme písmeno <code><b>u</b></code>).</p>

</div>


<div class="details">

<h4>Konce øádkù v rùznıch operaèních systémech</h4>

<p>Celé téma <em>konce øádkù v textovıch souborech</em> patøí k temnım
stránkám nestandardizované implementace v rùznıch operaèních systémech.
Rozdíly mají své koøeny v dávnıch dnech úsvitu datovıch komunikací, v magii
ovládání mechanickıch dálnopisù. Nové øádky se indikují v podstatì tøemi
rùznımi zpùsoby:</p>

<ol>
<li>Znak návratu vozíku (Carriage Return &mdash; CR; '\r').</li>
<li>Znak posunu o øádek (Line Feed &mdash; LF; '\n').</li>
<li>Dvojice CR/LF ('\r\n').</li>
</ol>

<p>V rùznıch operaèních systémech se pouívají všechny tøi techniky. V
MS&nbsp;DOS (a odtud i v MS&nbsp;Windows) se pouívá tøetí zpùsob. Unix
(vèetnì Linuxu) pouívá druhou metodu. Apple ve svém pùvodním systému MacOS
pouívá první metodu, ale v souèasnosti pouívá metodu druhou. Je to dáno
tím, e <em>MacOS&nbsp;X</em> je ve skuteènosti variantou systému Unix.</p>

<p>Take jak se má chudák programátor s takovou rozdílností zakonèování
øádkù vyrovnávat? V mnoha jazycích musí prostì více testovat a provádìt jiné
akce v závislosti na konkrétním operaèním systému. V modernìjších jazycích,
vèetnì Pythonu, máme k dispozici prostøedky, které nám umoní tento zmatek
zvládnout. V pøípadì jazyka Python tato pomoc pøichází v podobì modulu
<code>os</code>. Ten definuje promìnnou zvanou <code>linesep</code>, která
obsahuje posloupnost konce øádku pro danı operaèní systém. Take pøidávání
novıch øádkù není sloité. Pokud je chceme naopak odstranit, pouijeme
<code>rstrip()</code>, kterı pøi odstraòování konce øádku zohlední
vlastnosti operaèního systému. Take pokud si chceme pøi zpracování koncù
øádkù zachovat pøíèetnost: k odstraòování koncù øádkù pouívejte vdy
<code>rstrip()</code> a pøed zápisem do souboru zakonèujte øádky pøidáním
<code>os.linesep</code>.</p>

<p>Stále zde zùstává nepøíjemná situace, kdy byl soubor vytvoøen v jednom
operaèním systému a zpracovává se naj jiném, nesluèitelném. Bohuel s tím
nic moc nenadìláme. Mùeme jen porovnat konce øádkù s
<code>os.linesep</code> a zjistit, v èem se liší.</p>

<div class="trnote">

<p class="trnote"><b>Poznámka pøekladatele:</b> Podle mého názoru mají vıše
vyjádøená skepse a uvedené rady smysl pouze v situaci, kdy obsah textového
souboru naèítáme v binárním reimu. V textovém reimu se v&nbsp;systému
MS&nbsp;Windows posloupnost koncù øádkù pøevádí pøi ètení na <code>\n</code>
automaticky (a to nejen v Pythonu), pøi zápisu se zase automaticky provádí
pøevod na dvojznakovou posloupnost. Osobnì jsem se nikdy nemusel zabıvat 
popisovanou situací a nikdy jsem nemusel pøímo pouívat
<code>os.linesep</code>.</p>

<p>V systému Unix se s tímto problémem mùeme setkat jen v pøípadì, kdy
naèítáme soubor vytvoøenı v jiném operaèním systému. Ani bych si to nìjak
ovìøoval, pøedpokládám, e jde o starı problém, kterı se pøi práci se
soubory v textovém reimu øeší u dávno. Se systémem MacOS ovšem nemám ádné
zkušenosti.</p>

</div>

</div>

<p>Pøi zpracování souboru byste mohli ještì chtít, aby se naètená data
pøidávala na konec existujícího souboru. Jednou z moností by bylo otevøít
vıstupní soubor pro ètení, naèíst jeho obsah do seznamu, pøipojit k seznamu
data ze vstupního souboru a nakonec celı seznam zapsat jako novou verzi
pùvodního vıstupního souboru. Pokud by byly soubory krátké, pak to nezpùsobí
ádné problémy. Ale pokud je vıstupní soubor velmi velkı, tøeba vìtší ne
100MB, pak vám prostì pøi vytváøení seznamu øádkù dojde pamì. <span
class="trnote" title="Poznámka pøekladatele">(I kdybyste mìli dostateènì
velkou pamì, takovı postup by byl èasovì nároènı.)</span> Naštìstí mùeme
operaci <code>open()</code> urèit další reim <code>"a"</code> (jako
append), kterı zajistí pøipojení dat na konec souboru &mdash; do souboru
prostì zapisujeme. Je to dokonce ještì vylepšené tím, e pokud soubor
neexistuje, bude vytvoøen novı soubor &mdash; jako kdybyste pouili reim
<code>"w"</code>.</p>

<p>Uveïme si pøíklad, kdy pouíváme takzvanı log<sup class="trnote"><a
href="cztuttrn.html#Pfiles_log" id="Bfiles_log" title="Proè se log-souboru
øíká log-soubor?">[2]</a></sup> soubor, do kterého zapisujeme chybová
hlášení. Pøitom ale nechceme smazat pøedchozí záznamy, take nové záznamy
pøipisujeme na konec souboru <span class="trnote" title="Poznámka pøekladatele"
>(error = chyba; msg = message [mesid] = zpráva)</span>:</p>

<pre>
def logError(msg):
   err = open("Errors.log", "a")
   err.write(msg)
   err.close()
</pre>

<p>V reálném svìtì bychom ovšem rádi nìjakım zpùsobem omezili velikost
souboru. Bìnì se pouívá technika, kdy se jméno souboru odvodí z aktuálního
data. Take kdy se datum zmìní, vytvoøí se automaticky novı soubor. Správce
systému pak mùe snadno najít chyby, které se staly v urèitı den. Mùe
snadno rozhodnout, které soubory jsou staré, archivovat je a odstranit v
pøípadì, kdy u nebudou potøebné. (Pøipomeòme si, e aktuální datum mùeme
zjistit pomocí funkcí modulu <code>time</code> &mdash; stejnì jako ve vıše
uvedeném pøíkladu generování denní nabídky.)</p>


<h3 id="Address">Oprášenı pøíklad záznamníku s adresami</h3>

<p>Pamatujete si na pøíklad záznamníku s adresami, kterı jsme poprvé
nakousli v tématu <a href="cztutdata.html#address">Data, datové typy a
promìnné</a> a poté vylepšili v kapitole <a href="cztutinput.html#address"
>Konverzace s uivatelem</a>? Teï z nìj udìlám nìco opravdu uiteèného tím,
e obsah záznamníku budeme ukládat do souboru. Pøi startu programu jej
samozøejmì budeme také naèítat. Pro tyto úèely si napíšeme pár funkcí. V
tomto pøíkladu tedy spojíme nìkolik prvkù a dovedností, kterımi jsme se
zabıvali v pøedešlıch tématech.</p>

<p>Náš základní návrh bude vyadovat funkci, která pøi startu pøeète obsah
souboru, a další funkci, která jej pøi ukonèování programu opìt do souboru
zapíše. Prostøednictvím další funkce uivateli nabídneme monost volby ze
zobrazeného menu. A kadou volbu poloky z menu budou obsluhovat další
funkce. Menu bude uivateli umoòovat:</p>

<ul>
<li>Pøidání poloky do záznamníku s adresami.</li>
<li>Odstranìní poloky ze záznamníku.</li>
<li>Nalezení a zobrazení existující poloky.</li>
<li>Ukonèení programu.</li>
</ul>


<h4>Naètení obsahu záznamníku</h4>

<pre>
jmeno_souboru = 'adresy.dat'

def nactiObsah(zaznamnik):
    import os
    if os.path.exists(jmeno_souboru):
        soubor = open(jmeno_souboru, 'r')
        for radek in soubor:
            jmeno = radek.rstrip()
	    polozka = soubor.next().rstrip()
            zaznamnik[jmeno] = polozka
    else:
        soubor = open(jmeno_souboru, 'w') <span class="comment"># vytvoø novı prázdnı soubor</span>
    soubor.close()
</pre>

<p>Povšimnìte si, e znaky koncù øádkù odstraòujeme voláním
<code>rstrip()</code>. Povšimnìte si také, e k získání dalšího øádku
souboru uvnitø tìla cyklu vyuíváme operace <code>next()</code>. A všimnìte
si také toho, e jsme jméno souboru uloili do promìnné, která je definována
na úrovni modulu. To znamená, e promìnnou <code>jmeno_souboru</code> mùeme
vyuít jak pøi naèítání, tak pøi ukládání dat.</p>

<div class="trnote">

<p><b>Poznámka pøekladatele k pøíkladu:</b> Osobnì nejsem pøíznivcem øešení,
kdy se v jednom cyklu <code>for</code> naèítají dva øádky souboru najednou.
První problém spoèívá v tom, e by druhı øádek ji nemusel bıt v souboru
pøítomen (napøíklad díky chybì pøi implementaci zápisu do souboru). V
takovém pøípadì vznikne pøi volání <code>next()</code> vıjimka, kterou zde
neošetøujeme. To by ale nebylo nejhorší &mdash; chyba by se rychle
ukázala.</p> 

<p>Za závanìjší prohøešek povauji to, e <em>zneuíváme</em> znalosti
vnitøní implementace cyklu <code>for</code> a spoléháme se, e funguje právì
tak, jak momentálnì funguje. Tuto znalost v kódu zveøejòujeme voláním metody
<code>next()</code> a mlèky pøedpokládáme, e je vše v poøádku. Jinımi
slovy, ve zdrojovém textu tím vyjadøujeme pøímou souvislost fungování cyklu
<code>for</code> a metody <code>next()</code>. Úvahy podobného typu se nám
mohou v budoucnu vymstít, protoe by se napøíklad chování cyklu
<code>for</code> mohlo zmìnit. V tomto pøípadì to není pravdìpodobné. Berte
to jako teoretickou monost.</p>

<p>V tomto pøípadì bych se pravdìpodobnì uchılil k øešení, které by se
tomuto problému vyhıbalo. Jeden záznam s celou adresou bych ukládal na jeden
øádek. Jeho èásti bych vhodnım zpùsobem na øádku pøi zápisu oddìloval a pøi
naèítání bych je (z jednoho øádku) odpovídajícím zpùsobem získal.</p>

<p>Za zbyteènou povauji celou vìtev <code>else</code>. Vytváøení souboru
ani po logické stránce neodpovídá operaci, pøi které bychom èekali pouze
ètení ze souboru.</p>

</div>

<h4>Uloení obsahu záznamníku</h4>

<pre>
def ulozObsah(zaznamnik):
    soubor = open(jmeno_souboru, 'w')
    for jmeno, polozka in zaznamnik.items():
        soubor.write(jmeno + '\n')
        soubor.write(polozka + '\n')
    soubor.close()
</pre>

<p>Povšimnìte si, e pøi zápisu dat musíme pøidávat znak konce øádku
('<code>\n</code>').</p>


<h4>Naètení uivatelského vstupu</h4>

<pre>
def nactiVolbu(menu):
    print menu
    volba = int(raw_input(u'Zvolte monost (1-4): '))
    return volba
</pre>


<div class="trnote">

<p><b>Poznámka pøekladatele:</b> Python verze 2.4.1 a pravdìpodobnì i
pøedchozí verze obsahují chybu v implementaci zabudované funkce
<code>raw_input()</code>. Pokud pouijeme parametr v kódování Unicode a
program spustíme pod MS&nbsp;Windows v konzolovém oknì, vypíše se vızva v
neoèekávaném kódování. Je to dáno tím, e MS&nbsp;Windows z historickıch
dùvodù pouívají v konzolovém (DOSovém) oknì jiné kódování, ne v oknech
grafického uivatelského rozhraní. Detailní popis chyby mùete nalézt
(anglicky) na SourceForge u projektu Python pod èíslem <a
href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1099364&amp;group_id=5470&amp;atid=105470"
>1099364</a>.</p>

<p>Jeden z vıvojáøù Pythonu navrhuje doèasné øešení, kdy øetìzec s vızvou
pøevedeme do kódování, které pouívá <code>stdout</code> (souborovı objekt
pro standardní vıstup) takto:</p>

<pre>
import sys
vyzva.encode(sys.stdout.encoding)
</pre>

<p>Nyní máme dvì monosti. Buï si definujeme vlastní funkci, která co do
funkènosti nahradí <code>raw_input()</code> a pøidìlíme jí vlastní jméno,
nebo upravíme funkènost pùvodní <code>raw_input()</code> jejím
pøedefinováním. Vybral jsem druhou monost, protoe ji lze vyuít pro opravu
stávajících programù. Vytvoøíme novou stejnojmennou funkci, která bude
uvnitø volat její zabudovanou variantu (viz pøedpona
<code>__builtins__</code>):</p>

<pre>
def raw_input(vyzva):
    import sys
    return __builtins__.raw_input(vyzva.encode(sys.stdout.encoding))
</pre>

<p>Obecnou nevıhodou tohoto i alternativního pøístupu je to, e
pøedefinovaná funkce má omezenou oblast platnosti. Pokud se chcete zeptat na
podrobnosti, uèiòte tak odkazem na konci této stránky.</p>

</div>


<h4>Pøidání poloky</h4>

<pre>
def pridejPolozku(zaznamnik):
    jmeno = raw_input(u'Vlote jméno: ')
    polozka = raw_input(u'Vlote ulici, mìsto a telefonní èíslo: ')
    zaznamnik[jmeno] = polozka
</pre>


<h4>Odstranìní poloky</h4>


<pre>
def odstranPolozku(zaznamnik):
    jmeno = raw_input(u'Vlote jméno: ')
    del(zaznamnik[jmeno])
</pre>


<h4>Nalezení poloky</h4>

<pre>
def najdiPolozku(zaznamnik):
    jmeno = raw_input(u'Vlote jméno: ')
    if jmeno in zaznamnik: <span class="comment trnote" title="Poznámka&nbsp;pøekladatele"># v originále je zaznamnik.keys(), ale je to zbyteèné</span>
       print jmeno, zaznamnik[jmeno]
    else: 
       print u"Lituji. Pro '%s' nebyla nalezena ádná poloka." % jmeno
</pre>


<h4>Ukonèení programu</h4>

<p>Pro ukonèení programu nebudeme psát nìjakou zvláštní funkci. Místo toho
budeme volbu na ukonèení testovat v podmínce cyklu <code>while</code>. Take
hlavní program bude vypadat takto:</p>

<pre>
def main():
    menu = u'''
    1) Pøidej poloku
    2) Odstraò poloku
    3) Najdi poloku
    4) Uloit a konec
    '''
    zaznamnik = {}
    nactiObsah(zaznamnik)
    volba = nactiVolbu(menu)
    while volba != 4:
        if volba == 1:
            pridejPolozku(zaznamnik)
        elif volba == 2:
            odstranPolozku(zaznamnik)
        elif volba == 3:
            najdiPolozku(zaznamnik)
        else: 
            print u'Neoèekávaná volba. Zkuste to znovu.'
        volba = nactiVolbu(menu)
    ulozObsah(zaznamnik)
</pre>

<p>Teï u zbıvá jen zavolat pøi spuštìní programu funkci
<code>main()</code>. Zajistíme to pøi pouití trošky pythonovské magie:</p>

<pre>
if __name__ == '__main__':
    main()
</pre>

<p>Tento záhadnı úsek kódu nám umoní spouštìt pythonovskı soubor buï jako
modul tím, e ho <code>import</code>ujeme, nebo jako program tim, e ho
spustíme. Rozdíl <span class="trnote" title="Poznámka&nbsp;pøekladatele">pøi
uvedenıch dvou pouitích pythonovského souboru</span> spoèívá v tom, e pøi
importování modulu je vnitøní promìnné <code>__name__</code> <span
class="trnote" title="Poznámka&nbsp;pøekladatele">(dva znaky podtrení na
zaèátku jména a dva na konci)</span> pøiøazeno jméno modulu. Pokud je soubor
spuštìn <span class="trnote" title="Poznámka&nbsp;pøekladatele">pøímo (tj.
pouit jako samostatnı program)</span>, je promìnná <code>__name__</code>
nastavena na hodnotu <code>'__main__'</code>. Tajemné, e?</p>

<p>Pokud nyní vloíte všechny kousky kódu do nového textového souboru a
uloíte jej jako <code>adresy.py</code>, mìlo by to jít spustit z
pøíkazového øádku operaèního systému tím, e napíšete:</p>

<pre>
C:\PROJEKTY> python adresy.py
</pre>

<p>Nebo prostì v Prùzkumníku (Explorer, MS&nbsp;Windows) poklepete na ikonu.
Mìlo by se spustit nové DOSové okno a po ukonèení programu by mìlo zas
zmizet.</p>

<p>V Linuxu by to vypadalo podobnì:</p>

<pre>
$ python adresy.py
</pre>

<p>Prostudujte si uvedenı kód, zkuste v nìm najít chyby (nechal jsem tam
pøinejmenším dvì, ale mùe jich tam bıt i více) a zkuste je opravit.
Vıslednı cca 70 øádkovı program je typickım pøedstavitelem programù, které
byste mohli zaèít psát pro svou vlastní potøebu. Pár vìcí se v nìm dá
vylepšit &mdash; dostaneme se k tomu v další èásti &mdash;, ale i v této
podobì jde o rozumnì uiteènı, malı nástroj.</p>


<h3>VBScript a JavaScript</h3>

<p>Ani jeden z jazykù VBScript a JavaScript nepodporuje práci se soubory.
Jde o rys související s bezpeèností. Zajišuje, e nikdo nebude schopen èíst
vaše soubory v situaci, kdy jste si nevinnì stáhli nìjakou webovou stránku.
Na druhou stranu se tím však omezuje obecná pouitelnost obou jazykù. V
èásti zabıvající se znovupouitelností modulù jsme se ale dozvìdìli, e si v
tomto smìru mùeme pomoci, kdy pouijeme <a
href="cztutfunc.html#wsh">Windows Script Host</a>. WSH nám dává k dispozici
objekt <code>FileSystem</code>, kterı jakémukoliv WSH jazyku umoní ètení
souborù. Nejdøíve se podíváme na pøíklad v JavaScript a potom si jej
srovnáme s øešením v jazyce VBScript. Ale znovu uvidíme, jako v pøedchozím
pøípadì, e klíèovımi prvky øešení budou volání WScript objektù.</p>

<p>Ne se dostaneme k podrobnostem, mìli bychom se zmínit o <em>objektovém
modelu</em> <code>FileSystem</code>. Objektovım modelem rozumíme sadu
vzájemnì souvisejících objektù <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(tøíd)</span>, které mùe programátor
pøímo vyuívat. V rámci WSH se objektovı model <code>FileSystem</code>
skládá z objektù <code>FSO</code> a z øady objektù <span class="trnote"
title="Poznámka&nbsp;pøekladatele">typu</span> <code>File</code>, vèetnì
objektu <code>TextFile</code>, kterı budeme pouívat. Najdeme zde také
pomocné objekty. Pro naše úèely z nich budeme vyuívat objekt
<code>TextStream</code>. V podstatì budeme postupovat tak, e vytvoøíme
instanci objektu <span class="trnote"
title="Poznámka&nbsp;pøekladatele">tøídy</span> <code>FSO</code>, tu
pouijeme pro vytvoøení objektù <span class="trnote"
title="Poznámka&nbsp;pøekladatele">tøídy</span> <code>TextFile</code> a z
nich vytvoøíme objekty <code>TextStream</code>. Do nich budeme zapisovat
nebo z nich budeme èíst. 

<span class="ir">The <TT>TextStream</TT> objects 
themselves are what we actually read/write from the files.</span>  

</p>

<p>Následující kód ulote do souboru nazvaného <code>zkusSoubory.js</code> a
spuse jej pomocí <code>cscript</code> zpùsobem, kterı jsme pouili v úvodu
k WSH <span class="trnote" title="Poznámka&nbsp;pøekladatele">(tedy
<code>cscript&nbsp;zkusSoubory.js</code>)</span>.</p>

<h4>Otevøení souboru</h4>

<p>Abychom ve WSH mohli otevøít soubor, musíme si vytvoøit objekt typu
<code>FSO</code> a poté jeho prostøednictvím vytvoøit objekt
<code>TextFile</code>.</p>

<pre>
var jmenoSouboru, fso, inSoubor, outSoubor, radek;

<span class="comment">// Získáme jméno souboru.</span>
fso = new ActiveXObject("Scripting.FileSystemObject");
WScript.Echo("Jak se bude soubor jmenovat? ");
jmenoSouboru = WScript.StdIn.Readline();

<span class="comment">// Otevøeme inSoubor pro ètení a outSoubor pro zápis.</span>
inSoubor = fso.OpenTextFile(jmenoSouboru, 1); <span class="comment">// reim 1 = ètení</span>
jmenoSouboru = jmenoSouboru + ".BAK"
outSoubor = fso.CreateTextFile(jmenoSouboru);
</pre>

<h4>Ètení a zápis</h4>

<pre>
<span class="comment">// Cyklus pøes vstupní soubor, dokud nenarazíme na konec.</span>
while ( ! inSoubor.AtEndOfStream){
    radek = inSoubor.ReadLine();
    WScript.Echo(radek);
    outSoubor.WriteLine(radek);
    }
</pre>

<h4>Uzavøení souborù</h4>

<pre>
inSoubor.close();
outSoubor.close();
</pre>

<h4>Teï v jazyce VBScript</h4>

<pre>
&lt;?xml version="1.0" <span class="trnote" title="Poznámka&nbsp;pøekladatele">encoding="UTF-8"</span> ?>

&lt;job>
  &lt;script language="VBScript">
      Dim fso, inSoubor, outSoubor, inJmenoSouboru, outJmenoSouboru
      Set fso = CreateObject("Scripting.FileSystemObject")
      
      WScript.Echo "Zadejte jméno souboru pro zálohu."
      inJmenoSouboru = WScript.StdIn.ReadLine
      outJmenoSouboru = inJmenoSouboru &amp;amp; ".BAK"
      
      <span class="comment">' Otevøeme soubory.</span>
      Set inSoubor = fso.OpenTextFile(inJmenoSouboru, 1)
      Set outSoubor = fso.CreateTextFile(outJmenoSouboru)

      <span class="comment">' Èteme soubor a vytváøíme záloní kopii.</span>
      While not inSoubor.AtEndOfStream
         line = inSoubor.ReadLine
	 outSoubor.WriteLine(line)
      Wend
      
      <span class="comment">' Uzavøeme oba soubory.</span>
      inSoubor.Close
      outSoubor.Close
      
      WScript.Echo inJmenoSouboru &amp;amp; " zálohován do " &amp;amp; outJmenoSouboru
  &lt;/script>
&lt;/job>
</pre>


<div class="trnote">
<p><b>Poznámka pøekladatele:</b> Soubor uloíme do souboru
<code>zkusSoubory.wsf</code> a spustíme:</p>
                                                 
<pre>
C:\PROJEKTY> cscript zkusSoubory.wsf 
</pre>
</div>

<h3>Práce s netextovımi soubory</h3>

<p>Zpracování textu patøí k jednomu z nejbìnìjších programátorskıch úkolù.
Obèas ale potøebujeme zpracovávat i binární data. V jazycích VBScript nebo
JavaScript se s tímto problémem setkáme velmi zøídka <span class="trnote"
title="Poznámka&nbsp;pøekladatele">&mdash; u jen proto, e nemají pøímou
podporu práce se soubory &mdash;</span>, take se budeme zabıvat jen tím,
jak se s tím vypoøádáme v jazyce Python.</p>

<h4>Otvírání a uzavírání binárních souborù</h4>

<p>Klíèovı rozdíl mezi textovımi a binárními soubory spoèívá v tom, e
textové soubory jsou sloené z <em>oktetù</em> (nebo bajtù) s binárními
daty, kde kadı bajt reprezentuje znak. Konec souboru je oznaèen speciálním
bajtem, kterému se anglicky obecnì øíká <em>end of file</em> <span
class="trnote" title="Poznámka&nbsp;pøekladatele">[end of fajl]</span> nebo 
<em>eof</em> (èili konec souboru). Binární soubor obsahuje libovolná binární
data, take pro identifikaci konce souboru nemùe bıt pouita ádná
speciální hodnota. Pro ètení takovıch souborù se proto musí pouít jinı
reim. Pokud tedy v Pythonu (nebo v jiném programovacím jazyce) otvíráme
binární soubor, musíme jej otevøít v binárním reimu. V opaèném pøípadì
riskujeme, e soubor bude ukonèen v místì prvního vıskytu znaku
<code>eof</code>, kterı Python nalezne mezi binárními daty. Binárního
otevøení souboru v jazyce Python dosáhneme tak, e k parameru reimu
pøidáme <code>'b'</code>:</p>

<pre>
binarniSoubor = file('binSoubor.bin', 'rb')
</pre>

<p>Jedinou odlišnost od otvírání textového souboru pøedstavuje hodnota
reimu <code>'rb'</code>. Písmeno <code>'b'</code> mùeme pøidat i k
ostatním reimùm: <code>'wb'</code> pro zápis, <code>'ab'</code> pro
pøipojování za konec souboru.</p>

<p>Uzavírání binárního souboru se provádí stejnì, jako u textového souboru.
Jednoduše zavoláme metodu otevøeného souborového objektu
<code>close()</code>:</p>

<pre>
binarniSoubor.close()
</pre>

<p>Protoe soubor byl otevøen v binárním reimu, nemusíme Pythonu poskytovat
nìjakou další zvláštní informaci &mdash; Python ví, jak má soubor korektnì
uzavøít.</p>

<div class="trnote">

<p><b>Poznámka pøekladatele:</b> Mùj osobní pohled na rozdíl v binárních a
textovıch souborech je trochu jinı. Hlavní odlišnost spatøuji v tom, zda
existuje obecnì pøijímaná interpretace uloenıch dat, èi nikoliv. Jinımi
slovy se dá øíci, e odlišnost spoèívá v tom, zda existuje obecnì pøijímanı
<em>abstraktní pohled</em> na uloená data. Obecnì se pøijímá to, e v
textovém souboru jsou uloeny znaky a e se textovı soubor èlení na øádky.
Jde o technickı pohled. Z jazykového hlediska bychom mohli text èlenit na
odstavce, vìty, slova, znaky uvnitø slov a znaky, které nejsou souèástí
slov. Zùstaòme u technického pohledu.</p>

<p><em>Textovı soubor</em> lze v souèasnosti povaovat za pouhou variantu
binárních souborù. Dohodnutá interpretace si vynucuje, aby obsahoval jen
urèitou podmnoinu všech monıch binárních kombinací. Pokud víme, e se na
soubor máme dívat jako na textovı, jsme napøíklad schopni vytisknout nebo
jinak zobrazit jeho lidsky èitelnou podobu.</p>

<p>Pokud bychom chtìli bıt pøísní, mìl by textovı soubor obsahovat pouze
písmena, další tisknutelné znaky, mezeru a sekvence pro oddìlování øádkù (CR
a LF &mdash; viz poznámka vıše). Oddìlovaèe øádkù patøí mezi takzvané
<em>øídicí znaky</em>. Tento pojem pochází z doby dálnopisù &mdash; tyto
znaky øídily èinnost dálnopisu, pokud zrovna nemìl nìco tisknout. Historické
a technické souvislosti zpùsobily, e se za souèást textovıch souborù
povaují i další øídicí znaky, jako je znak tabulaèní ('<code>\t</code>'),
znak zpìtného posuvu ('<code>\b</code>' z anglického back), znak
<em>alarm</em> ('<code>\a</code>', dálnopis cinknul), a další. Patøí sem i
znak, kterı ukonèuje konec souboru, ale v souèasnıch textovıch souborech se
nepovauje za povinnı.</p>

<p><em>Binární soubor</em> ádnou dohodnutou interpretaci nemá. To znamená,
e bez dalších znalostí nevíme, co data znamenají, jak s nimi máme zacházet,
kolik bajtù nebo bitù tvoøí jeden informaèní celek, zda soubor obsahuje
posloupnost informaèních jednotek o stejné velikosti, èi nikoliv, atd.</p>

<p><em>Stupnì abstrakce</em> se tedy pøi práci se soubory v binárním a v
textovém reimu liší. Práci se soubory v binárním reimu musíme z hlediska
zpracování systémem povaovat za práci na niší úrovni abstrakce. S vyšší
úrovní abstrakce textovıch souborù souvisí existence nìkterıch operací, jako
je napøíklad naètení jednoho øádku.</p>

</div>

<div class="details">

<h4 id="encoding">Reprezentace dat a jejich ukládání</h4>

<p>Ne si øekneme, jak mùeme pøistupovat k datùm v binárním souboru, mìli
bychom se dozvìdìt nìco o tom, jakım zpùsobem jsou data reprezentována a
ukládána v poèítaèi. Veškerá data jsou ukládána jako posloupnosti binárních
èíslic (<em>bi</em>nary digi<em>t</em>), bitù. Bity se sdruují do skupin po
8 nebo po 16 a nazıvají se bajty (bytes), respektive slova (words). (Skupiny
po 4&nbsp;bitech se nìkdy nazıvají nibble.) Bajt mùe obsahovat jeden z 256
rùznıch vzorkù, kterım jsou pøiøazeny hodnoty 0&ndash;255.</p>

<p>Veškeré informace, se kterımi v našich programech manipulujeme &mdash;
øetìzce, èísla a další &mdash;, musí bıt pøevedeny na posloupnosti bajtù. To
znamená, e pro znaky, které jsme pouili v øetìzci, musíme vyhradit
odpovídající vzorek bajtù. V minulosti se pouívalo nìkolik zpùsobù
<em>kódování</em>, ale nejpouívanìjším se stalo takzvané <em>ASCII</em>
kódování (<b>A</b>merican <b>S</b>tandard <b>C</b>oding for
<b>I</b>nformation <b>I</b>nterchange). Èisté ASCII je naneštìstí definováno
jen pro 128 hodnot, co nestaèí pro pouití v neanglickıch jazycích. Pozdìji
byl navren novı kódovací standard, známı jako <em>Unicode</em>. Ten pro
ukládání datové reprezentace znakù pouívá místo bajtù slova, co umoòuje
kódovat pøes 65000 znakù. Pokud pouijeme kódovací formát UTF-8, pak pùvodní
soubory v ASCII kódování pøedstavují korektní reprezentaci Unicode textu.
Python standardnì podporuje kódování ASCII. Pokud pøed zápis øetìzce uvedeme
písmeno <code><b>u</b></code>, bude se øetìzec povaovat za øetìzec v
kódování Unicode.</p>


<div class="trnote">

<p><b>Poznámka pøekladatele:</b> O vìcech souvisejících se standardem
Unicode se mùeme podrobnìji doèíst na stránkách <a
href="http://www.unicode.org/">http://www.unicode.org/</a>. Technickı úvod
ke standardu Unicode naleznete na stránce <a
href="http://www.unicode.org/standard/principles.html"
>http://www.unicode.org/standard/principles.html</a> (principy, formáty).</p>

<p>Vıše uvedená informace o poètu bajtù na znak a o poètu kódovanıch znakù
je nepøesná. Standard Unicode verze 4.0 definuje kódy pro 96447 znakù.
Unicode verze 4.1.0 pøidává dalších 1273 znakù. Standard definuje
jednoznaèné kódy pro kadı znak. Pro ukládání do souboru se pouívají
kódovací formáty UTF-8, UTF-16 a UTF-32. Urèují zpùsob, jakım se jednoznaèné
èíslo znaku pøevede do binární podoby pro uloení v souboru. Pokud pouijeme
formát UTF-32, pak je kadı znak kódován na 4 bajtech. Pokud pouijeme
UTF-16, pak je vìtšina znakù kódována na 2 bajtech a nìkteré na 4 bajtech.
Pokud pouijeme kódování UTF-8, pak jsou ASCII znaky kódovány na jednom
bajtu, ale nìkteré znaky vyadují a 4 bajty.</p>

<p>Pokud chceme pracovat s Unicode øetìzci v neanglickıch jazycích, musíme
na zaèátku zdrojového textu pythonovského programu uvést speciální komentáø,
kterı øíká, v jakém kódování je zdrojovı text uloen. Pøi pøekladu zápisu
øetìzce pak mùe dojít ke korektnímu pøevodu zápisu do Unicode.</p>

</div>

<p>Do binárního kódování musíme pøevádìt i èísla. Pro malá celá èísla staèí
pøímo vyuít hodnoty jednoho bajtu. Ale pro èísla vìtší, ne 255 (nebo pro
záporná èísla, nebo pro racionální èísla) musíme uèinit nìco navíc. Bìhem doby
se objevila celá øada standardù pro kódování numerickıch dat. Vyuívá je
vìtšina programovacích jazykù a operaèních systémù. Øadu zpùsobù kódování
èísel s plovoucí øádovou èárkou vydal napøíklad americkı <em>Institute of
Electrical and Electronic Engineering</em> (IEEE).</p>

<p>Pointa spoèívá v tom, e pøi ètení binárního souboru musíme v našem
programu zajistit pøevod surovıch bitovıch vzorkù <span class="trnote"
title="Poznámka&nbsp;pøekladatele">na hodnotu</span> správného <em>datového
typu</em>. Sérii bajtù, kterou jsme pùvodnì zapsali jako øetìzec znakù, mùeme
klidnì naèítat jako sérii èísel v plovoucí øádové èárce. Pùvodní vıznam se tím
samozøejmì ztratí. <span class="trnote" title="Poznámka&nbsp;pøekladatele"
>Chci jen naznaèit</span>, e stejnı bitovı vzorek mùe reprezentovat oba
pøípady. Pokud tedy naèítáme binární data, je velmi dùleité, abychom je
pøevedli na správnı datovı typ.</p>

</div>

<h4>Modul <code>struct</code></h4>

<p>Pro kódování a dekódování binárních dat mùeme v Pythonu vyuít modulu
<code>struct</code> (zkratka pro <em>structure</em>, tedy struktura). Tento
modul pracuje podobnì, jako kdy jsme pouívali formátovací øetìzec pro tisk
dat rùzného typu. Zadáváme øetìzec, kterı reprezentuje typ naèítanıch dat, a
ten je pouit pro proud bajtù, kterı se pokoušíme interpretovat. Modul
<code>struct</code> mùeme pouít také pro pøevod dat na proud bajtù urèenıch
k zápisu do binárního souboru (nebo dokonce do komunikaèní linky).</p>

<p>Modul definuje øadu kódù pro pøevod formátù, ale my zde pouijeme jen kódy
pro celá èísla a pro øetìzce. (Ostatní kódy si mùete vyhledat v dokumentaci k
modulu <code>struct</code>, kterı je souèástí distribuce Pythonu. Kódy pro
celé èíslo a øetìzec jsou <code>i</code> respektive <code>s</code>.
Formátovací øetìzec modulu <code>struct</code> se skládá z posloupnosti kódù,
kterım jsou pøedøazena èísla, urèující kolik prvkù pøíslušného typu chceme
získat. Tak napøíklad zápis <code>4s</code> znamená, e chceme øetìzec o délce
4 znaky.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> Èíslo pøed øetìzcovou znaèkou
se chápe jinak, ne èísla pøed znaèkami pro jiné typy. U øetìzce udává délku
získávaného øetìzce, u znaèek ostatních typù jde skuteènì o poèet hodnot
daného typu. Tak napøíklad znaèka <code>10s</code> vyjadøuje <em>jeden</em>
øetìzec o délce 10 znakù, zatímco znaèka <code>10c</code> vyjadøuje
<em>deset</em> jednoznakovıch øetìzcù (Python nezná typ <em>znak</em>).</p>

<p>Dejme tomu, e bychom chtìli detaily adresy ve vıše zmínìném záznamníku adres
zapisovat jako binární data, kde by èíslo domu bylo uloeno jako celé èíslo a
zbytek by byl uloen jako øetìzec. (Z praktického hlediska to zase není tak
dobrı nápad, protoe <em>èísla domù</em> nìkdy obsahují i písmena.)
Formátovací øetìzec by pak vypadal nìjak takto:</p>

<pre>
'i34s'  <span class="comment"># Pøedpokládáme, e na adresu je vyhrazeno 34 znakù.</span>
</pre>

<p>Pokud bychom potøebovali pracovat s rùznou délkou adresy, mohli bychom si
napsat funkci, která vytvoøí její binární podobu takto:</p>

<pre>
def formatujAdresu(adresa): 
    <span class="comment"># split rozdìlí øetìzec na seznam 'slov'.</span>
    slova = adresa.split()
    cislo = int(slova[0])
    zbytek = ' '.join(slova[1:])
    format = "i%ds" % len(zbytek) <span class="comment"> # vytvoø formátovací øetìzec</span>
    return struct.pack(format, cislo, zbytek)
</pre>

<p>Take adresu jsme rozsekali na kousky metodou <code>split()</code> <span
class="trnote" title="Poznámka&nbsp;pøekladatele">zabudovaného typu
øetìzec</span>. První slovo jsme pøevedli na èíslo a ostatní slova jsme opìt
spojili mezerami do jednoho øetìzce. Jeho délku potøebujeme pro vygenerování
formátovacího øetìzce pro metodu modulu <code>struct</code>.</p>

<p>Funkce <code>formatujAdresu()</code> vrací posloupnost bajtù, které
zachycují binární vyjádøení zadané adresy. Kdy u tedy máme potøebná binární
data, podívejme se, jak je mùeme do binárního souboru zapsat a zase je zpìt
pøeèíst.</p>

<h4>Ètení a zápis s vyuitím modulu <code>struct</code></h4>

<p>Vytvoøíme si binární soubor, kterı bude obsahovat jedinı øádek adresy <span
class="trnote" title="Poznámka&nbsp;pøekladatele">pøevedenı do binární
podoby</span> vıše nadefinovanou funkcí <code>formatujAdresu()</code>. Soubor
musíme otevøít pro zápis v binárním reimu (<code>'wb'</code>), zakódujeme
data, zapíšeme je do souboru a ten následnì uzavøeme. Vyzkoušejme si to:</p>

<pre>
import struct

f = file('adresa.bin','wb')
data = "10 Ulice, Mìsto, 0171 234 8765"
bindata = formatujAdresu(data)
f.write(bindata)
f.close()
</pre>

<p>Otevøením souboru <code>adresa.bin</code> v Poznámkovém bloku (notepad,
<span class="trnote" title="Poznámka&nbsp;pøekladatele">pøípadnì v jiném
editoru</span>) si mùete ovìøit, e data byla skuteènì zapsána v binárním
tvaru. Znaky adresy sice budou èitelné, ale neuvidíme zde ádné èíslo 10.</p>

<p>Abychom adresu ze souboru opìt pøeèetli, musíme jej otevøít v reimu
<code>'rb'</code>, naèíst data jako posloupnost bajtù, uzavøít soubor a
nakonec data rozbalit metodou <code>unpack()</code> modulu
<code>struct</code>. K tomu opìt potøebujeme formátovací øetìzec. Otázka zní,
jak by mìl vypadat? V našem pøípadì víme, e musí bıt stejnı jako ten, kterı
jsme si pøipravili uvnitø funkce <code>formatujAdresu()</code> &mdash;
konkrétnì <code>iNs</code>, kde N musíme nahradit konkrétním èíslem. Ale jak
hodnotu N zjistíme?</p>

<p>V modulu <code>struct</code> najdeme také pomocné funkce, které vracejí
velikost kadého datového typu. Kdy si spustíme Python v interaktivním
reimu, pak po pár pokusech zjistíme, kolik bajtù zabírají hodnoty rùzného
datového typu:</p>

<pre>
>>> import struct
>>> print struct.calcsize('i')
4
>>> print struct.calcsize('s')
1
</pre>

<p>Take teï u víme, e èíslo zabere 4 bajty a kadı znak øetìzce zabere
jeden bajt. To znamená, e N spoèítáme jako délku dat mínus 4. Vyzkoušejme si
naèíst obsah našeho souboru:</p>

<pre>
import struct

f = file('adresa.bin','rb')
data = f.read()
f.close()

format = "i%ds" % (len(data) - 4)
cislo, zbytek = struct.unpack(format, data)
adresa = str(cislo) + ' ' + zbytek
print adresa
</pre>

<p>Co se tıká binárních souborù je to vše, k èemu jsem se chtìl vyjádøit.
Jistì jste si všimli, e pouívání binárních dat vede ke komplikacím. Pokud
k tomu nemáte velmi dobrı dùvod, pak uvedenı pøístup rozhodnì nedoporuèuji.
Pokud ovšem skuteènì potøebujete èíst binární soubor, je to moné. V takovém
pøípadì ovšem musíte vìdìt, co data reprezentují.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> V uvedeném pøíkladu
pøedpokládáme, e pracujeme s øetìzci, kde je kadı znak uloen na jednom
bajtu. Pokud bychom navíc potøebovali pracovat s Unicode øetìzci, pak se pøi
pouitém kódování UTF-8 mùe poèet bajtù pro uloení znaku mìnit. Novìjší
verze jazyka Python navíc podporují i celoèíselnı typ, kde hodnota tohoto typu
mùe bıt vìtší, ne jakou mùeme zachytit na 4 bajtech. Poøadí ukládanıch
bajtù èísla se navíc øídí pravidly konkrétního vıpoèetního prostøedí
(little/big endian). Pokud tedy chceme zaøídit pøenositelnost takto
vygenerovanıch binárních souborù do na jiné systémy, musíme si pomoci
explicitním uvedením dalších formátovacích znaèek, které pøedepíší konkrétní
poøadí ukládání bajtù. Vìci mohou bıt mnohem komplikovanìjší, ne se na první
pohled zdá.</p>


<div class="remember">
<p class="title">Zapamatujte si</p>
<ul>
<li>Pøed pouitím souborù je musíte otevøít.</li>
<li>Ze souborù mùeme obvykle jen èíst nebo do nich mùeme jen zapisovat,
  ale ne obojí souèasnì.</li>
<li>Funkce <code>readlines()</code> jazyka Python pøeète všechny øádky
  souboru najednou, zatímco funkce <code>readline()</code> pøeète jen jeden
  øádek. Mùe nám to pomoci šetøit pamìtí.</li>
<li>Po pouití soubor uzavøete.</li>
<li>Pøi práci se soubory v binárním reimu musíme navíc uvést pøíznak
  '<code>b</code>'.</li> 
</ul>
</div>

<div class="foot">
<p class="navig">[ 
<a href="cztutfunc.html" title="Moduly a funkce">pøedchozí</a> |
<a href="cztutcont.html">obsah</a> | 
<a href="cztuttext.html" title="Práce s textem">další</a> 
]</p>
<p class="note">Pokud vás napadne, co by se dalo na pøekladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztutfiles.html,v 1.9 2005/10/07 19:16:51 petr Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka' 
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20') 
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script> 

Tím budou do dopisu automaticky vloeny informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztutfiles.html,v 1.9 2005/10/07 19:16:51 petr Exp $</p>
</div>
</body>
</html>


<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se nauèit programovat: Úvod do funkcionálního programování</title>
</head>
<body>

<p class="ir">Níe uvedenı text pochází z prvního vydání. Nad tímto textem 
se nachází aktuální stav po revizi smìøující k druhému vydání.</p>

<h2>Funkcionální programování</h2>

<div class="whatcovered">

<p>V této kapitole se podíváme na to, jak jazyk Python podporuje další styl
programování, takzvané <em>funkcionální programování</em>. Podobnì jako
u&nbsp;<a href="cztutrecur.html">rekurze</a> jde vyloenì o téma pro
pokroèilé, které v tomto okamiku mùete jednoduše ignorovat. Techniky
funkcionálního programování mají své pouití i v kadodenní programátorské
praxi. Zastánci funkcionálního programování vìøí, e pøedstavuje od základù
lepší zpùsob vıvoje software.</p>

</div>

<h3>Co to vlastnì je funkcionální programování?</h3>

<p>Funkcionální programování by se nemìlo zamìòovat s pøíkazovım (nebo také
procedurálním) programováním. Nepodobá se ani objektovì orientovanému
programování. Jde o nìco jiného. Ne sice <em>zcela</em> jiného, protoe
koncepty, se kterımi budeme pracovat, patøí k známım konceptùm programování.
Jsou pouze vyjádøeny jinım zpùsobem. Mírnì se liší i základní filozofie
zpùsobu pouívání tìchto konceptù pøi øešení problémù.</p>

<p>Funkcionální programování je zaloené na <em>vırazech</em> <span
class="trnote" title="Poznámka pøekladatele">(ve smyslu
matematickém)</span>. Funkcionální programování bychom vlastnì mohli popsat
termínem <em>programování orientované na vırazy</em>, protoe se zde vše
redukuje právì na vırazy. Asi byste si mohli vzpomenout, e vıraz je sloen
z operací a promìnnıch takovım zpùsobem, e jeho vısledkem je jedna hodnota.
Take napøíklad <code>x&nbsp;==&nbsp;5</code> je boolovskı vıraz. Zápis
<code>5&nbsp;+&nbsp;(7&nbsp;-&nbsp;y)</code> pøedstavuje aritmetickı vıraz.
A u zápisu <code>string.search("Ahoj, vy tam!", "Aho")</code> jde o
øetìzcovı vıraz. V posledním uvedeném pøípadì jde souèasnì o volání funkce v
rámci modulu <code>string</code>. Jak pozdìji uvidíme, hrají funkce v rámci
funkcionálního programování velmi dùleitou roli. (To vás asi podle jména u
napadlo.)</p>

<p>S funkcemi se ve funkcionálním programování zachází jako s objekty. To
znamená, e jsou uvnitø programu èasto pøedávány podobnım zpùsobem, jako se
pøedávají promìnné. Pøíklady jsme vidìli v našich programech s grafickım
uivatelskım rozhraním, kde jsme jméno funkce pøiøazovali atributu
<code>command</code> ovládacího prvku <code>Button</code> (tlaèítko). S
funkcí pro obsluhu události jsme zacházeli jako s objektem a odkaz na ni
jsme pøedávali prvku tlaèítka. Myšlenka pøedávání funkcí v rámci našeho
programu je pro funkcionální programování myšlenkou klíèovou.</p>

<p>Funkcionální programy bıvají rovnì silnì orientovány na práci se
seznamy.</p>

<p>Závìrem reknìme, e se funkcionální programování snaí soustøedit spíše
na <em>co</em>, ne <em>jak</em> chceme øešit. To znamená, e funkcionální
program by mìl spíše popisovat øešenı problém, ne aby se soustøedil na
vlastní mechanismus øešení. Jazykù, které o sobì tvrdí, e pracují tímto
zpùsobem, existuje nìkolik. Jedním z nejrozšíøenìjších je Haskell. Na jeho
webovém serveru (<a href="http://www.haskell.org/"
target="_blank">www.haskell.org</a>) naleznete øadu èlánkù, které popisují
jak filosofii funkcionálního programování, tak samotnı jazyk Haskell. (Podle
mého osobního mínìní jsou zmínìné cíle, jakkoliv jsou chvályhodné, zastánci
funkcionálního programování ponìkud pøeceòovány.)</p>

<p>Struktura èistì funkcionálního programu je definována vırazem, kterı
zachycuje poadovanı cíl. Kadı <em>term</em> <span class="trnote"
title="Poznámka pøekladatele">(viz následující poznámka)</span> daného
vırazu je zase vyjádøením urèité charakteristiky øešeného problému.
Vyhodnocením kadého z tìchto termù nakonec dospìjeme k øešení.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> Term neboli terminální
podvıraz je v rámci zápisu vırazu jeho dále nedìlitelná souèást. Mùeme si
zde pøedstavit volání pojmenované funkce.</p>

<p>Dobrá. To je tedy teoretickı pohled. A funguje to vùbec? Ano, nìkdy to
funguje velmi dobøe. Pro øešení urèitıch typù problémù jde o pøirozenou a
mocnou techniku. Pro øadu dalších problémù tento pøístup naneštìstí vyaduje
pomìrnì abstraktní zpùsob myšlení, kterı je velmi ovlivnìn matematickımi
principy. Vıslednı kód je pro laického programátora èasto velmi neèitelnı.
Ale vıslednı kód bıvá èasto mnohem kratší a spolehlivìjší, ne odpovídající
kód zapsanı pøíkazovım stylem. A právì poslednì zmiòované kvality pøitáhly
ke studiu funkcionálního programování mnoho programátorù, kteøí pouívali
procedurální nebo objektovì orientovanı zpùsob programování. Dokonce i kdy
se mu nebudete vìnovat s plnım nasazením, poskytuje funkcionální
programování nìkolik mocnıch nástrojù, které mohou vyuívat všichni.</p>

<h3>Jak se k tomu staví jazyk Python?</h3>

<p>Python poskytuje nìkolik funkcí, které umoòují uplatnìní funkcionálního
pøístupu k programování. Tyto funkce patøí k rysùm, které byly zavedeny
hlavnì kvùli usnadnìní práce, protoe bychom je v jazyce Python mohli docela
snadno zapsat sami. Mnohem dùleitìjší je ovšem pøímé vyjádøení
<em>zámìru</em>, dané jejich existencí. Jde zejména o zámìr poskytnout
programátorovi v jazyce Python monost práce ve stylu funkcionálního
programování &mdash; pokud si pøeje jej vyuít.</p>

<p>Podíváme se na nìkteré z tìchto funkcí a uvidíme, jak budou pracovat s
nìkterımi vzorovımi funkcemi, které definujeme jako:</p>

<pre>
spam = ['pork', 'ham', 'spices']
numbers = [1, 2, 3, 4, 5]

def eggs(item): 
    return item
</pre>

<h4>map(funkce, posloupnost)</h4>

<p>Tato funkce aplikuje pythonovskou funkci <code>funkce</code> na kadı z
èlenù posloupnosti <code>posloupnost</code>. Mìjme vıraz:</p>

<pre>
L = map(eggs, spam)
print L
</pre>

<p>Vısledem je novı seznam (v tomto pøípadì totonı se seznamem
<code>spam</code>), kterı je vrácen v <code>L</code>.</p>

<p>Stejného efektu bychom mohli dosáhnout zápisem:</p>

<pre>
for i in spam:
    L.append(i)
print L
</pre>

<p>Ale povšimnìte si skuteènosti, e pouitím funkce <code>map()</code>
odstraníme potøebu zápisu vnoøeného bloku kódu. Z urèitého pohledu tím
sniujeme sloitost programu o jednu úroveò. Uvidíme, e jde o jakési
opakující se téma funkcionálního programování. Pøi pouívání tìchto funkcí
se relativní sloitost kódu sniuje odstraòováním blokù.</p>

<h4 id="filter">filter(funkce, posloupnost)</h4>

<p>Jak ji jméno napovídá, funkce <code>filter()</code> vybírá všechny prvky
posloupnosti <code>posloupnost</code>, pro které <code>funkce</code> vrací
hodnotu <code>True</code>. Uvaujme náš seznam èísel <code>numbers</code>.
Pokud chceme vytvoøit novı seznam, kterı se skládá pouze z lichıch èísel,
pak jej mùeme vytvoøit takto:</p>

<pre>
def jeLiche(n): return (n%2 != 0) <span class="comment"># pouijeme operátor modulo</span>
L = filter(jeLiche, numbers)
print L
</pre>

<p>Øešení bychom mohli napsat i takto:</p>

<pre>
def jeLiche(n): return (n%2 != 0)
for i in numbers:
    if jeLiche(i):
        L.append(i)
print L
</pre>

<p>Opìt si povšimnìte, e konvenèní kód vyaduje k dosaení stejného
vısledku pouití dvou úrovní odsazení. A opìt, zvıšení úrovnì odsazení je
pøíznakem zvıšené sloitosti kódu.</p>


<h4>reduce(funkce, posloupnost)</h4>

<p>Vıznam funkce <code>reduce()</code> je ponìkud ménì zøejmı. Tato funkce
redukuje seznam na jedinou hodnotu tím, e jeho prvky kombinuje pomocí
dodané funkce. Mohli bychom napøíklad seèíst hodnoty prvkù seznamu a vrátit
hodnotu celkového souètu takto:</p>

<pre>
def secti(i, j): return i + j
print reduce(secti, numbers)
</pre>

<p>Stejnì jako v pøedchozích pøípadech bychom mohli pouít konvenèní zápis:</p>

<pre>
vysledek = 0
for i in range(len(numbers)): <span class="comment"># pouijeme indexování</span>
    vysledek = vysledek + numbers[i]
print vysledek
</pre>

<p>I kdy v tomto pøípadì bude vısledek stejnı, vdycky to není tak
pøímoèaré. Funkce <code>reduce()</code> <em>ve skuteènosti</em> dìlá to, e
volá dodanou funkci, pøièem jí pøedává první dva èleny posloupnosti.
Vısledek uloí místo nich. Jinımi slovy, pøesnìjší reprezentace funkce
<code>reduce()</code> vypadá takto:</p>

<pre>
def reduce(numbers):
    L = numbers[:]        <span class="comment"># vytvoø kopii originálu</span>
    while len(L) >= 2:
        i, j = L[0], L[1] <span class="comment"># pouijeme násobné pøiøazení</span>
        L = [i+j] + L[2:] <span class="comment"># souèet prvních dvou a zbytek</span>
    return L[0]
</pre>

<p>Opìt vidíme, e technika funkcionálního programování redukuje sloitost
kódu odstranìním nutnosti pouití odsazenıch blokù kódu.</p>

<h4>lambda</h4>

<p>Jedním z rysù, kterého jste si v dosud uvedenıch pøíkladech mohli
všimnout, je skuteènost, e funkce, které pøedáváme jako argument funkcí pro
podporu funkcionálního programování, bıvají velmi krátké. Èasto jde o jedinı
øádek kódu. Abychom si ušetøili námahu pøi definování velkého mnoství velmi
malıch funkcí, nabízí nám Python další pomocnou funkci pro podporu
funkcionálního programování &mdash; <code>lambda</code>.</p>

<p>Pojem <em>lambda vıraz</em> se pouívá pro referenci na <em>anonymní
funkci</em>, to znamená pro blok kódu, kterı lze provést stejnım zpùsobem,
jako kdyby se jednalo o funkci, která ovšem nemá jméno. Lambda vırazy mohou
bıt definovány uvnitø programu všude tam, kde se mùe vyskytovat legální
pythonovskı vıraz. To znamená, e je mùeme pouívat i uvnitø zmiòovanıch
pomocnıch funkcí pro podporu funkcionálního stylu programování.
</p>

<p>Zápis lambda vırazu vypadá takto:</p>

<pre>
lambda &lt;seznam parametrù&gt; : &lt;pythonovskı vıraz pouívající parametry&gt;
</pre>

<p>Take vıše zmínìnou funkci <code>secti</code> bychom mohli pøepsat
jako:</p>

<pre>
secti = lambda i, j: i + j
</pre>

<p>Pouití øádku s definicí funkce se mùeme úplnì vyhnout zápisem lambda
vırazu pøímo uvnitø volání funkce <code>reduce()</code>:</p>

<pre>
print reduce(lambda i, j: i+j, numbers)
</pre>

<p>Podobnım zpùsobem mùeme pøepsat naše pøíklady pouívající funkce
<code>map</code> a <code>filter</code>:</p>

<pre>
L = map(lambda i: i, spam)
print L

L = filter(lambda i: (i%2 != 0), numbers)
print L
</pre>

<h4 id="ListComprehension">List Comprehension</h4>

<p class="trnote"><b>Poznámka pøekladatele:</b> Pojem <em>list
comprehension</em> (èti list komprihenšn) je obtínì pøeloitelnı tak, aby
byl vısledek pøekladu krátkı a pøesnı. Je zaloen na jednom z vıznamù slova
<em>comprehension</em>, pro kterı existuje synonymum <em>comprise</em> (èti
kemprais). Vyjadøuje skuteènost <em>nìco obsahovat</em>, <em>bıt z nìèeho
poskládán, sloen</em>. Slovo <em>list</em> se zde jednoznaènì pøekládá jako
<em>seznam</em>. Pojem <em>list comprehension</em> se pouívá pro
syntaktickou konstrukci, která pøedepisuje zpùsob vygenerování seznamu z
jiné kolekce. Vulgárnì bychom jej tedy mohli pøeloit jako <em>sestavovaè
seznamù</em>. V odborné terminologii by se moná dal pouít pojem
<em>funkcionální konstruktor seznamu</em>. Ale radìji zùstaòme u
originálního pojmu. Smiøte se s tím, e <em>nauèit se programovat</em> do
znaèné míry znamená také <em>uèit se anglicky</em>.</p>

<p>Mechanismus <em>list comprehension</em> pøedstavuje techniku pro
vytváøení novıch seznamù, která pochází z jazyka Haskell a v jazyce Python
byla uvedena od verze 2.0. Má ponìkud zatemòující syntaxi, podobající se
matematickému zápisu mnoin. Vypadá takto:</p>

<pre>
[&lt;vıraz&gt; for &lt;promìnná&gt; in &lt;kolekce&gt; if &lt;podmínka&gt;]
</pre>

<p>Mùeme ji vyjádøit ekvivalentním zápisem:</p>

<pre>
L = []
for promìnná in kolekce:
    if podmínka:
        L.append(vıraz)
</pre>

<p>Stejnì jako u ostatních konstrukcí z funkcionálního programování i zde
dochází k úspoøe øádkù a dvou úrovní odsazení. Podívejme se na nìjaké
praktické pøíklady.</p>

<p>Nejdøíve si vytvoøíme seznam sudıch èísel:</p>

<pre>
>>> [n for n in range(10) if n % 2 == 0 ]
[0, 2, 4, 6, 8]
</pre>

<p>Tento zápis øíká, e chceme seznam hodnot (<code>n</code>), kde se
<code>n</code> pohybuje v rozmezí 0 a 9 a souèasnì platí, e <code>n</code>
je sudé (tedy <code>n % 2 == 0</code>).</p>

<p>Podmínka, uvedená na konci, mùe bıt samozøejmì nahrazena funkcí &mdash;
za pøedpokladu, e tato funkce vrací hodnotu, kterou mùe Python
interpretovat jako hodnotu boolovskou. Take pokud se znovu podíváme na
pøedchozí pøíklad, mùeme jej pøepsat následovnì:</p>

<pre>
>>> def jeSude(n): return ((n % 2) == 0)
>>> [ n for n in range(10) if jeSude(n) ]
[0, 2, 4, 6, 8]
</pre>

<p>Vytvoøme nyní seznam druhıch mocnit prvních pìti èísel:</p>

<pre>
>>> [n * n for n in range(5)]
[0, 1, 4, 9, 16]
</pre>

<p>Povšimnìte si, e èást <code>if</code> nemusíme povinnì pouít. Úvodní
vıraz zde má podobu <code>n * n</code> a pouíváme pro nìj všechny hodnoty
ze zadaného intervalu.</p>

<p>Na závìr pouijme místo funkce <code>range()</code> ji existujíci
kolekci:</p>

<pre>
>>> hodnoty = [1, 13, 25, 7]
>>> [x for x in hodnoty if x &lt; 10]
[1, 7]
</pre>

<p>Takovı zápis bychom mohli pouít jako náhradu za funkci
<code>filter</code>:</p>

<pre>
>>> filter(lambda x: x &lt; 10, hodnoty)
[1, 7]
</pre>

<p>To, kterı ze stylù se zdá pøirozenìjší nebo vhodnìjší, je èistì
subjektivní vìc. Pokud budujeme novou kolekci z ji existující kolekce,
mùeme pouít buï døíve uvedené funkce z oblasti funkcionálního
programování, nebo mùeme pouít <em>list comprehension</em>. Pokud vyloenì
vytváøíme úplnì novou kolekci, pak je obvykle snazší pouít <em>list
comprehension</em>.</p>

<p>Kdy to shrneme, tak aèkoliv se nám tyto konstrukce mohou zdát
pøitalivé, mùe pro dosaení poadovaného vısledku tento pøístup vést k tak
sloitım vırazùm, e je prostì jednodušší rozepsat je na tradièní
pythonovské ekvivalenty. Není to ádná ostuda. Dobrá èitelnost je vdy
lepší, ne zatemòování vìcí jen proto, abychom vypadali chytøe.</p>


<h3>Ostatní konstrukce</h3>

<p>Zmínìné funkce jsou samozøejmì uiteèné samy o sobì, ale pøesto nestaèí k
tomu, aby v jazyce Python umonily plnì funkcionální styl programování.
Funkcionálním zpùsobem musíme zmìnit, nebo alespoò nahradit, pouívání
øídicích struktur jazyka. Jednou z cest, kterou toho mùeme dosáhnout, je
vyuití vedlejšího efektu toho, jak Python vyhodnocuje boolovské vırazy.</p>

<h4>Zkrácené vyhodnocování</h4>

<p>Protoe Python pouívá <em>zkrácené vyhodnocování</em> boolovskıch
vırazù, lze nìkterıch vlastností tìchto vırazù vyuít. Pøipomeòme si
zkrácené vyhodnocování: Pokud se vyhodnocuje boolovskı vıraz, zaèíná
vyhodnocování na levé stranì vırazu a postupuje smìrem vpravo. Vyhodnocování
konèí v okamiku, kdy ji pro urèení koneèného vısledku není další
vyhodnocování nutné.</p>

<p>Pro zviditelnìní zkráceného vyhodnocení pouijeme zvláštní postup.
Nejdøíve nadefinujeme dvì funkce, které nám oznámí, e jsou volány, a poté
vrátí hodnotu, odpovídající jejich jménùm:</p>

<pre>
>>> def TRUE():
...   print 'TRUE'
...   return True  <span class="comment"># True se ve verzi 2.2 tiskne jako 1</span>
...   
>>>def FALSE():
...   print 'FALSE'
...   return False <span class="comment"># False se ve verzi 2.2 tiskne jako 0</span>
...
</pre>

<p>Nyní je pouijeme, abychom zjistili, jak se vyhodnocování boolovskıch
vırazù provádí:</p>

<pre>
>>> print TRUE() and FALSE()
TRUE
FALSE
0
>>> print TRUE() and TRUE()
TRUE
TRUE
1
>>> print FALSE() and TRUE()
FALSE
0
>>> print TRUE() or FALSE()
TRUE
1
>>> print FALSE() or TRUE()
FALSE
TRUE
1
>>> print FALSE() or FALSE()
FALSE
FALSE
0
</pre>

<div class="trnote" id="boolean">

<p><b>Poznámka pøekladatele:</b> Boolovskı typ s hodnotami
<code>False</code> a <code>True</code> byl zaveden ve verzi Python 2.2.
Jména <code>False</code> a <code>True</code> však pouze pojmenovávala
konstanty <code>0</code> a <code>1</code>, co se projevovalo pøi tisku.
Pøedchozí verze jazyka Python boolovskı typ vùbec neznaly a místo
boolovskıch hodnot se pouívaly hodnoty <code>0</code> a <code>1</code>,
jako napøíklad v jazyce C. Øada programátorù si pøesto definovala konstanty
<code>False</code> a <code>True</code>. Od verze 2.3 se boolovskı typ stal
plnohodnotnım zabudovanım typem jazyka. Místo hodnot <code>0</code> a
<code>1</code> pøíkaz <code>print</code> vytiskne <code>False</code> nebo
<code>True</code>. Od verze 2.3 tedy bude vıstup vypadat takto:</p>

<pre>
>>> print TRUE() and FALSE()
TRUE
FALSE
False
>>> print TRUE() and TRUE()
TRUE
TRUE
True
>>> print FALSE() and TRUE()
FALSE
False
>>> print TRUE() or FALSE()
TRUE
True
>>> print FALSE() or TRUE()
FALSE
TRUE
True
>>> print FALSE() or FALSE()
FALSE
FALSE
False
</pre>

</div>

<p>Povšimnìte si, e u <em>logického souèinu</em> (operátor
<code>and</code>) dochází k vyhodnocování druhé èásti vırazu <em>tehdy a jen
tehdy, kdy</em> nabıvá první èást vırazu hodnoty True (pravda). Pokud první
èást nabıvá logické hodnoty False (nepravda), pak se druhá èást
nevyhodnocuje, protoe vıraz jako celek ji <em>nemùe</em> nabıt hodnoty
True.</p>

<p>Podobnì je tomu u <em>logického souètu</em> (operátor <code>or</code>) v
pøípadì, kdy první èást nabıvá hodnoty True. V takovém pøípadì ji druhá
èást nemusí bıt vyhodnocována, protoe celek <em>musí</em> nabıvat hodnoty
True.</p>

<p>Pøi vyhodnocování boolovského vırazu se uplatòuje ještì jeden rys,
kterého mùeme vyuít. Jde o to, e pøi vyhodnocování vırazu <span
class="trnote" title="Poznámka pøekladatele">v boolovském kontextu</span>
Python nevrací jednoduše hodnotu <code>1</code> nebo <code>0</code> <span
class="trnote" title="Poznámka pøekladatele">(nebo <code>True</code> èi
<code>False</code>)</span>. Místo toho se vrací skuteèná hodnota vırazu.
Take pokud testujeme øetìzec na prázdnost (prázdnı øetìzec se chápe jako
<code>False</code>) takto:</p>

<pre>
if "Tento retezec neni prazdny": print "Neni prazdny"
else: print "Prazdny retezec"
</pre>

<p>... Python prostì vrací testovanı øetìzec.</p>

<p>Této vlastnosti mùeme vyuít k realizaci chování, které se podobá
vìtvení. Dejme tomu, e máme napøíklad následující úsek kódu:</p>

<pre>
if TRUE(): print "Je to pravda (True)"
else: print "Je to nepravda (False)"
</pre>

<p>Mùeme jej nahradit konstrukcí ve stylu funkcionálního programování:</p>

<pre>
V = (TRUE() and "Je to pravda (True)") or ("Je to nepravda (False)")
print V
</pre>

<p>Zkuste tento pøíklad provést a poté nahraïte volání <code>TRUE()</code>
voláním <code>FALSE()</code>.</p>

<p>To znamená, e jsme pøi vyuití zkráceného vyhodnocování boolovskıch
vırazù nalezli zpùsob, jak z našich programù odstranit konvenèní pøíkazy
<code>if</code>/<code>else</code>. Moná si vzpomínáte, e jsme u tématu <a
href="cztutrecur.html">rekurze</a> zjistili, e rekurzi mùeme pouít k
nahrazení konstrukce cyklu. Take kombinací tìchto dvou efektù mùeme z
našeho programu odstranit všechny konvenèní øídicí struktury a nahradit je
èistımi vırazy. Jde o velkı krok smìrem monosti øešení problémù èistì ve
stylu funkcionálního programování.</p>

<p>Abychom to vše ukázali na praktickém pøíkladì, napišme si èistì
funkcionálním stylem program pro vıpoèet faktoriálu, kterı pouívá rekurzi
místo cyklu a zkrácené vyhodnocování vırazu místo <code>if/else</code>:</p>

<pre>
def factorial(n):
   return ((n &lt;= 1) and 1) or
          (factorial(n - 1) * n)
</pre>

<p>To je opravdu celé. Moná to není tak dobøe srozumitelné jako
konvenènìjší pythonovskı kód, ale funguje to a jde o funkci zapsanou èistì
ve funkcionálním stylu &mdash; jde tedy o èistı vıraz.</p>

<h3>Závìry</h3>

<p>V tomto místì se moná pozastavujete nad tím, co je vlastnì cílem toho
všeho? A nejste sami. I kdy funkcionální programování pøitahuje øadu
teoretikù v oblasti vıpoèetních vìd (Computer Science) &mdash; a èasto
matematiky &mdash;, zdá se, e vìtšina praktickıch programátorù pouívá
techniky funkcionálního programování velmi zøídka. Navíc pouívají jakısi
hybridní pøístup, kdy tyto techniky kombinují s tradiènìjším, pøíkazovım
stylem podle toho, jak to povaují za vhodné.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> Podle mého názoru mùe mít
takové pouívání technik funkcionálního programování pøíèiny jak
subjektivní, tak objektivní. Mezi subjektivní pøíèiny bych zaøadil ten fakt,
e se jedná pøece jen o téma pro pokroèilé. Do hloubky se s ním na
vysokoškolské úrovni seznámil jen zlomek tìch, kteøí pracují jako praktiètí
programátoøi. Mezi objektivní pøíèiny bych zaøadil skuteènost, e model, na
kterém je funkcionální programování zaloeno, neodpovídá pøesnì modelu,
kterı se pouívá pro vıstavbu bìnıch poèítaèù. Von Neumannovská koncepce
poèítaèe s pamìtí pro data a pro program a s procesorem, kterı vykonává
instrukce, je vìtšinou mnohem efektivnìji vyuitelná pro programy napsané
procedurálním stylem. Jinımi slovy, dobøe napsanı procedurální program na
tìchto poèítaèích bude typicky vıkonnìjší, ne dobøe napsanı odpovídající
program zapsanı ve funkcionálním jazyce. Z matematického (teoretického)
pohledu je ale tato skuteènost nevıznamná. Proto se øada matematicky
zamìøenıch programátorù, kteøí typicky neøeší problémy denní praxe, otázkami
skuteèného vıkonu pøíliš nezabıvá. Funkcionální pøístup je z hlediska
matematického urèitì jednodušší, lépe uchopitelnı matematickımi
nástroji.</p>

<p>Pokud musíme na prvky seznamu aplikovat operace, které lze pøirozenì
vyjádøit pomocí <code>map</code>, <code>reduce</code> nebo
<code>filter</code>, pak je v kadém pøípadì pouijte. Obèas mùete dokonce
zjistit, e rekurze je v daném pøípadì vhodnìjší, ne konvenèní cyklus. V
ještì øidších pøípadech mùete najít pouití i pro zkrácené vyhodnocování
místo konvenèního <code>if</code>/<code>else</code> &mdash; zejména pøi
pouití uvnitø vırazu. Tak jako je tomu u kadého programátorského nástroje,
nenechte se unést jen urèitou filozofií. Pro øešení konkrétního zadání se
radìji snate pouít nejvhodnìjší nástroj, a u je jakéhokoliv charakteru.
Pøinejmenším si buïte vìdomi toho, e existují alternativy.</p>

<p>K otázce <em>lambda vırazù</em> zbıvá poznamenat ještì jeden závìr. I
kdy neuvaujeme ve stylu funkcionálního programování, existuje jedna
oblast, ve které lze dobøe pouít operátor <code>lambda</code>. Jde o
definice <em>funkcí pro obsluhu událostí</em> (event handler), se kterımi se
setkáváme pøi programování uivatelského rozhraní. Tyto funkce jsou èasto
velmi krátké, pøípadnì se v nich volají nìjaké rozsáhlejší funkce, kterım se
pøedává nìkolik napevno pouitıch hodnot argumentù. V tìchto pøípadech lze v
roli funkce pro obsluhu událostí pouít lambda funkci. Tím se vyhneme
nutnosti definovat mnoho malıch funkcí, které by nám zaplòovaly prostor
jmény, pouitımi jen jednou. Vzpomeòte si, e pøíkaz <code>lambda</code>
vrací objekt typu <em>funkce</em>. Právì tento objekt (funkce) je pøedán
prvku typu widget a je volán v dobì, kdy se vyskytne pøíslušná událost.
Pokud si vzpomenete, jak se v Tkinter definuje prvek typu
<code>Button</code> (tlaèítko), pak mùeme lambda pouít následovnì:</p>

<pre>
def write(s): print s
b = Button(rodic, text="Stiskni mne", 
           command = lambda : write("Stiskl jsi mne!"))
b.pack()
</pre>

<p>V tomto pøípadì bychom samozøejmì mohli dosáhnout tého efektu tím, e
bychom definovali pøednastavenou hodnotu parametru funkce
<code>write()</code>. Atributu <code>command</code> prvku typu
<code>Button</code> bychom pak jednoduše pøiøadili <code>write</code> <span
class="trnote" title="Poznámka pøekladatele">(bez pouití závorek)</span>.
Nicménì i v takto jednoduchém pøípadì nám pouití <code>lambda</code>
pøináší tu vıhodu, e jediná definice funkce <code>write()</code> mùe bıt
pouita pro více tlaèítek tak, e jí pøes <code>lambda</code> pøedáme rùzné
øetìzce. To znamená, e mùeme pøidat druhé tlaèítko takto:</p>

<pre>
b2 = Button(rodic, text="Nebo mne", 
            command = lambda : write("Stiskl jsi mne. (Tvoje druhe tlacitko.)"))
b2.pack()
</pre>

<p>Pøíkaz <code>lamda</code> mùeme pouít i u techniky, kdy pouíváme metodu
ovládacího prvku <code>bind()</code>, které jako argument pøedáváme objekt 
pro ošetøení události:</p>

<pre>
b3 = Button(rodic, text="Mne taky stiskni")
b3.bind(&lt;Button-1>, lambda ev : write("Stisknuto"))
</pre>

<p>To je vše, co se zde o funkcionálním programování dozvíte. Pokud se na nì
chcete podívat trochu hloubìji, existuje celá øada dalších informaèních
zdrojù. Nìkteré z nich jsou uvedeny níe.</p>

<h4>Ostatní zdroje</h4>

<ul>

<li>Na <a
href="http://www-106.ibm.com/developerworks/linux/library/l-prog.html"
target="_blank">webovském serveru IBM</a> naleznete vynikající èlánek Davida
Mertze o funkcionálním programování v jazyce Python. Hloubìji se zabıvá
detaily kolem øídicích struktur a uvádí podrobnìjší pøíklady tohoto
pøístupu.</li>

<li>Jiné jazyky podporují funkcionální programování ještì lépe, ne Python.
Jsou to napøíklad Lisp, Scheme, Haskel, ML a nìkteré další. Cenné informace
o funkcionálním programování naleznete zvláštì na <a
href="http://www.haskell.org/" target="_blank">webovském serveru jazyka
Haskell</a>.</li>

<li>Uiteèné FAQ a nejnovìjší události kolem funkcionálního programování
mùete nalézt v diskusní skupinì <code>comp.lang.functional</code>.</li>

<li>Na vıše zmínìnıch místech naleznete odkazy na nìkolik knih. Jedna z
klasickıch knih, která se nevìnuje jen funkcionálnímu programování, ale
dobøe popisuje jeho principy, má název <a
href="http://mitpress.mit.edu/sicp/full-text/book/book.html"
target="_blank"><em>Structure &amp; Interpretation of Computer
Programs</em></a>, jejími autory jsou Abelman, Sussman a Sussman. Tento
text se soustøedí na jazyk Scheme a na rozšíøenou verzi jazyka Lisp. Mım
osobním primárním zdrojem byl <a href="http://haskell.cs.yale.edu/soe/"
target="_blank"><em>The Haskell School of Expression</em></a> &mdash;
autorem je Paul Hudak. Zabıvá se, jak jinak, jazykem Haskell.</li>

</ul>

<p>Pokud kdokoliv nalezne dobrı odkaz, pošlete mi zprávu prostøednictvím
níe uvedeného odkazu. <span class="trnote" title="Poznámka pøekladatele"
>(Poznámka pøekladatele: Mùete pouít odkaz z anglického originálu, ale i z
èeského pøekladu. V druhém pøípadì jej autorovi pøedám.)</span></p>

<hr>
<div class="foot">
<p class="navig">[ 
<a href="cztutgui.html" title="Programování grafického uivatelského rozhraní">pøedchozí</a> |
<a href="cztutcont.html">obsah</a> | 
<a href="cztutcase.html" title="Pøípadová studie">další</a> 
]</p>
<p class="note">Pokud vás napadne, co by se dalo na pøekladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztutfctnl.html,v 1.5 2004/08/31 11:55:13 prikryl Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka' 
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20') 
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script> 

Tím budou do dopisu automaticky vloeny informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztutfctnl.html,v 1.5 2004/08/31 11:55:13 prikryl Exp $</p>
</div>
</body>
</html>


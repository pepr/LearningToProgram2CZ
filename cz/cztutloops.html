<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se nauèit programovat: Pøíkazy cyklu</title>
</head>
<body>

<h2>Pøíkazy cyklu, aneb umìní opakování se</h2>

<div class="whatcovered">
<p class="title">O èem si budeme povídat?</p>

<ul>
<li>Øekneme si, jak uívat cykly, abychom se vyhnuli opakovanému psaní
    pøíkazù.</li>
<li>Ukáeme si rùzné typy cyklù a to, kdy je máme pouít.</li>    
</ul>

</div>

<p>Na konci pøedchozí kapitoly jsme si vytiskli èást tabulky násobkù èísla
12. Ale stálo nás to mnoho psaní a pokud bychom potøebovali tabulku
rozšíøit, bylo by to velmi èasovì nároèné. Naštìstí existuje lepší zpùsob a
na nìm si ukáeme opravdovou sílu, kterou nám programovací jazyky
nabízejí.</p>

<h3>Cyklus typu FOR</h3>

<p>Nyní si ukáeme, jak v programovacím jazyku zapíšeme, e se nìco má
opakovat. Budeme dosazovat hodnotu promìnné a pøi kadém opakování ji
souèasnì budeme zvyšovat. Zápis v jazyce Python vypadá takto:</p>

<pre>
>>> for i in range(1, 13):
...     print "%d x 12 = %d" % (i, i*12)
...
</pre>

<p><b>Poznámka 1:</b> V pøíkazu <code>range(1,&nbsp;13)</code> musíme pouít 13,
protoe <code>range()</code> generuje èísla od dolní hranice vèetnì a po
horní zadanou hranici vyjma. Na první pohled se vám to mùe zdát podivné,
ale jsou pro to dobré dùvody a èasem si na to zvyknete.</p>

<p><b>Poznámka 2:</b> Operátor <code>for</code> jazyka Python je ve
skuteènosti operátorem, kterı bıvá oznaèován jako <em>foreach</em> <span
class="trnote" title="Poznámka pøekladatele">(doslova <em>pro
kadı</em>)</span>. Následující posloupnost pøíkazù je provedena pro kadı
prvek kolekce. V našem pøípadì je touto kolekcí seznam èísel generovanıch
funkcí <code>range()</code>. Mùete si to ovìøit zapsáním pøíkazu
<code>print&nbsp;range(1,&nbsp;13)</code> na pøíkazovı øádek interpretu
jazyka Python. Uvidíte, co se vytiskne.</p>

<p><b>Poznámka 3:</b> Øádek s pøíkazem <code>print</code> je
<em>odsazen</em> více, ne pøedcházející øádek s pøíkazem <code>for</code>.
To je velmi dùleité, protoe tím pøekladaèi jazyka Python dáváme najevo, e
chceme opakovat právì pøíkaz <code>print</code>. Mohou následovat i další
odsazené øádky. Python bude pro kadı prvek z kolekce opakovat všechny
odsazené øádky. Nezáleí na tom, jak velké odsazení pouijete, ale zvolenou
hodnotu odsazení musíte dodrovat.</p>

<p><b>Poznámka 4:</b> Pokud s pøekladaèem jazyka Python pracujete v
interaktivním reimu, spustí se program a po dvojím stisku klávesy Enter.
Dùvod spoèívá v tom, e po prvním stisku pøekladaè jazyka Python nepozná,
zda chcete k posloupnosti opakovanıch pøíkazù pøidat další øádek, èi
nikoliv. Pokud stisknete klávesu Enter podruhé, Python pøedpokládá, e jste
ji dokonèili vkládání pøíkazù a program spustí.</p>

<p>Take jak uvedenı program pracuje? Projdeme si jej krok po kroku.</p>

<p>Python nejdøíve pouije funkci <code>range()</code> pro vytvoøení seznamu
èísel od 1 do 12. Poté pøiøadí promìnné <code>i</code> první hodnotu
seznamu. Následuje provedení odsazeného kódu pøi pouití hodnoty
<code>i&nbsp;=&nbsp;1</code>:</p>

<pre>
    print "%d x 12 = %d" % (1, 1*12)
</pre>

<p>Potom se Python vrátí zpìt na øádek pøíkazem <code>for</code> a pøiøadí
<code>i</code> další hodnotu se seznamu, tentokrát 2. Opìt se provede
odsazenı kus kódu, tentokrát s hodnotou <code>i&nbsp;=&nbsp;2</code>:</p>
<pre>
    print "%d x 12 = %d" % (2, 2*12)
</pre>

<p>Python bude odsazenou posloupnost pøíkazù opakovat a do doby, kdy byly
promìnné <code>i</code> pøiøazeny všechny hodnoty seznamu. V ten
okamik<span class="trnote" title="Poznámka pøekladatele">, po provedení
tìla cyklu s poslední hodnotou v promìnné <code>i</code>,</span> se
provádìní pøesune na další pøíkaz, kterı <em>není</em> odsazen. V našem
pøíkladu ádné další pøíkazy nemáme, take dojde k ukonèení programu.</p>

<h4>Stejnı cyklus v jazyce VBScript</h4>

<pre>
&lt;script type="text/vbscript">
For I = 1 To 12
    MsgBox I &amp; " x 12 = " &amp; I*12
Next
&lt;/script>
</pre>

<p>V tomto zápisu je mnohem lépe na první pohled vidìt, co se dìje. Hodnota
<code>I</code> se mìní od 1 a do 12 a provádí se kód uvedenı pøed klíèovım
slovem <code>Next</code>. V našem pøípadì se vısledky jednoduše zobrazují v
dialogovém oknì. Odsazení <span class="trnote"
title="Poznámka&nbsp;pøekladatele">pøíkazu <code>MsgBox</code></span> je
nepovinné, ale díky nìmu se kód ète snadnìji.</p>

<p>Poznamenejme, e aèkoliv zápis v jazyce VBScript vypadá jasnìji,
pythonovská verze je mnohem prunìjší. Proè, to uvidíme za chvíli.</p>

<div class="trnote" title="Poznámka&nbsp;pøekladatele">

<p><b>Poznámka pøekladatele:</b> Zápis pøíkladu v jazyce Python mùeme
pøiblíit podobì pøíkladu v jazyce VBScript tím, e nevyuijeme vıhod
pouití formátovacího øetìzce:</p>

<pre>
>>> for i in range(1, 13):
...     print i, "x 12 =", i*12
...
</pre>

<p>Jednou z vıhod pouití formátovacího øetìzce je ale napøíklad monost
pøedepsat, jak se má èíslo naformátovat &mdash; tj. na kolik pozic se má
tisknout. Vyzkoušejte:</p>

<pre>
>>> for i in range(1, 13):
...     print "%2d x 12 = %3d" % (i, i*12)
...
</pre>
</div>


<h4>A toté v JavaScript</h4>

<p>Konstrukci <code>for</code>, která je bìná ve více programovacích
jazycích, pøebírá JavaScript z jazyka C. Vypadá takto:</p>

<pre>
&lt;script type="text/javascript">
for (i = 1; i &lt;= 12; i++) {
    document.write(i + " x 12 = " + i*12 + "&lt;br>");
    }
&lt;/script>
</pre>

<p><b>Poznámka:</b> Tato konstrukce má v kulatıch závorkách uvedeny tøi
èásti:</p>

<ul>
<li><em>Inicializaèní èást</em> <code>i&nbsp;=&nbsp;1</code> se provede 
    pouze jednou, pøed vším ostatním.</li>

<li><em>Èást s testem <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(podmínková èást)</span></em>
<code>i&nbsp;&lt;=&nbsp;12</code> se vykonává pøed kadou iterací<span
class="trnote" title="Poznámka&nbsp;pøekladatele">, tj. pøed kadou obrátkou
cyklu</span>.</li>

<li><em>Pøírùstková èást</em> <code>i++</code>, co je zkrácenı zápis
    pøíkazu pro "zvıšení promìnné <code>i</code> o jednièku", se vykonává po
    kadé iteraci.</li>

</ul>

<p>Povšimnìte si, e v JavaScript uzavíráme pøíkazy, které se mají opakovat
(<em>tìlo cyklu</em>) do sloenıch závorek <code>{}</code>. Aèkoliv z
technického hlediska je to vše, co musíme s tìlem cyklu udìlat, z
praktického hlediska se povauje za vhodné, aby byl kód v závorkách odsazen.
Zvyšuje se tím èitelnost <span class="trnote"
title="Poznámka&nbsp;pøekladatele">zdrojového textu</span>.</p>

<p><em>Tìlo cyklu</em> se provede pouze v pøípadì, kdy je podmínka v
<em>testové</em> èásti splnìna. Kadá z uvedenıch èástí mùe obsahovat
libovolnı kód, ale vısledkem vırazu v testové èásti musí bıt boolovská
hodnota.</p>

<div class="trnote" title="Poznámka&nbsp;pøekladatele">

<p><b>Poznámka pøekladatele:</b> Povšimnìte si pouití operátoru pro zvıšení
promìnné cyklu o jednièku <code>i++</code>. V tomto pøípadì se jedná o
takzvanı <em>postfixovı</em> operátor <code>++</code>. To znamená, e je
zapsán a <em>za</em> identifikátor promìnné. Kromì toho existuje
<em>prefixová</em> varianta tého operátoru <code>++i</code> &mdash;
operátor je uveden <em>pøed</em> identifikátorem promìnné. Oba zvıší obsah
promìnné o jednièku. V èem se tedy jejich pouití liší? V tomto pøípadì v
nièem, ale...</p>

<p>Operátory <code>++</code> a <code>--</code> pocházejí z jazyka C. V nìm
celá øada pøíkazù mùe vystupovat jako vıraz. To znamená, e vracejí nìjakou
hodnotu a mohou tedy bıt pouity napøíklad na pravé stranì pøiøazovacího
pøíkazu. Mimo jiné se to tıká i samotného pøíkazu pøiøazení a zmínìnıch
operátorù pro zvıšení a sníení o jednièku. Místo jinak bìného
zápisu...</p>

<pre>
a = 0;
b = 0;
c = 0;
d = 0;
</pre>

<p>...tedy mùeme psát:</p>

<pre>
d = c = b = a = 0;
</pre>

<p>V tomto okamiku nabıvá prefixová a postfixová varianta zmínìnıch
operátorù svùj vıznam. Vısledkem postfixové varianty <code>i++</code> je
toti pùvodní hodnota promìnné <code>i</code> (nejdøíve se získá hodnota a
<em>potom</em> se provádí zvıšení o jednièku), zatímco vısledkem prefixové
varianty <code>++i</code> je nová hodnota promìnné <code>i</code>
(<em>nejdøíve</em> se provádí zvıšení o jednièku a pak se vrací hodnota
promìnné <code>i</code>). Pokud v pøedchozím pøípadì místo nuly pouijeme
další promìnnou, její obsah upravujeme variantami operátoru
<code>++</code>, dostaneme po provedení pøíkazù na øádku v promìnnıch
hodnoty, které jsou uvedeny v komentáøích:</p>

<pre>
i = 1;
a = i++;    <span class="comment">/* a: 1, i: 2 */</span>
b = ++i;    <span class="comment">/* b: 3, i: 3 */</span>
c = ++i;    <span class="comment">/* c: 4, i: 4 */</span>
d = i++;    <span class="comment">/* d: 4, i: 5 */</span>
</pre>

<p>Pøi pouití postfixové verze operátoru <code>++</code> musí pøekladaè
jazyka udìlat jeden krok navíc &mdash; pùvodní hodnotu promìnné si musí
nìkam uloit (do registru nebo do jiné, skryté, pomocné promìnné) a teprve
potom mùe provést zvıšení pùvodní promìnné o jednièku. Pokud pøekladaè
neprování optimalizaci, pak je v pøípadì, kdy se mùeme rozhodnout pro
prefixovou nebo postfixovou variantu pøíkazu <code>++</code>, vdy
efektivnìjší pouít <em>prefixovou</em> variantu, tedy <code>++i</code>.
Vıše uvedenı pøíklad cyklu v JavaScript bychom tedy mìli psát spíše
takto:</p>

<pre>
&lt;script type="text/javascript">
for (i = 1; i &lt;= 12; ++i) {
    document.write(i + " x 12 = " + i*12 + "&lt;br>");
    }
&lt;/script>
</pre>

<p><b>Ale v jazyce Python musíme dát pozor!</b> Ten toti operátory
<code>++</code> a <code>--</code> vùbec nezná. A zatímco pro vırazy
<code>i++</code> nebo <code>i--</code> zahlásí chybu, pro vırazy
<code>++i</code> nebo <code>--i</code> nezahlácí vùbec nic. Pokud jsme z
jazykù rodiny C zvyklí pouívat <code>++i</code>, budeme se divit, proè to
nefunguje. Python jednoduše rozdìlí jeden operátor na dvojici znamének. Na
zápis se tedy dívá jako na vıraz <code>(+(+i))</code> nebo
<code>(-(-i))</code>, co z matematického hlediska znamená prázdnou
operaci.</p>

</div>

<h3>Další informace o pythonovské konstrukci <em>for</em></h3>

<p>Pythonovskı cyklus <code>for</code> prochází <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(øíkáme také, e <em>iteruje</em>)</span>
pøes všechny prvky posloupnosti. Posloupností v jazyce Python &mdash; pro
pøípad, e byste zapomìli &mdash; je øetìzec, seznam nebo n-tice. To
tedy znamená, e mùeme psát cykly <code>for</code>, které zpracovávají
libovolnı ze zmínìnıch typù. Vytisknìme si na zkoušku jednotlivá písmena
slova s vyuitím cyklu <code>for</code> aplikovaného na øetìzec:</p>

<pre>
>>> for znak in 'slovo': print znak
...
</pre>

<p>Povšimnìte si, e se kadé písmeno vytiskne na jeden øádek. Povšimnìte si
také, e pokud se tìlo cyklu skládá z jediného øádku, mùeme je napsat na
ten samı øádek, za dvojteèku. Právì dvojteèka øíká pøekladaèi jazyka Python,
e bude následovat blok kódu.</p>

<p>Iterovat mùeme i pøes n-tici:</p>

<pre>
>>> for slovo in ('jedno', 'slovo', 'a', 'zas', 'jine'): print slovo
...
</pre>

<p>Tentokrát se nám na øádcích objeví jednotlivá slova. Mohli bychom je
samozøejmì <span class="trnote" title="Poznámka&nbsp;pøekladatele">pøi
tisku</span> spojit na jeden øádek. Vyuijeme triku s uvedením èárky na
konci pøíkazu <code>print</code>. Pokud zde uvedeme èárku, nebude Python
pøecházet na další øádek a další tisk bude pokraèovat tam, kde pøedchozí
skonèil. <span class="trnote">Poznámka pøekladatele: Kadá èárka v pøíkazu
<code>print</code> vygeneruje oddìlovací mezeru. Platí to i pro èárku na
konci pøíkazu <code>print</code>. Vypsaná slova tedy budou uvedena na jednom
øádku a budou oddìlena mezerou.</span></p>

<pre>
>>> for slovo in ('jedno', 'slovo', 'a', 'zas', 'jine'): print slovo,
...
</pre>

<p>Vidíte, jak se slova poskládala na jeden øádek?</p>

<p>Pouití pøíkazu <code>for</code> nad seznamem jsme ji vidìli, protoe
<span class="trnote" title="Poznámka&nbsp;pøekladatele">døíve pouitá
funkce</span> <code>range()</code> generuje právì seznam. Ale pro úplnost si
uveïme pøíklad s pøímo zapsanım seznamem:</p>

<pre>
>>> for prvek in ['jedna', 2, 'tri']: print prvek
...
</pre>

<p>S uvedenım typem cyklu, kterı slouí k prùchodu všemi prvky, je spojen
jeden zádrhel. V prùbìhu dostáváte <em>kopii</em> toho, co se v procházené
kolekci nachází. Obsah kolekce nemùete mìnit pøímo. Pokud kolekci modifikovat
potøebujeme, musíme pouít nevzhlednı obrat, kterı do hry zatahuje indexy
prvkù v kolekci:</p>

<pre>
mujSeznam = [1, 2, 3, 4]
for index in range(len(mujSeznam)):
    mujSeznam[index] += 1
print mujSeznam
</pre>

<p>Uvedenı program zvìtšuje kadou poloku uvnitø <code>mujSeznam</code> o
jednièku. Pokud bychom nepouili trik s indexem, pak bychom pouze zvyšovali
hodnoty okopírovanıch prvkù, ale nemìnili bychom prvky originálního
seznamu.</p>

<div class="trnote">

<p><b>Poznámka pøekladatele 1:</b> Ono to ve skuteènosti není tak pøímoèaré.
Problematika modifikace seznamu souvisí s tím, e u nìkterıch objektù mùeme
mìnit hodnotu a u nìkterıch ne. Do seznamu se vdy vkládají <em>odkazy</em> na
objekty. V uvedeném pøíkladu jsou tìmito objekty celoèíselné hodnoty, které
nikdy nemùeme mìnit. Mùeme se na nì dívat jako na konstanty. Pøiètením
jednièky k èíselné konstantì dostaneme jiné èíslo &mdash; jinou konstantu,
odkaz na zcela jinı objekt. Tento novı odkaz však s pùvodním odkazem v seznamu
nemá nic spoleèného.</p>

<p>Pokud chceme dosáhnout toho, e se v seznamu objeví jiná èísla, musíme na
pøíslušné pozice v seznamu uloit odkazy na jiné konstantní objekty s
èíslem. Situace by byla jiná, pokud bychom do seznamu zaøadili objekty, které
mohou bìhem své existence mìnit svùj stav. O tom ale a pozdìji.</p>

<p>Pokud této poznámce nerozumíte nebo vás dìsí, nepropadejte panice. Je to
úplnì normální. Èasem vám to bude jasné. Chtìl jsem jen, aby nad tím
nesouhlasnì nekroutili hlavou ti, kteøí u tomu trochu víc rozumí.</p>


<p><b>Poznámka pøekladatele 2:</b> V Pythonu verze 2.3 se objevil novı rys,
kterému bychom mìli pøi øešení podobného problému dávat pøednost. Místo
nepìkného obratu pro získání seznamu indexù bychom mìli vdy pouít mnohem
elegantnìjší a také vıkonnìjší verzi, vyuívající zabudované funkce
<code>enumerate()</code>:

<pre>
mujSeznam = [1, 2, 3, 4]
for index, hodnota in enumerate(mujSeznam):
    mujSeznam[index] = hodnota + 1
print mujSeznam
</pre>

<p>Pouitím funkce <code>enumerate()</code> se zajistí, e v kadé obrátce
cyklu získáme sobì odpovídající dvojici <code>(index,&nbsp;hodnota)</code>. V
uvedeném pøíkladu její sloky pøiøazujeme do stejnojmennıch promìnnıch a
následnì pouíváme. (... <em>Nepropadejte panice!</em>)</p>

</div>

<p id="loopDelProblem">Další problém s cykly typu <code>for</code> spoèívá v
tom, e nemùeme rušit prvky kolekce, pøes kterou procházíme. Došlo by ke
zmatku. Podobá se to trochu situaci postavy ze starıch grotesek, která
odøezává vìtev, na ní sedí. K øešení podobnıch situací se lépe hodí jinı typ
cyklu, o kterém si nìco øekneme za chvíli. K porozumìní problému bezpeèného
odstraòování prvkù kolekce však budeme potøebovat znalosti z další tématické
kapitoly, která je vìnovaná <a href="cztutbranch.html">vìtvení</a>. Vysvìtlení
naznaèeného problému tedy uvedeme <a
href="cztutbranch.html#loopDelProblem">pozdìji</a>.</p>

<p>Od verze Python 2.2 byly do jazyka pøidány další triky, které èiní cyklus
<code>for</code> ještì mocnìjším. Budeme se jimi zabıvat pozdìji. Prozatím
stojí za to poznamenat, e i v jazycích VBScript a JavaScript existují
konstrukce cyklu pro prùchod všemi prvky kolekce. Detaily se zde zabıvat
nebudeme. Zápis konstrukce ve VBScript vypadá symbolicky takto:
<code>for&nbsp;each&nbsp;...&nbsp;in&nbsp;...</code>. Zápis v jazyce
JavaScript vypadá takto: <code>for&nbsp;...&nbsp;in&nbsp;...</code>. Pokud
máte zájem, mùete detailní popis nalézt na odpovídajících stránkách s
nápovìdou.</p>


<h3>Cyklus typu WHILE</h3>

<p>Cykly typu <code>FOR</code> nepøedstavují jedinı monı typ konstrukce
cyklu. A to je dobøe, protoe u cyklu <code>FOR</code> musíme vìdìt, nebo
musíme bıt schopni pøedem vypoèítat, poèet provádìnıch iterací. Take co
máme dìlat v pøípadech, kdy chceme pokraèovat v provádìní urèitého úkolu a
do doby, kdy nastane urèitá situace, ale kdy pøitom nevíme, kdy k dané
situaci dojde? Mùeme napøíklad chtít naèítat a zpracovávat data ze souboru,
ale pøedem nevíme, kolik datovıch poloek soubor obsahuje. Chtìli bychom
prostì pokraèovat ve zpracování dat a do dosaení konce souboru. Lze k tomu
sice pouít i cyklus <code>FOR</code>, ale je to obtínìjší.</p>

<p>K øešení tohoto problému se hodí jinı typ cyklu &mdash; cyklus typu
<em>WHILE</em>.</p>

<p>Zápis v jazyce Python vypadá takto:</p>

<pre>
>>> j = 1
>>> while j &lt;= 12:
...     print "%d x 12 = %d" % (j, j*12)
...     j = j + 1
</pre>

<p>Projdìme si, co jednotlivé pøíkazy dìlají.</p>

<ol>
<li>Nejdøíve inicializujeme promìnnou <code>j</code> na <code>1</code>.
    Nastavení poèáteèní hodnoty <em>øídicí promìnné</em> cyklu
    <code>while</code> pøedstavuje velmi dùleitı první krok. Jeho opomenutí
    bıvá èastou pøíèinou chyb.</li>
<li>Poté zaèneme provádìt samotnı pøíkaz <code>while</code>. V nìm se
    vyhodnocuje <em>boolovskı vıraz</em>.</li>
<li>Pokud je vısledkem vırazu hodnota <code>True</code>, dochází k
    provedení následujícího odsazeného bloku. V našem pøípadì nabıvá
    promìnná <code>j</code> hodnoty menší ne 12, take zahájíme provádìní
    bloku kódu.</li>
<li>Provede se pøíkaz <code>print</code>, kterı vytiskne první øádek naší
    tabulky.</li>
<li>Na dalším øádku se zvyšuje (inkrementuje) hodnota øídicí promìnné
    <code>j</code>. V našem pøípadì je to poslední <span class="trnote"
    title="Poznámka&nbsp;pøekladatele">stejnì</span> odsazenı øádek, co
    znamená, e blok cyklu <code>while</code> konèí.</li>
<li>Vracíme se opìt k pøíkazu <code>while</code> a provádíme kroky
    4&nbsp;a&nbsp;6, vdy s novımi hodnotami promìnné <code>j</code>.</li>
<li>Uvedená posloupnost akcí se opakuje a do doby, kdy <code>j</code>
    dosáhne hodnoty 13.</li>
<li>V tom okamiku vrátí test cyklu <code>while</code> hodnotu
    <code>False</code> a provádìní odsazeného bloku se pøeskoèí. Pokraèovat
    se bude øádkem, kterı má stejné odsazení, jako øádek s pøíkazem
    <code>while</code>.</li>
<li>V našem pøípadì ádné další øádky nenásledují, take program skonèí.</li>    
</ol>


<p>V tomto okamiku u by se vám to mohlo zdát docela jasné. Chtìl bych vás
jen upozornit na jednu vìc. Vidíte tu dvojteèku na konci øádku s pøíkazem
<code>while</code> a pøed tím na konci øádku s <code>for</code>? Právì ta
pøekladaèi jazyka Python øíká, e bude následovat úsek kódu (<em>blok</em>).
Jiné jazyky, jak uvidíme za chvíli, definují své vlastní zpùsoby, jak
naznaèit pøekladaèi skuteènost, e skupina øádkù patøí k sobì. Python
pouívá kombinaci dvojteèky a odsazení.</p>


<h4>VBScript</h4>

<p>Podívejme se, jak vypadá zápis cyklu <code>while</code> v jazyce
VBScript:</p>

<pre>
&lt;script type="text/vbscript">
DIM J
J = 1
While J &lt;= 12
    MsgBox J &amp; " x 12 = " &amp; J*12
    J = J + 1
Wend
&lt;/script>
</pre>

<p>Uvedenı pøíklad produkuje stejné vısledky. Povšimnìte si, e blok pøíkazù
cyklu je tentokrát uzavøen klíèovım slovem <code>Wend</code> (co je
samozøejmì zkratka pro <code>While&nbsp;End</code>). A na tento rozdíl
pøíklad funguje naprosto stejnì, jako jeho pythonovská verze.</p>


<h4>JavaScript</h4>

<pre>
&lt;script type="text/javascript">
j = 1;
while (j &lt;= 12) {
    document.write(j, " x 12 = ", j*12, "&lt;br>");
    j = j + 1;
    }
&lt;/script>
</pre>

<p>Jak vidíte, struktura programu je velmi podobná. Jen místo
<code>Wend</code> (VBScript) se objevily sloené závorky. Ani VBScript, ani
JavaScript (na rozdíl od Pythonu) nevyadují jakékoliv odsazování. Kód se
odsazuje jen proto, aby byl èitelnìjší.</p>

<p>V JavaScript ještì stojí za to, abychom porovnali cykly <code>for</code>
a <code>while</code>. Pøipomeòme, e cyklus <code>for</code> vypadal nìjak
takto:</p>

<pre>
for (j = 1; j &lt;= 12; j++) {....}
</pre>

<p>Má tedy naprosto stejnou strukturu, jako cyklus <code>while</code>, jen s
tím rozdílem, e je vše stlaèeno do jednoho øádku. Jasnì zde vidíme
inicializaèní èást, testovanou podmínku a èást úprav pro další obrátku
cyklu. Take v jazyce JavaScript pøedstavuje cyklus <code>for</code> pouze
kompaktnìjší formu cyklu <code>while</code>. Bez cyklu <code>for</code>
bychom se mohli zcela obejít. Staèí nám pouze cyklus <code>while</code>.
Nìkteré jazyky volí právì takovı pøístup.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> Podoba cyklu
<code>for</code> je do JavaScript pøevzata z jazyka C. To, e kopíruje
èinnost cyklu <code>while</code> je známkou jeho niší úrovnì abstrakce.
(Jazyk C je nìkdy nazıván <em>vysokoúrovòovım assemblerem</em>.) Porovnejte
si stejnı pøíklad opìt s jazykem Python, kdy naopak musíme pøevést abstrakci
jednoduchého èísla na <em>posloupnost</em> hodnot, abychom vùbec mohli
konstrukci <code>for</code> pouít. Pythonovskı cyklus <code>for</code> je z
jazykového hlediska modernìjší. A poznáte všechny jeho monosti, urèitì
nebudete ve vìtšinì pøípadù dávat pøednost cyklu <code>while</code>.
Uiteènost cyklu pracujícího s vyššími abstrakcemi je také dùvodem, proè
VBScript a JavaScript definují i døíve zmínìné formy cyklu pro iteraci pøes
všechny prvky kolekce.</p>

<h3>Prunìjší zápis cyklù</h3>

<p>Vrame se zpìt k naší tabulce násobení èíslem 12 ze zaèátku této
kapitoly. Cyklus, kterı jsme vytvoøili, se pro tisk takové tabulky velmi
dobøe hodí. Ale jak by to bylo s jinımi hodnotami? Mohli bychom cyklus
upravit tak, aby produkoval tabulku násobkù tøeba èíslem 7? Mìlo by to
vypadat nìjak takto:</p>

<pre>
>>> for j in range(1, 13):
...     print "%d x 7 = %d" % (j, j*7)
</pre>

<p>Pøi úpravì jsme museli hodnotu 12 zmìnit na hodnotu 7 a to na dvou
místech. A pokud bychom chtìli pouít jinou hodnotu, museli bychom ji<span
class="trnote" title="Poznámka pøekladatele">, opìt na dvou místech,</span>
zmìnit znovu. Nebylo by lepší, kdybychom mohli nìjakım <span class="trnote"
title="Poznámka pøekladatele">obecnìjším</span> zpùsobem zadat poadovaného
násobitele?</p>

<p>Mùeme toho dosáhnout tím, e místo konkrétní hodnoty pouijeme další
promìnnou. Hodnotu této promìnné nastavíme pøed zahájením cyklu:</p>

<pre>
>>> nasobitel = 12
>>> for j in range(1,13):
...     print "%d x %d = %d" % (j, nasobitel, j*nasobitel)
</pre>

<p>Takto získáme naši starou známou tabulku násobení èíslem 12. Ale pokud
nyní budeme chtít násobit sedmi, staèí, kdy zmìníme pouze hodnotu promìnné
<code>nasobitel</code>.</p>

<p>Povšimnìte si, e zde kombinujeme zápis posloupnosti pøíkazù a pøíkaz
cyklu. Nejdøíve jsme pouili jednoduchı pøíkaz
<code>nasobitel&nbsp;=&nbsp;12</code>, za kterım následuje <em>v poøadí
další</em> pøíkaz cyklu <code>for</code>.</p>


<h3>Vnoøené cykly</h3>

<p>Pouijme nyní pøedchozí pøíklad k dalšímu kroku. Dejme tomu, e chceme
vytisknout všechny tabulky násobkù èísel od 2 do 12 (násobení èíslem 1 je
pøíliš jednoduché ne abychom se jím zabıvali). Jediné, co musíme uèinit, je
pouít promìnnou <code>nasobitel</code> jako souèást dalšího cyklu:</p>

<pre>
>>> for nasobitel in range(2, 13):
...     for j in range(1, 13):
...         print "%d x %d = %d" % (j, nasobitel, j*nasobitel)
</pre>

<p>Všimnìte si, e odsazená èást uvnitø prvního cyklu <code>for</code> je
zápisem pøesnì tého cyklu, s kterım jsme zaèínali. Funguje to
následovnì:</p>

<ol>
<li>Nastavíme <code>nasobitel</code> na první hodnotu (2) a provedeme druhı
    cyklus.</li>
<li>Poté hodnotu promìnné <code>nasobitel</code> zmìníme na následující
    hodnotu (3) a znovu provedeme vnitøní cyklus,</li>
<li>a tak dále.</li>
</ol>

<p>Tato technika je známa jako <em>vnoøování</em> cyklù.</p>

<p>Drobnou nepøíjemností je to, e se nám všechny tabulky spojí dohromady.
Mùeme ji odstranit tím, e na konci prvního cyklu vytiskneme oddìlovací
èáru:</p>

<pre>
>>> for nasobitel in range(2, 13):
...     for j in range(1, 13):
...         print "%d x %d = %d" % (j, nasobitel, j*nasobitel)
...     print "-------------------"
</pre>

<p>Všimnìte si, e druhı pøíkaz <code>print</code> je odsazenı o stejnou
hodnotu, jako øádek s druhım cyklem <code>for</code> &mdash; jde tedy o
druhı pøíkaz v posloupnosti pøíkazù cyklu. <span class="trnote"
title="Poznámka pøekladatele">(Prvním pøíkazem je zde vnoøenı
cyklus.)</span> Zapamatujte si, e úroveò odsazení je v jazyce Python velmi
dùleitá.</p>

<p>Jen pro porovnání uveïme, jak by to vypadalo v jazyce JavaScript:</p>

<pre>
&lt;script type="text/javascript">
for (nasobitel = 2; nasobitel &lt; 13; nasobitel++) {
    for (j = 1; j &lt;= 12 ; j++) {
        document.write(j, " x ", nasobitel, " = ", j*nasobitel, "&lt;br>");
        }
    document.write("---------------&lt;br>");
    }
&lt;/script>
</pre>

<p>Pokuste se vytvoøit oddìlovaè tabulek, kterı by øíkal, jaká tabulka mu
pøedchází &mdash; popis pod tabulkou. Nápovìda: Pravdìpodobnì budete muset
pouít promìnnou <code>nasobitel</code> a pythonovskı formátovací
øetìzec.</p>

<h3>Ostatní typy cyklù</h3>

<p>Nìkteré jazyky umoòují více typù konstrukcí cyklu, ale obvykle podporují
nìco jako <code>for</code> a <code>while</code>. (Modula&nbsp;2 a Oberon
poskytují pouze cykly typu <code>while</code>, protoe cykly
<code>for</code> jimi mùeme nasimulovat &mdash; jak jsme vidìli vıše.) Jiné
typy cyklù, se kterımi se mùete setkat jsou:</p>

<dl>

<dt>do-while</dt>
<dd>Tento typ cyklu je stejnı jako <code>while</code>, ale test se provádí
a na konci<span class="trnote" title="Poznámka pøekladatele">, za tìlem
cyklu</span>. To znamená, e se cyklus provede vdy alespoò jednou.</dd>

<dt>repeat-until</dt>
<dd>Podobá se pøedchozímu typu s tím, e logika testu je opaèná.</dd>

<dt>GOTO, JUMP, LOOP, atd.</dt>
<dd>Lze se s nimi setkat hlavnì ve starších jazycích. V kódu se obvykle definuje
znaèka a skáèe se pøímo na takto oznaèené místo.</dd>
</dl>
 

<div class="remember">
<p class="title">Zapamatujte si</p>
<ul>

<li>Cyklus <code>FOR</code> opakuje sadu pøíkazù pøi pevnì daném poètu
iterací (obrátek cyklu).</li>

<li>Cyklus <code>WHILE</code> opakuje sadu pøíkazù dokud je splnìna
podmínka. Mùe se stát, e se <em>tìlo</em> cyklu neprovede nikdy. Stane se
tak v pøípadì, kdy se pokraèovací podmínka hned na zaèátku vyhodnotí jako
<em>false</em> (nepravda).</li>

<li>Existují i jiné typy cyklù, ale <code>FOR</code> a <code>WHILE</code>
jsou k dispozici témìø ve všech jazycích.</li>

<li>Cyklus <code>for</code> v jazyce Python je skuteènosti cyklem typu
<code>foreach</code> &mdash; pracuje nad polokami seznamu.</li>

<li>Cykly lze do sebe vnoøovat.</li>
</ul>
</div>

<div class="foot">
<p class="navig">[ 
<a href="cztutseq2.html" title="Další posloupnosti">pøedchozí</a> |
<a href="cztutcont.html">obsah</a> | 
<a href="cztutstyle.html" title="Styl zápisu kódu">další</a> 
]</p>
<p class="note">Pokud vás napadne, co by se dalo na pøekladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztutloops.html,v 1.11 2005/10/20 20:52:28 petr Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka' 
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20') 
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script> 

Tím budou do dopisu automaticky vloeny informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztutloops.html,v 1.11 2005/10/20 20:52:28 petr Exp $</p>
</div>
</body>
</html>


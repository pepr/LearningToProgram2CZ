<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se nauèit programovat: Rekurze</title>
</head>
<body>

<p class="ir">Níe uvedenı text pochází z prvního vydání. Nad tímto textem 
se nachází aktuální stav po revizi smìøující k druhému vydání.</p>

<h2>Rekurze</h2>

<div class="whatcovered">
<p>Poznámka: Téma <em>rekurze</em> je urèeno pro pomìrnì pokroèilé
programátory. Pøi tvorbì vìtšiny aplikací o rekurzi nemusíte vìdìt vùbec
nic. Ale obèas je uiteènost pouití rekurze pøímo neocenitelná, proto si
zde o ní nìco øekneme. Pokud vám to v prvním okamiku nebude dávat smysl,
nepropadejte panice.</p>
</div>

<h3>Co to vlastnì je?</h3>

<p>V pøedchozích èástech uèebnice jsme se zmínili o tom, e pouití cyklu
patøí k jednomu ze základních kamenù programování. Navzdory tomuto tvrzení
je ve skuteènosti moné vytváøet programy, které nepouívají pøímo
vyjádøenou konstrukci cyklu. V nìkterıch jazycích, jako je napøíklad Lisp,
pøímá konstrukce cyklu jako <code>FOR</code>, <code>WHILE</code>, a dalších
ve skuteènosti vùbec neexistuje. Místo toho se zde pouívá technika známá
jako <em>rekurze</em>. Pro øešení nìkterıch typù problémù se rekurze ukazuje
bıt velmi mocnou technikou. Proto se na ni teï podíváme.</p>

<p>Rekurzí jednoduše rozumíme pouití nìjaké funkce jako èásti definice té
samé funkce. Take o definici akronymu GNU (co je zdroj velkého mnoství
softwarovıch produktù dostupnıch zdarma) øíkáme, e je rekurzivní, protoe
zkratka GNU znamená <em>GNU's Not Unix</em> <span class="trnote"
title="Poznámka pøekladatele">(èili <em>GNU Není Unix</em>)</span>. Zkratka
GNU je tedy souèástí definice vıznamu zkratky samé.</p>

<p>Klíèem k fungování rekurze je to, e <b>musí existovat podmínka
ukonèení</b> taková, e v urèité situaci funkce pokraèuje vìtví, která
pøedstavuje nerekurzivní øešení. (Definice akronymu GNU tímto testem
pouitelnosti neprojde, protoe vede k nekoneènému cyklu.)</p>

<div class="trnote">
<p><b>Poznámka pøekladatele:</b> Moná jste se nìkdy setkali s ertovnou
podobou vysvìtlení nekoneèného cyklu, jak by mohl bıt uveden ve vıkladovém
slovníku:</p>

<dl>
<dt>Cyklus nekoneènı</dt>
<dd><p>Viz <em>Nekoneènı cyklus</em>.</p></dd>
<dt>Nekoneènı cyklus</dt>
<dd><p>Viz <em>Cyklus nekoneènı</em>.</p></dd>
</dl>

<p>Taková definice nekoneèného cyklu je vlastnì generována rekurzí. Pokud
hesla <em>Cyklus nekoneènı</em> a <em>Nekoneènı cyklus</em> budeme povaovat
za funkce a jejich èást <em>Viz xyz</em> za volání jiné funkce, pak jsme
vytvoøili nekoneènı cyklus za pouití takzvané <em>nepøímé rekurze</em>. Ta
se od vıše zmínìné rekurze liší pouze tím, e k volání funkce samé nedochází
pøímo, ale zprostøedkovanì, jinou funkcí. Aby nepøímá rekurze byla k nìèemu
dobrá, musí bıt rovnì splnìn pøedpoklad, e <em>v urèitém bodì musí nastat
nerekurzivní doøešení problému</em>.</p>

</div>

<p>Podívejme se na jednoduchı pøíklad. Matematická funkce <em>faktoriál</em>
je definována jako souèin všech èísel a po zadanı argument vèetnì.
Faktoriál èísla 1 (jedna) je definován jako 1. Pokud se nad tím zamyslíme,
pak zjistíme, e toté mùeme vyjádøit jinım zpùsobem: faktoriál èísla N je
roven N krát faktoriál èísla (N-1). Take mùeme psát:</p>

<pre>
1! = 1
2! = 1 x 2 = 2
3! = 1 x 2 x 3 = 2! x 3 = 6
N! = 1 x 2 x 3 x .... (N-2) x (N-1) x N = (N-1)! x N
</pre>

<p>V jazyce Python to mùeme zapsat takto:</p>

<pre>
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)
</pre>

<p>Protoe v kadém kroku sniujeme hodnotu èísla N a testujeme shodu na
hodnotu 1, musí funkce skonèit. V uvedené definici funkce je ovšem malá chyba.
Pokud se ji pokusíte zavolat pro èíslo menší ne jedna, uvede se do
nekoneèného cyklu. Opravit to mùeme tím, e místo testu na rovnost pouijeme
operátor <code>&lt;=</code>. Tento pøíklad ukazuje, jak snadno mùeme pøi
zápisu podmínky ukonèení udìlat chybu. U rekurzivních funkcí jde pravdìpodobnì
o jednu z nejbìnìjších chyb. Abyste zajistili jejich správnou funkènost,
ujistìte se, e testujete všechny hodnoty v okolí bodu ukonèení <span
class="trnote" title="Poznámka pøekladatele">rekurze</span>.</p>

<p>Podívejme se, co se dìje, kdy funkci spustíme. Povšimnìte si, e pøíkaz
<code>return</code> vrací <code>n * (<em>vısledek následujícího volání funkce
factorial</em>)</code>, take dostáváme:</p>

<pre>
factorial(4) = 4 * factorial(3)
factorial(3) = 3 * factorial(2)
factorial(2) = 2 * factorial(1)
factorial(1) = 1
</pre>

<p>V tomto okamiku se Python vrací do vyšších úrovní a dosazuje hodnoty:</p>

<pre>
factorial(2) = 2 * 1 = 2
factorial(3) = 3 * 2 = 6
factorial(4) = 4 * 6 = 24
</pre>

<p>Zápis funkce pro vıpoèet faktoriálu bez pouití rekurze ve skuteènosti
není tak obtínı. Vyzkoušejte si jej v rámci cvièení. V podstatì potøebujete
provést cyklus pøes všechna èísla a do <code>N</code> a bìhem této èinnosti
provádíte násobení. Ale pozdìji uvidíme, e existují funkce, jejich zápis
je bez pouití rekurze mnohem obtínìjší <span class="trnote"
title="Poznámka pøekladatele">(ve srovnání s rekurzivním zápisem)</span>.


<h3>Rekurzivní prùchod seznamem</h3>

<p>Jinou oblastí, kdy je pouití rekurze velmi uiteèné, je zpracování
seznamù. Rekurzi mùeme snadno pouít za pøedpokladu, e jsme schopni
testovat prázdnost seznamu a generovat zeznam bez první poloky. <span
class="trnote" title="Poznámka pøekladatele">Pro získání èásti
seznamu</span> mùeme v jazyce Python pouít techniku, které se øíká
<em>slicing</em> ([slajsing] = odkrajování, odøezávání). Plné vysvìtlení
naleznete v pøíruèce jazyka Python. Pro naše úèely postaèí, kdy budeme
vìdìt, e se pøi poutí indexu ve tvaru <code>[1:]</code> vrací <span
class="trnote" title="Poznámka pøekladatele">kopie</span> všech prvkù
seznamu prvku na idexu 1 a do konce seznamu. Take pokud chceme získat
první prvek seznamu <code>L</code>, napíšeme:</p>

<pre>
prvni = L[0] <span class="comment"># pouijeme prostì normální indexování</span>
</pre>

<p>A pokud chceme získat <span class="trnote" title="Poznámka
pøekladatele">kopii</span> zbytku seznamu, napíšeme:</p>

<pre>
zbytek = L[1:] <span class="comment"># vyøízneme prvky na indexech 1, 2, 3, ...</span>
</pre>

<p>Abyste se ujistili, e to funguje, napište na vyzıvací øádek Pythonu
následující:</p>

<pre>
>>> L = [1, 2, 3, 4, 5]
>>> print L[0]
1
>>> print L[1:]
[2, 3, 4, 5]
</pre> 

<p class="trnote"><b>Poznámka pøekladatele:</b> Obecnì zápis
<code>Seznam[od:do]</code> vyøízne z pùvodního seznamu prvky poèínaje indexem
<code>od</code> a po prvek s indexem o jedno menším, ne <code>do</code>.
Pokud èást <code>od</code> nebo <code>do</code> není uvedena, pak se do
neuvedené èásti vnitønì doplní index, kterı zahrne prvky od zaèátku nebo do
konce seznamu. Pøí získávání èásti seznamu dochází ke kopii prvkù. Zápis
<code>Seznam[:]</code> se pouívá jako obrat pro získání kopie seznamu.
Prostım pøiøazením <code>s2&nbsp;=&nbsp;Seznam</code> získáme pouze odkaz na
originální seznam. Pokud zmìníme <code>s2</code>, zmìní se i
<code>Seznam</code>. Poadavek na získání kopie seznamu proto nepatøí k nìjak
vıjimeènım.</p>

<p>Nyní se vrame k pouití rekurze pro tisk seznamù. Uvaujme jednoduchı
pøípad, kdy chceme kadı prvek seznamu øetìzcù vytisknout voláním funkce
<code>tiskSeznamu</code>:</p>

<pre>
def tiskSeznamu(Seznam):
    if Seznam:
        print Seznam[0]<span class="comment">
        # Podrobnosti k [1:] &mdash; viz pøíruèka jazyka Python, 'slicing'.</span>
        tiskSeznamu(Seznam[1:])
</pre>

<p>Pokud je seznam neprázdnı &mdash; dotaz na neprázdnı seznam v boolovském
kontextu vrací hodnotu <code>True</code> &mdash;, pak vytiskneme obsah
prvního prvku seznamu a zpracujeme <span class="trnote" 
title="Poznámka pøekladatele">stejnım zpùsobem</span> zbytek seznamu takto
(nepythonovskı pseudo kód):</p>

<pre>
Jsme uvnitø tiskSeznamu([1,2,3])
   tiskne se [1,2,3][0] => 1
   spouští se tiskSeznamu([1,2,3][1:]) => tiskSeznamu([2,3])
   => nyní jsme uvnitø tiskSeznamu([2,3])
      tiskne se [2,3][0] => 2
      spouští se tiskSeznamu([2,3][1:]) => tiskSeznamu([3])
      => nyní jsme uvnitø tiskSeznamu([3])
         tiskne se [3][0] => 3
         spouští se tiskSeznamu([3][1:]) => tiskSeznamu([])
         => nyní jsme uvnitø tiskSeznamu([])
            Podmínka v "if Seznam" není pro prázdnı seznam splnìna, 
            proto se vracíme z funkce <span class="trnote" title="Poznámka pøekladatele">(nejhlubší bod rekurze)</span>.
      => jsme zpìt v tiskSeznamu([3])
         narazili jsme na konec funkce a vracíme se
   => jsme zpìt v tiskSeznamu([2,3])
      narazili jsme na konec funkce a vracíme se
=> jsme zpìt v tiskSeznamu([1,2,3]), tj. na nejvyšší úrovni
   narazili jsme na konec funkce a vracíme se
</pre>

<p class="note"><b>Poznámka:</b> Vıše uvedené vysvìtlení je s úpravami
pøevzato z textu, kterı uvedl Zak Arntson v mailing listu "Python Tutor" v
èervenci 2003.</p>

<p>V pøípadì jednoduchého seznamu lze toté jednoduše øešit pøi pouití
jednoduchého cyklu <code>for</code>. Ale uvaujme, jak by to vypadalo v
pøípadì, kdyby byl <code>Seznam</code> sloitìjší a mohl uvnitø obsahovat
další seznamy. <span class="trnote" title="Poznámka pøekladatele">(Prvkem by
mohl bıt buï øetìzec nebo další seznam.)</span> Pokud jsme schopni testovat,
zda je prvek seznamu dalším seznamem, pak zavoláme funkci
<code>tiskSeznamu()</code> rekurzivnì. Pokud prvek není seznamem, pak jej
jednoduše vytiskneme. Vyzkoušejme si to:</p>

<pre>
def tiskSeznamu(Seznam):
    <span class="comment"># Jestlie je seznam prázdnı, nedìlej nic.</span>
    if not Seznam: return
    <span class="comment"># Pokud je první prvek seznamem, dosadíme jej do tiskSeznamu().</span>
    if type(Seznam[0]) == type([]):
        tiskSeznamu(Seznam[0])
    else:<span class="comment"> # První prvek není seznam. Jednoduše jej vytiskneme.</span> 
        print Seznam[0]
    <span class="comment"># Nyní zpracujeme zbytek Seznamu.</span> 
    tiskSeznamu(Seznam[1:])
</pre>

<p>Pokud se toté pokusíte zapsat pomocí cyklu, zjistíte, e je to velmi
obtíné. Rekurze umoní zapsat <span class="trnote" title="Poznámka pøekladatele"
>podobnì</span> sloité úlohy srovnatelnì jednoduše. <span class="trnote"
title="Poznámka pøekladatele">(Jinımi slovy, rekurzivní øešení jednoduchého
pøípadu a uvedeného sloitìjšího pøípadu je pøiblinì stejnì
obtíné.)</span></p>

<p>Je tu ovšem jeden zádrhel (jako vdycky). Rekurzivní zpracování velkıch
datovıch struktur typicky vede k velké spotøebì pamìového prostoru. Take
pokud máte k dispozici málo pamìti nebo zpracováváte velmi velké datové
struktury, mùe bıt sloitìjší konvenèní øešení bezpeènìjší.</p>

<p>Tak. A nyní udìlejme další skok do neznáma &mdash; seznámíme se
s&nbsp;<em>objektovì orientovanım programováním</em>.</p>

<hr>

<div class="foot">
<p class="navig">[ 
<a href="cztuterrors.html" title="Práce s chybami">pøedchozí</a> |
<a href="cztutcont.html">obsah</a> | 
<a href="cztutclass.html" title="Objektovì orientované programování">další</a> 
]</p>
<p class="note">Pokud vás napadne, co by se dalo na pøekladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztutrecur.html,v 1.6 2004/08/31 11:55:14 prikryl Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka' 
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20') 
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script> 

Tím budou do dopisu automaticky vloeny informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztutrecur.html,v 1.6 2004/08/31 11:55:14 prikryl Exp $</p>
</div>
</body>
</html>


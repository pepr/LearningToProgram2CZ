<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <link rel="stylesheet" type="text/css" href="tutor.css" >
  <link rel="stylesheet" type="text/css" href="colors.css" >
  <title>Jak se nauèit programovat: Zpracování textu</title>
</head>
<body>

<h2>Zpracování textu</h2>

<div class="whatcovered">
<p class="title">O èem si budeme povídat?</p>
<ul>
<li>Jak rozdìlit øádky textu na skupiny znakù.</li>
<li>Jak vyhledávat textové øetìzce uvnitø jinıch øetìzcù.</li>
<li>Jak nahradit text uvnitø øetìzce.</li>
<li>Jak mìnit velikost písmen (malá za velká a naopak).</li>
</ul>
</div>

<p>Zpracování textu patøí mezi nejbìnìjší programátorské èinnosti. Díky
tomu nám vìtšina programovacích jazykù nabízí øadu specifickıch nástrojù,
které mají zpracování textu usnadnit. V této èásti se podíváme na nìkteré
z&nbsp;nich a na to, jak je mùeme vyuít pøi realizaci typickıch
programátorskıch úloh.</p>

<p>Mezi nejbìnìjší akce pøi práci s textem patøí:</p>

<ul>
<li>Rozdìlování øádkù textu na skupiny znakù,</li>
<li>hledání podøetìzcù v øetìzcích,</li>
<li>náhrada textu uvnitø øetìzce,</li>
<li>zmìna velikosti písmen (malá na velká a naopak).</li>
</ul>

<p>Podíváme se, jak se uvedené úkoly øeší v jazyce Python. Poté se struènì
seznámíme s tím, jaké monosti zpracování textu poskytují jazyky VBScript a
JavaScript.</p>

<p>Od verze 2.3 Python pøi zpracování textu postupuje trošku nejednoznaènì.
Pøíèina spoèívá v tom, e starší verze jazyka Python provádìly veškeré
manipulace prostøednictvím modulu, kterı byl napìchovanı funkcemi a
uiteènımi konstantami. Python verze 2.0 zavedl pro typ øetìzec metody,
které nahrazují funkce ve zmínìném modulu, ale konstanty byly dostupné stále
jen prostøednictvím modulu. Tato situace trvala a do verze 2.3. Další vıvoj
smìøuje k tomu, aby potøeba pouívat starı modul <code>string</code> byla
zcela odstranìna. V tomto tématu se zamìøíme vıluènì na novı, objektovì
orientovanı pøístup k manipulaci s øetìzci. Pokud si chcete vyzkoušet práci
s pùvodním modulem, hledejte potøebné informace v jeho dokumentaci.</p>


<h3>Rozdìlování øetìzcù</h3>

<p>Nejdøíve se budeme zabıvat tím, jak mùeme øetìzec rozdìlit na èásti, z
kterıch se skládá. Pøi zpracování textovıch souborù se s takovım poadavkem
setkáváme èasto. Obsah souboru se obvykle snaíme èíst po øádcích, ale
poadovaná data mohou bıt uloena v urèitıch èástech øádkù. Jako pøíklad si
mùeme uvést náš záznamník s adresami. Místo tisku celé adresy bychom mohli
chtít pøistupovat napøíklad jen k èástem adresy.</p>

<p>V Pythonu pro tento úèel pouijeme metodu <code>split()</code> <span
class="trnote" title="Poznámka pøekladatele">(rozdìlit na èásti,
rozštípnout)</span> následujícím zpùsobem:</p>

<pre>
>>> retezec = 'Toto je (kratky) retezec.'
>>> print retezec.split()
['Toto', 'je', '(kratky)', 'retezec.']
</pre>

<p>Povšimnìte si, e se nám vrací seznam, kterı obsahuje slova z øetìzcové
promìnné <code>retezec</code>. Všechny mezery byly odstranìny.
Pøeddefinovanım oddìlovaèem metody <code>split()</code> jsou toti <em>bílé
znaky</em> (tj. tabulátory, znaky pøechodu na novı øádek a mezery). Zkusme
to znovu, ale tentokrát si jako oddìlovaè vybereme otvírací závorku:</p>

<pre>
>>> print retezec.split('(')
['Toto je ', 'kratky) retezec.']
</pre>

<p>Vidíte ten rozdíl? Seznam obsahuje tentokrát jen dva prvky a otvírací
závorka na zaèátku <code>'kratky)'</code> byla odstranìna. Dùleitou
vlastností metody <code>split()</code> je to, e odstraòuje oddìlovací
znaky. Vìtšinou takové chování poadujeme, ale obèas bychom si pøáli, aby
tomu tak nebylo.</p>

<p>K dispozici máme i metodu <code>join()</code>, která pøebírá seznam (nebo
také jinou podobu posloupnosti) øetìzcù a spojuje je dohromady. Jednou z
matoucích vlastností metody <code>join()</code> je to, e øetìzec, jeho
metodu <code>join()</code> voláme, je pouit v roli spojovacích znakù.
Následující pøíklad ukazuje, co mám na mysli:</p>

<pre>
>>> lst = ['Tohle', 'je', 'seznam', 'slov.']
>>> print '-+-'.join(lst)
Tohle-+-je-+-seznam-+-slov.
>>> print ' '.join(lst)
Tohle je seznam slov.
</pre>

<p>Kdy o tom zaènete pøemıšlet, dává to smysl. Ale na první pohled to
vypadá divnì.</p>

<div class="trnote">
<p><b>Poznámka pøekladatele:</b> Na první pohled by se zdálo pøirozenìjší,
kdyby metoda <code>join()</code> byla metodou typu <em>seznam</em> a jako
parametr by pøebírala øetìzec, kterı se pouije pro spojení prvkù seznamu:</p>

<pre>
>>> lst.join('-+-')    <span class="comment"># Tohle NEFUNGUJE!</span>
</pre>

<p>Ale argumentem metody <code>join()</code> nemusí bıt pøímo
<em>seznam</em> øetìzcù. Mùe to bıt libovolnı iterovatelnı objekt, tj.
objekt kterı podporuje prùchod jednotlivımi øetìzcovımi polokami. (Typicky
to bıvá kontejner, ale mùe to bıt napøíklad i generátor s omezenım poètem
generovanıch øetìzcovıch hodnot.) Pokud si to uvìdomíme, nevypadá u
rozhodnutí o pøíslušnosti metody <code>join()</code> k øetìzcovému typu tak
nezvykle. V opaèném pøípadì by metoda <code>join()</code> musela bıt
implementována pro všechny typy kontejnerù, jejich obsah bychom chtìli
spojovat. Následující pøíklad uvádí pøevod seznamu na n-tici a na mnoinu a
spojení jejich obsahu mezerou:</p>

<pre>
>>> lst = ['Tohle', 'je', 'seznam', 'slov.']
>>> t = tuple(lst)
>>> se = set(lst)
>>> print ' '.join(t)
Tohle je seznam slov.
>>> print ' '.join(se)
je seznam Tohle slov.
</pre>

<p>Povšimnìte si, e v pøípadì mnoiny není dodreno poøadí, ve kterém se
prvky mnoiny vkládaly (z mnoinového hlediska není poøadí poloek
dùleité). Z prvkù mnoiny ovšem mùeme nìjakou funkcí vytvoøit uspoøádanou
posloupnost:</p>

<pre>
>>> print ' '.join(sorted(se))
Tohle je seznam slov.
</pre>

<p>Zdánlivì správné poøadí slov je dáno pouze náhodou, protoe uvedená slova
ve vìtì náhodou odpovídají svému lexikografickému poøadí. Dokame si to na
jiném pøíkladì:</p>

<pre>
>>> lst = ['tohle', 'je', 'neusporadany', 'salat', 'z', 'ceskych', 
...        'slov', 'bez', 'diakritickych', 'znamenek']
>>> se = set(lst)
>>> print ' '.join(se)
ceskych slov neusporadany diakritickych znamenek bez salat je z tohle
>>> print ' '.join(sorted(se))
bez ceskych diakritickych je neusporadany salat slov tohle z znamenek
</pre>

</div>


<h4 id="word_count">Poèítání slov</h4>
                                                                       
<p>Nyní se znovu podívejme na program pro poèítání slov, o kterém jsem se
zmínil v pøedchozí podkapitole <a href="cztutfunc.html#wc"
>o&nbsp;funkcích</a>. Pøipomeòme si, e <em>pseudo kód</em> vypadal
takto:</p>

<pre>
def pocetSlov(s):
    seznam = split(s)  <span class="comment"># seznam, kde prvkem je vdy slovo</span>
    return len(seznam) <span class="comment"># vrátíme poèet prvkù seznamu</span>

for radek in soubor:
    celkem = celkem + pocetSlov(radek) <span class="comment"># seèti poèty za kadı øádek</span>
print "Soubor má %d slov." % celkem
</pre>

<p>Nyní ji víme, jak lze naèítat øádky souboru. Podívejme se blíe na tìlo
funkce <code>pocetSlov()</code>. Nejdøíve chceme z daného øádku vytvoøit
seznam slov. Staèí, kdy na øádek aplikujeme standardní metodu
<code>split()</code>. Nahlédnutím do dokumentace zjistíme, e zabudovaná
funkce <code>len()</code> vrací pro seznam poèet v nìm umístìnıch prvkù. V
našem pøípadì to bude poèet slov v øetìzci, co je pøesnì to, co
potøebujeme.</p>

<p>Take koneèná podoba zdrojového kódu vypadá takto:</p>

<pre>
<span class="comment"># -*- coding: cp1250 -*-</span>
import string
def pocetSlov(s):
    seznam = s.split() <span class="comment"># split() je metodou øetìzcového objektu <code>s</code></span>
    return len(seznam) <span class="comment"># vrátíme poèet prvkù seznamu</span>

vstup = open('menu.txt', 'r')
celkem = 0 <span class="comment"># vytvoøíme promìnnou a nastavíme jí poèáteèní hodnotu nula</span>

for radek in vstup:
    celkem = celkem + pocetSlov(radek) <span class="comment"># seèti poèty za kadı øádek</span>
print u'Soubor má %d slov.' % celkem

vstup.close()
</pre>

<p>Tento program není tak docela správnı, protoe napøíklad zapoèítá <span
class="trnote" title="Poznámka pøekladatele">samostatnì stojící</span> znak
'&amp;' (ampersand) jako slovo (aèkoliv si vlastnì mùete myslet, e je to
správné). Program navíc zpracovává jedinı soubor (<code>menu.txt</code>).
Ale není pøíliš obtíné upravit jej tak, aby jméno souboru èetl z
pøíkazového øádku (<code>argv[1]</code>) nebo prostøednictvím
<code>raw_input()</code>, jak jsme si ukázali v podkapitole <a
href="cztutinput.html">Konverzace s uivatelem</a>. Øešení ponechávám za
domácí úkol.</p>


<h3>Vyhledávání textu</h3>

<p>Další bìnou operací, na kterou se teï podíváme, je vyhledávání
podøetìzce v delším øetìzci. V Pythonu pro ni opìt nalezneme podporu v
podobì metody zabudovaného øetìzcového typu &mdash; tentokrát se jmenuje
<code>find()</code>. Její základní zpùsob pouití je velmi jednoduchı.
Pøedáte jí vyhledávanı podøetìzec, a pokud jej Python v hlavním øetìzci
najde, vrátí index prvního znaku, na kterém podøetìzec zaèíná. Pokud
podøetìzec nalezen není, vrací se hodnota <code>-1</code>:</p>


<pre>
>>> retezec = 'Toto je dlouhy retezec, ve kterem se nachazi podretezec.'
>>> print retezec.find('dlouhy')
8
>>> print retezec.find('moc')
-1
>>> print retezec.find('retezec')
15
</pre>

<p>První dva pøíklady pouití jsou pøímoèaré. První z nich vrací index
zaèátku podøetìzce <code>'dlouhy'</code>. Druhı pøíklad pouití vrací
hodnotu <code>-1</code>, protoe podøetìzec <code>'moc'</code> se v øetìzci
nevyskytuje. U tøetího pøíkladu pouití narazíme na jeden detail &mdash;
vyhledal se <em>první</em> vıskyt zadaného podøetìzce. Ale co vlastnì mùeme
dìlat v pøípadech, kdy se hledanı vzorek vyskytuje v pùvodním øetìzci více
ne jednou?</p>

<p>Jedna z moností spoèívá v pouití indexu prvního vıskytu a rozseknutí
pùvodního øetìzce na dvì èásti. Poté mùeme hledat znovu. Takto pokraèujeme
a do doby, kdy se nám vrátí vısledek <code>-1</code>:</p>


<pre>
<span class="comment"># -*- coding: cp1250 -*-</span>
retezec = u"'Haf, òaf', øíká pes. Kolik 'af' je v øetìzci?"
s = retezec            <span class="comment"># Na zaèátku se odkazujeme na stejnı øetìzec.</span>
pocet = 0
index = s.find('af')
while index != -1:
    pocet += 1
    s = s[index + 1:]  <span class="comment"># Budeme pracovat s druhou èástí øetìzce (slicing).</span>
    index = s.find('af')
print u"V øetìzci \"%s\" jsme našli %d vıskyty vzorku 'af'." % (retezec, pocet)   
</pre>

<p>V pøíkladu jsme pouze vıskyty vzorku pouze poèítali. Stejnì dobøe bychom
ale mohli nalezené indexy sbírat do seznamu, kterı bychom vyuili pøi dalším
zpracování.</p>

<p>Pokud pouijeme nepovinné parametry metody <code>find()</code>, mùeme
proces urychlit. Tìmito nepovinnımi parametry je urèení poèáteèní a koncové
pozice v pùvodním øetìzci:</p>

<pre>
<span class="comment"># -*- coding: cp1250 -*-</span>
retezec = u"'Haf, òaf', øíká pes. Kolik 'af' je v øetìzci?"
pocet = 0
index = retezec.find('af')
while index != -1:
    pocet += 1
    start = index + 1  <span class="comment"># Pøipravíme novı zaèátek.</span>
    index = retezec.find('af', start)
print u"V øetìzci \"%s\" jsme našli %d vıskyty vzorku 'af'." % (retezec, pocet)   
</pre>

<p>U tohoto øešení nemusíme pokadé vytváøet novı øetìzec, co mùe bıt v
pøípadì dlouhıch øetìzcù èasovì nároèné. Pokud chceme vyhledávat vıskyt
podøetìzce jen v nìkolika prvních znacích (a další pøípadné vıskyty nás
nezajímají), mùeme urèit poèáteèní a koncové pozice <span class="trnote"
title="Poznámka&nbsp;pøekladatele">prohledávané èásti øetìzce</span>
takto:</p>

<pre>
<span class="comment"># -*- coding: cp1250 -*-</span>
retezec = u"'Haf, òaf', øíká pes. Kolik 'af' je v øetìzci?"
print retezec.find('af', 0, 20)
</pre>

<p>V souvislosti s vyhledáváním Python nabízí navíc nìkolik pìknıch, speciálních
metod, které se nám hodí v nejèastìjších pøípadech &mdash; jde zejména o
metody <code>startswith()</code> a <code>endswith()</code> <span
class="trnote" title="Poznámka&nbsp;pøekladatele">(dalo by se pøeloit jako
<em>zaèíná tímhle</em> a <em>konèí tímhle</em>)</span>. Samotná jména
napovídají, so metody asi dìlají. Vracejí hodnoty <code>True</code> nebo
<code>False</code> v závislosti na to, zda pùvodní øetìzec <span
class="trnote" title="Poznámka&nbsp;pøekladatele">(tj. objekt jeho metodu
voláme)</span> zaèíná nebo konèí vyhledávanım podøetìzcem. Pøíklad:</p>

<pre>
>>> print 'Python jede!'.startswith('Perl')
False
>>> print 'Python jede!'.startswith('Python')
True
>>> print 'Python jede!'.endswith('je nanic!')
False
>>> print 'Python jede!'.endswith('de!')
True
</pre>
                         
<p>Povšimnìte si, e vısledek je boolovského typu. Povšimnìte si také, e
vyhledávací øetìzec nemusí mít podobu celého slova, staèí prostì podøetìzec.
Pokud chcete testovat na vıskyt podøetìzce jen v uèité èásti øetìzce, mùeme
upøesnit poèáteèní a koncovou pozici èásti, která se má prohledávat &mdash;
stejnì jako u metody <code>find()</code>. V praxi se ale tenhle rys moc
nepouívá.</p>

<p>Na závìr si uveïme, e pro prosté otestování, zda se podøetìzec nachází
kdekoliv v øetìzci mùeme pouít pythonovskı operátor <code>in</code>
takto:</p>

<pre>
>>> if 'foo' in 'foobar': print 'True'
True
>>> if 'baz' in 'foobar': print 'True'
>>> if 'bar' in 'foobar': print 'True'
True
</pre>


<div class="trnote">

<p><b>Poznámka pøekladatele:</b> Podle mého názoru uvedenı pøíklad zbyteènì
kombinuje pøímo nesouvisející vìci a svádí tak zaèáteèníky na scestí.</p>

<ol>
<li>Pro demonstraci není vùbec nutné pouívat konstrukci <code>if</code>.</li>
<li>Tisknout <code>True</code>, pokud je vısledek vırazu <code>True</code>
  navozuje pøedstavu, e jinak to není moné ukázat.</li>
</ol>

<p>Za didaktiètìjší pokládám pøímé zobrazení vısledku vırazu:</p>

<pre>
>>> print 'foo' in 'foobar'
True
>>> print 'baz' in 'foobar'
False
>>> print 'bar' in 'foobar'
True
</pre>

<p>Liší se to sice tím, e se v druhém pøípadì tiskne <code>False</code>,
zatímco v pùvodním pøíkladu se netiskne nic, ale asi to není na závadu. V
interaktivním reimu mùeme dokonce vynechat pøíkaz <code>print</code>: </p>

<pre>
>>> 'foo' in 'foobar'
True
>>> 'baz' in 'foobar'
False
>>> 'bar' in 'foobar'
True
</pre>

</div>

<p>K vyhledávání je to zatím vše. Teï se podívejme, jak mùeme provádìt
náhrady textu.</p>


<h3>Náhrada textu</h3>

<p>Kdy nalezneme hledanı podøetìzec, èasto jej chceme zmìnit na nìco
jiného. Øešení se nám nabízí v podobì metody <code>replace()</code>, kterou
nalezneme mezi metodami pro pythonovskı typ øetìzec. Vyaduje zadání dvou
argumentù: vyhledávanı podøetìzec a øetìzec, kterım bude nahrazen. Metoda
vrací novı øetìzec, kterı je vısledkem náhrady.</p>

<pre>
>>> retezec = 'Jedna, dvì / Honza jde / nese pytel s brouky'
>>> print retezec.replace('s brouky', 'mouky')
Jedna, dvì / Honza jde / nese pytel mouky
</pre>

<p>Zajímavé je, e metoda <code>replace()</code> standardnì nahrazuje
<em>všechny vıskyty</em> vyhledaného øetìzce a ne jen první vıskyt, narozdíl
od metody <code>find()</code>. <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(Není to zase tak pøekvapující, pokud si
uvìdomíme, e <code>find()</code> by pøi vyhledávání všech vıskytù musela
vracet seznam pozic. Bráno z opaèného konce, u metody <code>replace()</code>
&mdash; pokud by nahrazovala standardnì jen první vıskyt &mdash; bychom zase
nìjakım zpùsobem museli umìt pøedepsat náhradu všech vıskytù.)</span>
Maximální poèet náhrad mùeme omezit zadáním nepovinného argumentu
<code>count</code> (tj. poèet):</p>

<pre>
>>> retezec = 'Haf, òaf, blaf, øekl pejsek.'
>>> print retezec.replace('af', 'afiky')
Hafiky, òafiky, blafiky, øekl pejsek.
>>> print retezec.replace('af', 'afiky', 1) <span class="comment"># jen první vıskyt</span>
Hafiky, òaf, blaf, øekl pejsek.
</pre>

<p>Mnohem dùmyslnìjší operace vyhledávání a náhrad mùeme provádìt pomocí
nástroje zvaného <em>regulární vırazy</em>. Ale práce regulárními vırazy je
mnohem sloitìjší, a proto si zaslouí <a href="cztutregex.html">vlastní
téma</a> v èásti <em>Témata pro pokroèilé</em>.</p>

<h3>Zmìna velikosti písmen</h3>

<p>Poslední vìc, kterou se v této èásti budeme zabıvat, je zmìna malıch
písmen na velá a naopak. Není to tak úplnì bìná operace, ale Python nám pro
tento úèel nabízí pár metod:</p>

<pre>
>>> print u'SMÍšenİ PØípad: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ'.lower()
smíšenı pøípad: ìšèøıáíéúùó ìšèøıáíéúù
>>> print u'SMÍšenİ PØípad: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ'.upper()
SMÍŠENİ PØÍPAD: ÌŠÈØİÁÍÉÚÙÓ ÌŠÈØİÁÍÉÚÙ
>>> print u'SMÍšenİ PØípad: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ'.swapcase()
smíŠENı pøÍPAD: ÌŠÈØİÁÍÉÚÙÓ ìšèøıáíéúù
>>> print u'SMÍšenİ PØípad: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ'.capitalize()
Smíšenı pøípad: ìšèøıáíéúùó ìšèøıáíéúù
>>> print u'TEST'.isupper()
True
>>> print u'TEST'.islower()
False
</pre>

<p>Povšimnìte si, e metoda <code>capitalize()</code> <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(z anglického <em>capital letter</em>,
èili velké písmeno)</span> provádí zvìtšení prvního písmene pro øetìzec jako
celek, nikoliv pro kadé slovo zvláš. Všimnìte si také dvou funcí pro
otestování øetìzce <span class="trnote" title="Poznámka&nbsp;pøekladatele"
>na urèitou vlastnost</span> (neboli <em>predikátù</em>). K dalším uiteènım
testùm patøí <code>isalpha()</code> a <code>isspace()</code>. Poslední
zmínìná funkce kontroluje, zda se v øetìzci vyskytují jen <em>bílé
znaky</em>, tedy nejen mezery <span class="trnote"
title="Poznámka&nbsp;pøekladatele">(tj. také tabulátory, konce
øádkù...)</span>.</p>

<p>V dalších èástech kurzu budeme mnohé z uvedenıch øetìzcovıch metod
pouívat. Zejména <a href="cztutcase.html">Pøípadová studie gramatického
poèítadla</a> jich pouívá nìkolik najednou.</p>

<div class="trnote">

<p><b>Poznámka pøekladatele:</b> Povšimnìte si, e ve vıše uvedené ukázce
øetìzcovıch metod jsou všechny literály (øetìzcové konstanty) zapsány jako
Unicode øetìzce &mdash; na zaèátku, pøed prvním apostrofem mají uvedeno
písmeno <code><b>u</b></code>. V originálním anglickém textu tomu tak není.
Ale èeština pouívá znaky, které nepatøí do kódu ASCII, a proto vıznam kódu
znaku závisí na tom, jaké kódování pouíváme.</p>

<p>Pythonovskı string, kterı není uloen v kódování Unicode, s sebou nenese
ádnou informaci o pouitém kódování. Python takovı øetìzec chápe jako
posloupnost bajtù. Nemá odkud vzít informaci o tom, e velké písmeno k znaku
s kódem 249 má kód 217. Napøíklad v kódování <code>windows-1250</code> jde o
znaky <code>ùÙ</code>. V jinıch kódováních ovšem uvedené kódy mohou patøit
zcela jinım znakùm, nemusí vùbec tvoøit pár malé/velké písmeno a dokonce
vùbec nemusí patøit mezi písmena.</p>

<p>ASCII znaky &mdash; tj. ty, které mají kód v rozsahu 0 a 127 &mdash;
pøedstavují vıjimku v tom smyslu, e mají stejnı kód ve všech odvozenıch
kódováních (kódy ASCII znakù jsou zachovány i v Unicode). Metody pro zmìnu
velikosti písmen tedy mohou bez problémù nad tìmito znaky fungovat i bez
znalosti pouívaného kódování pro písmena s vìtším kódem. Podívejme se, co
Python provede, kdy bychom v pøíkladu neuvedli øetìzce v Unicode:</p>

<pre>
>>> print 'SMÍšenİ PØípad: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ'.lower()
smÍšenİ pØípad: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ
>>> print 'SMÍšenİ PØípad: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ'.upper()
SMÍšENİ PØíPAD: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ
>>> print 'SMÍšenİ PØípad: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ'.swapcase()
smÍšENİ pØíPAD: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ
>>> print 'SMÍšenİ PØípad: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ'.capitalize()
SmÍšenİ pØípad: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ
>>> print 'ÌŠÈØİÁÍÉ'.islower()
False
>>> print 'ÌŠÈØİÁÍÉ'.isupper()
False
</pre>

<p>Všechna písmena v rozsahu ASCII jsou správnì pøevedena, ale všechna
ostatní písmena byla ponechána beze zmìny. Metoda neví, co s nimi, proto je
ponechá v pùvodním tvaru. Uvìdomte si, e je to pøirozené chování metod v
pøípadech, kdy zpracovávají znaky, která nejsou písmenem. Existují také
písmena, která nemají definováno odpovídající malé nebo velké písmeno
(napøíklad nìmecké ostré s). Všimnìte si, e predikáty
<code>islower()</code> a <code>isupper()</code> zde nepovaují testované
øetìze ani za malá ani za velká písmena.</p>

<p>Unicode øetìzce jsou ovšem speciálnìjší, informaènì bohatší. Písmena jsou
urèena jednoznaènì a existuje i jednoznaènı vztah mezi malım a velkım
písmenem (pokud to u znaku dává smysl). Metody pro pøevody písmen z malıch
na velká a naopak nemusí zohledòovat ádné nejednoznaènosti. Pøi pouití
Unicode se tedy i u ostatních lidskıch jazykù dostáváme do stejnì pohodové
situace, v jaké o podobnıch øetìzcovıch operacích píší anglicky mluvící
autoøi ;-)</p>

</div>

<h3>Zpracování textu v jazyce VBScript</h3>

<p>VBScript vychází z jazyka BASIC. Díky tomu disponuje celou øadou
zabudovanıch funkcí pro práci s øetìzci. V referenèní pøíruèce jsem jich
napoèítal nejménì 20 a to jsem nepoèítal ty, které se vztahují k zpracování
znakù v Unicode.</p>

<p>To znamená, e v jazyce VBScript mùeme <span class="trnote"
title="Poznámka&nbsp;pøekladatele">s&nbsp;øetìzci</span> dìlat v podstatì vše,
co jsme si ukazovali v jazyce Python. V rychlosti si ukáeme jeho
monosti:</p>


<h4>Rozdìlování textu</h4>

<p>Zaèneme funkcí <code>Split</code>:</p>

<pre>
&lt;script type="text/vbscript">
Dim retezec
Dim seznam
retezec = "Toto je seznam slov."
seznam = Split(retezec) <span class="comment">' vrací pole</span>
MsgBox seznam(1)
&lt;/script>
</pre>

<p>Pokud nám rozdìlování øetìzce v místech s bílımi znaky (zde mezerami)
nevyhovuje, mùeme stejnì jako v Pythonu pøedepsat hodnotu oddìlovaèe.</p>

<p>Pro opaènı postup zde máme funkci <code>Join</code> &mdash; stejnì jako v
jazyce Python.</p>


<h4>Vyhledávání a náhrada v textu</h4>

<p>K vyhledávání podøetìzce slouí funkce <code>InStr</code>, co je zjevnì
zkratka z anglického <em>In&nbsp;String</em>, tedy
<em>v&nbsp;øetìzci</em>.</p>

<pre>
&lt;script type="text/vbscript">
Dim s, n
s = "Toto je dlouhı textovı øetìzec."
n = InStr(s, "dlouhı")
MsgBox "Slovo 'dlouhı' bylo nalezeno na pozici: " &amp; CStr(n)
&lt;/script>
</pre>

<p>Návratová hodnota obvykle udává pozici v pùvodním øetìzci, na které zaèíná
vyhledávanı podøetìzec. Pokud není nalezen, vrací se nula. (V jazyce VBScript
to nepùsobí ádnı problém, protoe se v nìm indexuje od jednièky. To znamená,
e hodnota nula nereprezentuje platnou hodnotu indexu.) Pokud má øetìzec
hodnotu <code>Null</code>, vrací se hodnota <code>Null</code>. Tím se ponìkud
komplikuje ovìøování, zda nedošlo k chybì.</p>

<p>Stejnì jako v Pythonu mùeme i v jazyce VBScript vymezit èást pùvodního
øetìzce, která se má prohledávat. Mùeme uvést index, od kterého se má zaèít
vyhledávat:</p>


<pre>
&lt;script type="text/vbscript">
Dim s, n
s = "Toto je dlouhı textovı øetìzec."
n = InStr(6, s, "dlouhı")  <span class="comment">' Hledej od pozice 6.</span>
MsgBox "Slovo 'dlouhı' bylo nalezeno na pozici: " &amp; CStr(n)
&lt;/script>
</pre>

<p>Narozdíl od Pythonu mùeme v jazyce VBScript pøedepsat také to, zda se mají
pøi vyhledávání rozlišovat velká a malá písmena, èi nikoliv. Pokud to
neurèíme, velká a malá písmena se rozlišují.</p>

<p>Náhrady textu se provádìjí prostøednictvím funkce <code>Replace</code>:</p>

<pre>
&lt;script type="text/vbscript">
Dim s
s = "Pøíšernì zeleòouèkı kùò úpìl ïábelské ódy."
MsgBox Replace(s, "zeleòouèkı", "luouèkı")
&lt;/script>
</pre>

<p>Poslední nepovinnı argument urèuje, kolik vıskytù vyhledávaného vrorku se
má nahradit. Pokud neurèíme jinak, nahrazují se všechny vıskyty. Mùeme urèit
i poèáteèní pozici pro prohledávání a náhradu, jako u vıše zmínìné funkce
<code>InStr</code>.</p>


<h4>Zmìna velikosti písmen</h4>

<p>Zmìnu velikosti písmen provádíme v jazyce VBScript funkcemi
<code>UCase</code> a <code>LCase</code>. Ekvivalent pythonovské metody
<code>capitalize()</code> tady nenajdeme.</p>

<pre>
&lt;script type="text/vbscript">
Dim s
s = "SMÍšenİ PØípad: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ"
MsgBox LCase(s)
MsgBox UCase(s)
&lt;/script>
</pre>

<p>To je vše, èím se budeme v této uèebnici zabıvat. Pokud se chcete dozvìdìt
více, projdìte si seznam funkcí v nápovìdì k VBScript.</p>

<p class="trnote"><b>Poznámka pøekladatele:</b> V tomto pøípadì (narozdíl od
stejného øetìzce v pythonovském pøíkladu, kdy øetìzec nebyl uveden v Unicode)
dojde ke korektnímu pøevodu na malá i velká písmena i u znakù s diakritikou.
Je to dáno tím, e VBScript s øetìzci jednoznaènì spojuje urèité kódování.
Pokud je skript vloen do HTML souboru, pak bıvá kódování pøedepsáno v jeho
hlavièce. Stejnì je tomu i u XML souborù. Pokud kódování není pøedepsáno
vùbec, pak VBScript pøedpokládá, e se pouívá kódování definované v
systému.</p>


<h3>Zpracování textu v JavaScript</h3>

<p>JavaScript je z našich tøí jazykù pro zpracování textu vybaven nejhùøe.
I&nbsp;pøesto jsou základní operace do urèité míry podporovány. Ve srovnání s
jazyky Python a VBScript jazyk JavaScript trpí nedostatky, které tkví spíše
jen v mnoství <span title="bells &amp; whistles">"cingrlátek"</span>.
JavaScript tato omezení kompenzuje silnou podporou <em>regulárních
vırazù</em>. (Budeme se jimi zabıvat <a href="cztutregex.html">v jednom z
dalších témat</a>.) Regulární vırazy vıraznì rozšiøují monosti, které
poskytují vıše zmínìné primitivní funkce, ale platíme za to zvıšením
sloitosti.</p>

<p>JavaScript, stejnì jako Python, vyuívá k manipulaci s øetìzci objektovì
orientovanı pøístup. Všechny operace se provádìjí prostøednictvím metod
tøídy <code>String</code>.</p>

<h4>Rozdìlování textu</h4>

<p>Rozdìlování textu se provádí metodou <code>split()</code>:</p>

<pre>
&lt;script type="text/javascript">
var seznam, retezec = "Toto je krátkı øetìzec";
seznam = retezec.split(" ");
document.write(seznam[1]);
&lt;/script>
</pre>

<p>Povšimnìte si, e JavaScript vyaduje zadání oddìlovacího znaku.
Neexistuje zde ádná pøeddefinovaná hodnota. Oddìlovaè mùe bıt definován i
<a href="cztutregex.html">regulárním vırazem</a>, take operace rozdìlení
mùe bıt velmi dùmyslná.</p>

<h4>Vyhledávání textu</h4>

<p>K vyhledávání textu se v jazyce JavaScript pouívá metoda
<code>search()</code>:</p>

<pre>
&lt;script type="text/javascript">
var retezec = "Na Nilu ibisi kvílili bílí...";
document.write("'ibisi' se nachází na pozici: " + retezec.search(/ibisi/));
&lt;/script>
</pre>

<p class="ir">zmatky øetìzec/vzorek</p>

<p>Znovu platí, e vyhledávanı øetìzcovı vzorek je ve skuteènosti
regulárním vırazem. To znamená, e vyhledávání mùe mít velmi dùmyslná
pravidla. Na druhou stranu neexistuje monost vymezit èást pùvodního
øetìzce, která se má prohledávat, zadáním poèáteèní pozice (aèkoliv i tuto
monost mùeme simulovat prostøednictvím regulárního vırazu).</p>

<p>JavaScript podporuje i jinou vyhledávací operaci s mírnì odlišnım
chováním. Nazıvá ze <code>match()</code> <span class="trnote"
title="Poznámka&nbsp;pøekladatele">([meè], zde ve smyslu <em>odpovídat</em>,
<em>pasovat</em>)</span>. V této èástí se metodou <code>match()</code>
nebudeme zabıvat.</p>

<h4>Náhrada textu</h4>

<p class="ir">zmatky øetìzec/vzorek</p>

<p>K nahrazování textu se pouívá metoda <code>replace()</code>.</p>

<pre>
&lt;script type="text/javascript">
var retezec = "Koèka leze dírou, pes dveømi...";
document.write(retezec.replace(/dveømi/, "oknem"));
&lt;/script>
</pre>

<p>A znovu pøipomeòme, e vyhledávanı vzorek mùe bıt zadán regulárním
vırazem. Myslím, e u vidíte ten obecnı vzor. Operace náhrady nahrazuje
všechny vıskyty vyhledávaného vzorku a, pokud mohu øíci, neexistuje ádnı
zpùsob, jak dosáhnout náhrady pouze jednoho vıskytu, ani byste øetìzec
nejdøíve rozdìlili a pak jej opìt pospojovali dohromady.</p>

<p class="ir">zmatky øetìzec/vzorek, poèet náhrad</p>


<h4>Zmìna velikosti písmen</h4>

<p>Pro zmìnu velikosti písmen máme k dispozici dvì funkce:
<code>toLowerCase()</code> a <code>toUpperCase()</code>.
</p>

<pre>
&lt;script type="text/javascript">
var retezec = "SMÍšenİ PØípad: ìšèøıáíéúùó ÌŠÈØİÁÍÉÚÙ";
document.write(retezec.toLowerCase()+ "&lt;br>");
document.write(retezec.toUpperCase()+ "&lt;br>");
&lt;/script>
</pre>

<p>K tìmto funkcím mùeme stìí co dodat. Jednoduchım zpùsobem provádìjí
jednoduchou èinnost. JavaScript &mdash; narozdíl od ostatních jazykù, o
kterıch se bavíme &mdash; nabízí øadu speciálních textovıch funkcí pro
zpracování HTML. Odhaluje tím své koøeny jazyka urèeného pro programování ve
webovém prostøedí. Nebudeme se jimi zabıvat. Popis naleznete ve standardní
dokumentaci.</p>

<p>Tím uzavíráme pohled do svìta zpracování textu. Doufám, e jste tím
získali nástroje, které potøebujete ke zpracování textu ve vašich
projektech. Závìreèná rada zní: Pøi zpracování textu si vdy proètìte
dokumentaci zvoleného jazyka.Øešení nejzákladnìjších programátorskıch
úloh je èasto podpoøeno mocnımi nástroji.</p>

                            
<div class="remember">
<p class="title">Zapamatujte si</p>
<ul>
<li>Soubory musíme pøed pouitím otevøít.</li>
<li>Ze souborù mùeme obvykle jen èíst nebo do nich mùeme jen zapisovat,
  ale ne obojí souèasnì.</li>
<li>Funkce <code>readlines()</code> jazyka Python pøeète všechny øádky
  souboru najednou, zatímco funkce <code>readline()</code> pøeète jen jeden
  øádek. Mùe nám to pomoci šetøit pamìtí.</li>
<li>Po pouití soubor uzavøete.</li>
</ul>
</div>

<div class="foot">
<p class="navig">[ 
<a href="cztutfiles.html" title="Práce se soubory">pøedchozí</a> |
<a href="cztutcont.html">obsah</a> | 
<a href="cztuterrors.html" title="Práce s chybami">další</a> 
]</p>
<p class="note">Pokud vás napadne, co by se dalo na pøekladu této kapitoly
vylepšit, zašlete e-mail odklepnutím

<script type="text/javascript">
var id = new String('$Id: cztuttext.html,v 1.6 2005/10/20 20:52:40 petr Exp $');
var ma = new String('prikryl at skil dot cz');
ma = ma.replace(/ at /, '@');
ma = ma.replace(/ dot /, '.');
document.write('<a href="mailto:' + ma + '?subject=JNP2:%20poznamka' 
               + '&body=Dokument:%20' + id.replace(/\s/g, '%20') 
               + '%0d%0dPoznámky:%0d" '
               + 'title="Tento odkaz spustí váš program pro zasílání pošty."'
               + '>tohoto odkazu<' + '/a>.');
</script> 

Tím budou do dopisu automaticky vloeny informace o tomto HTML dokumentu.</p>

<p class="cvs">$Id: cztuttext.html,v 1.6 2005/10/20 20:52:40 petr Exp $</p>
</div>
</body>
</html>

